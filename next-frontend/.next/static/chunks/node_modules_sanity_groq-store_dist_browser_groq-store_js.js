/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_sanity_groq-store_dist_browser_groq-store_js"],{

/***/ "./node_modules/@sanity/groq-store/dist/browser/groq-store.js":
/*!********************************************************************!*\
  !*** ./node_modules/@sanity/groq-store/dist/browser/groq-store.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("function e(e){return e&&\"object\"==typeof e&&\"default\"in e?e.default:e}var r=e(__webpack_require__(/*! groq */ \"./node_modules/groq/lib/groq.js\")),t=e(__webpack_require__(/*! fast-deep-equal */ \"./node_modules/fast-deep-equal/index.js\")),n=__webpack_require__(/*! throttle-debounce */ \"./node_modules/throttle-debounce/cjs/index.js\"),o=__webpack_require__(/*! groq-js */ \"./node_modules/groq-js/dist/groq-js.esm.js\"),i=__webpack_require__(/*! mendoza */ \"./node_modules/mendoza/lib/esm/index.js\");function u(){return(u=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])}return e}).apply(this,arguments)}function s(e,r,t){var n,o=r.token,i=new e(\"https://\"+r.projectId+\".api.sanity.io/v1/data/listen/\"+r.dataset+\"?query=*&effectFormat=mendoza\",{withCredentials:!0,headers:o?{Authorization:\"Bearer \"+o}:void 0});return i.addEventListener(\"welcome\",t.open,!1),i.addEventListener(\"mutation\",(n=t.next,function(e){var r;try{r=JSON.parse(e.data)}catch(e){return}n(r)}),!1),i.addEventListener(\"channelError\",function(e){var r;i.close();try{r=JSON.parse(e.data)}catch(e){return void t.error(new Error(\"Unknown error parsing listener message\"))}t.error(new Error(r.message||r.error||\"Listener returned HTTP \"+r.statusCode))},!1),i.addEventListener(\"error\",function(e){var r=\"undefined\"!=typeof window&&window.location.origin,n=r?\", and that the CORS-origin (\"+r+\") is allowed\":\"\",o=function(e){return\"object\"==typeof e&&null!==e&&\"message\"in e}(e)?\" (\"+e.message+\")\":\"\";t.error(new Error(\"Error establishing listener - check that the project ID and dataset are correct\"+n+o))},!1),{unsubscribe:function(){return Promise.resolve(i.close())}}}function c(e){return e._id.startsWith(\"drafts.\")?e._id.slice(7):e._id}function a(e,r){var t=u({},e);return delete t._rev,i.applyPatch(t,r)}function f(){return Promise.resolve()}function d(){var e,r,t=(e=[\"*[_id == $id][0]\"],r||(r=e.slice(0)),e.raw=r,e);return d=function(){return t},t}function v(e,r,t){if(!e.s){if(t instanceof l){if(!t.s)return void(t.o=v.bind(null,e,r));1&r&&(r=t.s),t=t.v}if(t&&t.then)return void t.then(v.bind(null,e,r),v.bind(null,e,2));e.s=r,e.v=t;var n=e.o;n&&n(e)}}var l=function(){function e(){}return e.prototype.then=function(r,t){var n=new e,o=this.s;if(o){var i=1&o?r:t;if(i){try{v(n,1,i(this.v))}catch(e){v(n,2,e)}return n}return this}return this.o=function(e){try{var o=e.v;1&e.s?v(n,1,r?r(o):o):t?v(n,1,t(o)):v(n,2,o)}catch(e){v(n,2,e)}},n},e}();function h(e){return e instanceof l&&1&e.s}var m=function(e){var r=e.projectId,t=e.dataset,n=e.token,o=e.documentLimit;try{return Promise.resolve(fetch(\"https://\"+r+\".api.sanity.io/v1/data/export/\"+t,{credentials:\"include\",headers:n?{Authorization:\"Bearer \"+n}:void 0})).then(function(e){function r(r){var t,n,i=function(e){if(!e)throw new Error(\"Failed to read body from response\");var r,t=!1;function n(){t=!0,r&&r.cancel()}return new ReadableStream({start:function(o){r=e.getReader();var i=new TextDecoder,u=\"\";r.read().then(function e(s){try{if(s.done)return t?Promise.resolve():0===(u=u.trim()).length?(o.close(),Promise.resolve()):(o.enqueue(JSON.parse(u)),o.close(),Promise.resolve());for(var c=(u+=i.decode(s.value,{stream:!0})).split(\"\\n\"),a=0;a<c.length-1;++a){var f=c[a].trim();if(0===f.length)return Promise.resolve();try{o.enqueue(JSON.parse(f))}catch(e){return o.error(e),n(),Promise.resolve()}}if(u=c[c.length-1],!r)return Promise.resolve();var d=function(t,n){try{var o=Promise.resolve(r.read()).then(function(r){e(r)})}catch(e){return n(e)}return o&&o.then?o.then(void 0,n):o}(0,function(e){o.error(e)});return Promise.resolve(d&&d.then?d.then(function(){}):void 0)}catch(e){return Promise.reject(e)}}).catch(function(e){return o.error(e)})},cancel:n})}(e.body).getReader(),u=[],s=function(e,r){var t;do{var n=e();if(n&&n.then){if(!h(n)){t=!0;break}n=n.v}var o=r();if(h(o)&&(o=o.v),!o)return n}while(!o.then);var i=new l,u=v.bind(null,i,2);return(t?n.then(s):o.then(c)).then(void 0,u),i;function s(t){for(n=t;h(o=r())&&(o=o.v),o;){if(o.then)return void o.then(c).then(void 0,u);if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}}v(i,1,n)}function c(t){if(t){do{if((n=e())&&n.then){if(!h(n))return void n.then(s).then(void 0,u);n=n.v}if(h(t=r())&&(t=t.v),!t)return void v(i,1,n)}while(!t.then);t.then(c).then(void 0,u)}else v(i,1,n)}}(function(){return Promise.resolve(i.read()).then(function(e){if(function(e){return!!e&&\"error\"in e&&\"object\"==typeof e.error&&null!==e.error&&\"description\"in e.error&&\"string\"==typeof e.error.description&&!(\"_id\"in e)}(n=(t=e).value))throw new Error(\"Error streaming dataset: \"+n.error);if(n&&!n._id.startsWith(\"_.\")&&u.push(n),o&&u.length>o)throw i.cancel(\"Reached document limit\"),new Error(\"Error streaming dataset: Reached limit of \"+o+\" documents\")})},function(){return!t.done});return s&&s.then?s.then(function(e){return u}):u}var t=function(){if(200!==e.status)return Promise.resolve(e.json()).then(function(e){throw new Error(\"Error streaming dataset: \"+(\"object\"==typeof(r=e)&&\"error\"in r&&\"message\"in r?r.message||r.error:\"<unknown error>\"));var r})}();return t&&t.then?t.then(r):r()})}catch(e){return Promise.reject(e)}};exports.groq=r,exports.groqStore=function(e){if(function(){var e=[\"EventSource\",\"ReadableStream\",\"fetch\"].filter(function(e){return!(e in window)});if(e.length>0)throw new Error(\"Browser not supported. Missing browser APIs: \"+e.join(\", \"))}(),e.token)throw new Error(\"`token` option not currently supported in browser\");return function(e,i){var v,l=function(e,r){try{return Promise.resolve(h()).then(function(){var t=o.parse(e,{params:r});return Promise.resolve(o.evaluate(t,{dataset:m,params:r})).then(function(e){return e.get()})})}catch(e){return Promise.reject(e)}},h=function(){try{return v||(v=function(e,r,t){var n=t.getDocuments,o=t.EventSource,i=e.projectId,d=e.dataset,v=e.overlayDrafts,l=e.documentLimit;if(!e.listen)return{unsubscribe:f,loaded:n({projectId:i,dataset:d,documentLimit:l}).then(j).then(f)};var h,m,p,w,b,g,y=new Map,P=[],E=new Promise(function(e,r){m=e,p=r});return{unsubscribe:s(o,e,{next:function(e){h?(function(e){if(e.effects&&!e.documentId.startsWith(\"_.\")){var r=y.get(e.documentId)||null;!function(e,r){var t=y.get(e),n=h||[],o=t?n.indexOf(t):-1;-1===o&&r?(n.push(r),y.set(e,r)):r?(n.splice(o,1,r),y.set(e,r)):(n.splice(o,1),y.delete(e))}(e.documentId,a(r,e.effects.apply))}}(e),function(e,r){clearTimeout(g),b!==r.transactionId&&w?(j(w),b=void 0):(b=r.transactionId,w=e.slice()),g=setTimeout(j,25,e.slice())}(h,e)):P.push(e)},open:function(){try{return Promise.resolve(n({projectId:i,dataset:d,documentLimit:l})).then(function(e){(h=function(e,r){var t=new Map;return r.forEach(function(e){var r=t.get(e.documentId)||[];r.push(e),t.set(e.documentId,r)}),t.forEach(function(r,t){var n=e.find(function(e){return e._id===t});if(n){var o=!1,i=n;r.forEach(function(e){(o=o||e.previousRev===n._rev)&&e.effects&&(i=a(i,e.effects.apply))}),e.splice(e.indexOf(n),1,i)}else console.warn(\"Received mutation for missing document %s\",t)}),e}(e,P)).forEach(function(e){return y.set(e._id,e)}),j(h),m()})}catch(e){return Promise.reject(e)}},error:function(e){return p(e)}}).unsubscribe,loaded:E};function j(e){w=void 0,g=void 0,b=void 0,r(v?function(e){var r=new Map;return e.forEach(function(e){var t=r.get(c(e));e._id.startsWith(\"drafts.\")?r.set(c(e),function(e){return u({},e,{_id:c(e)})}(e)):t||r.set(e._id,e)}),Array.from(r.values())}(e):e)}}(e,function(e){m=e,p()},i)),Promise.resolve(v.loaded).then(function(){})}catch(e){return Promise.reject(e)}},m=[],p=n.throttle(e.subscriptionThrottleMs||50,function(){w.forEach(b)}),w=[];function b(e){return l(e.query,e.params).then(function(r){\"previousResult\"in e&&t(e.previousResult,r)||(e.previousResult=r,e.callback(void 0,r))}).catch(function(r){e.callback(r)})}return{query:l,getDocument:function(e){try{return Promise.resolve(h()).then(function(){return l(r(d()),{id:e})})}catch(e){return Promise.reject(e)}},getDocuments:function(e){try{return Promise.resolve(h()).then(function(){var r=e.map(function(e){return'*[_id == \"'+e+'\"][0]'}).join(\",\\n\");return l(\"[\"+r+\"]\")})}catch(e){return Promise.reject(e)}},subscribe:function(r,t,n){if(!e.listen)throw new Error(\"Cannot use `subscribe()` without `listen: true`\");var o={query:r,params:t,callback:n};w.push(o);var i=!1;return b(o),{unsubscribe:function(){return i||(i=!0,w.splice(w.indexOf(o),1)),Promise.resolve()}}},close:function(){return p.cancel(),v?v.unsubscribe():Promise.resolve()}}}(e,{EventSource:window.EventSource,getDocuments:m})};\r\n//# sourceMappingURL=groq-store.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ncm9xLXN0b3JlL2Rpc3QvYnJvd3Nlci9ncm9xLXN0b3JlLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsd0RBQXdELFFBQVEsbUJBQU8sQ0FBQyw2Q0FBTSxPQUFPLG1CQUFPLENBQUMsZ0VBQWlCLEtBQUssbUJBQU8sQ0FBQyx3RUFBbUIsSUFBSSxtQkFBTyxDQUFDLDJEQUFTLElBQUksbUJBQU8sQ0FBQyx3REFBUyxFQUFFLGFBQWEsb0NBQW9DLFlBQVksbUJBQW1CLEtBQUssbUJBQW1CLHNFQUFzRSxTQUFTLHdCQUF3QixrQkFBa0IsMkhBQTJILDhCQUE4QiwwQkFBMEIsUUFBUSxFQUFFLG1HQUFtRyxNQUFNLElBQUkscUJBQXFCLFNBQVMsT0FBTyxLQUFLLG9EQUFvRCxNQUFNLFVBQVUsSUFBSSxxQkFBcUIsU0FBUyx5RUFBeUUsK0VBQStFLDRDQUE0Qyw4SEFBOEgsa0RBQWtELDBCQUEwQiwwR0FBMEcsTUFBTSx1QkFBdUIsb0NBQW9DLGNBQWMsd0RBQXdELGdCQUFnQixVQUFVLElBQUksdUNBQXVDLGFBQWEseUJBQXlCLGFBQWEsK0RBQStELG9CQUFvQixTQUFTLEdBQUcsa0JBQWtCLFNBQVMsbUJBQW1CLDBDQUEwQyxtQkFBbUIsbUVBQW1FLFlBQVksVUFBVSxTQUFTLGlCQUFpQixjQUFjLHNDQUFzQyxxQkFBcUIsTUFBTSxjQUFjLE1BQU0sSUFBSSxpQkFBaUIsU0FBUyxTQUFTLFNBQVMsWUFBWSwwQkFBMEIsSUFBSSxVQUFVLDZDQUE2QyxTQUFTLFVBQVUsR0FBRyxHQUFHLEdBQUcsY0FBYyw2QkFBNkIsa0JBQWtCLDBEQUEwRCxJQUFJLDhFQUE4RSxpQ0FBaUMsMEJBQTBCLFFBQVEsb0JBQW9CLGNBQWMsc0JBQXNCLDJEQUEyRCxXQUFXLGFBQWEsbUJBQW1CLDJCQUEyQixrQkFBa0IsZ0JBQWdCLDJCQUEyQiw0QkFBNEIsSUFBSSxrSkFBa0osZ0NBQWdDLFVBQVUsbUJBQW1CLGFBQWEsS0FBSyxrQkFBa0IseUNBQXlDLElBQUkseUJBQXlCLFNBQVMseUNBQXlDLCtDQUErQyxvQkFBb0IsSUFBSSxpREFBaUQsS0FBSyxFQUFFLFNBQVMsWUFBWSxvQ0FBb0MsZUFBZSxXQUFXLEVBQUUsb0RBQW9ELFVBQVUsU0FBUywwQkFBMEIsb0JBQW9CLGtCQUFrQixFQUFFLFVBQVUsRUFBRSwwQ0FBMEMsTUFBTSxHQUFHLFVBQVUsY0FBYyxVQUFVLEtBQUssTUFBTSxNQUFNLFVBQVUsNkJBQTZCLGVBQWUsK0JBQStCLCtDQUErQyxjQUFjLFFBQVEsb0JBQW9CLEVBQUUsK0NBQStDLG9CQUFvQiw4Q0FBOEMsT0FBTyxTQUFTLGNBQWMsTUFBTSxHQUFHLG9CQUFvQiw4Q0FBOEMsTUFBTSw2Q0FBNkMsZUFBZSx5QkFBeUIsZUFBZSxZQUFZLGtEQUFrRCxlQUFlLDhJQUE4SSxxRUFBcUUsdUtBQXVLLEVBQUUsWUFBWSxjQUFjLEVBQUUsb0NBQW9DLFNBQVMsSUFBSSxpQkFBaUIsb0VBQW9FLHNJQUFzSSxNQUFNLEVBQUUsR0FBRywrQkFBK0IsRUFBRSxTQUFTLDJCQUEyQixZQUFZLEdBQUcsaUJBQWlCLGFBQWEsY0FBYyxrRUFBa0UscUJBQXFCLEVBQUUsNEZBQTRGLGdGQUFnRixxQkFBcUIsc0JBQXNCLElBQUksNENBQTRDLGlCQUFpQixTQUFTLEVBQUUscUNBQXFDLG1CQUFtQixvQkFBb0IsZUFBZSxFQUFFLEVBQUUsU0FBUywwQkFBMEIsY0FBYyxJQUFJLDZCQUE2QixtR0FBbUcsb0JBQW9CLHdCQUF3QixzQ0FBc0MsbUJBQW1CLDJEQUEyRCxRQUFRLEVBQUUsT0FBTyxtQkFBbUIsaUJBQWlCLGVBQWUsOENBQThDLGdDQUFnQyxlQUFlLDJDQUEyQyw0RkFBNEYscUNBQXFDLGtCQUFrQixvSEFBb0gsaUJBQWlCLGlCQUFpQixJQUFJLDBCQUEwQixzQ0FBc0Msb0JBQW9CLGlCQUFpQixjQUFjLDZCQUE2Qiw4QkFBOEIsZ0NBQWdDLDBCQUEwQix5QkFBeUIsaUJBQWlCLEVBQUUsTUFBTSxhQUFhLHNCQUFzQixtRUFBbUUsNkJBQTZCLGlFQUFpRSxJQUFJLDJCQUEyQixzQkFBc0IsV0FBVyxFQUFFLFNBQVMsMEJBQTBCLG1CQUFtQixhQUFhLHdCQUF3QixjQUFjLDJDQUEyQyxjQUFjLDZCQUE2QixrQkFBa0IsbURBQW1ELFdBQVcsSUFBSSxTQUFTLEVBQUUsdUJBQXVCLHlCQUF5QixRQUFRLGVBQWUsUUFBUSxnREFBZ0QsRUFBRSxTQUFTLDBCQUEwQiwyREFBMkQsYUFBYSxPQUFPLGNBQWMsNENBQTRDLHVGQUF1RixvQkFBb0IsY0FBYyxFQUFFLE9BQU8sZ0NBQWdDLElBQUksNENBQTRDLGlCQUFpQixLQUFLLEVBQUUsRUFBRSxTQUFTLDBCQUEwQiwwQkFBMEIsSUFBSSw0Q0FBNEMsd0JBQXdCLDZCQUE2QixjQUFjLG9CQUFvQixFQUFFLFNBQVMsMEJBQTBCLDJCQUEyQixnRkFBZ0YsT0FBTyw2QkFBNkIsVUFBVSxTQUFTLGFBQWEsdUJBQXVCLDhEQUE4RCxrQkFBa0Isd0RBQXdELElBQUksOENBQThDO0FBQzVsUSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNhbml0eS9ncm9xLXN0b3JlL2Rpc3QvYnJvd3Nlci9ncm9xLXN0b3JlLmpzP2I5MTEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZShlKXtyZXR1cm4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUmJlwiZGVmYXVsdFwiaW4gZT9lLmRlZmF1bHQ6ZX12YXIgcj1lKHJlcXVpcmUoXCJncm9xXCIpKSx0PWUocmVxdWlyZShcImZhc3QtZGVlcC1lcXVhbFwiKSksbj1yZXF1aXJlKFwidGhyb3R0bGUtZGVib3VuY2VcIiksbz1yZXF1aXJlKFwiZ3JvcS1qc1wiKSxpPXJlcXVpcmUoXCJtZW5kb3phXCIpO2Z1bmN0aW9uIHUoKXtyZXR1cm4odT1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihlKXtmb3IodmFyIHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKXt2YXIgdD1hcmd1bWVudHNbcl07Zm9yKHZhciBuIGluIHQpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsbikmJihlW25dPXRbbl0pfXJldHVybiBlfSkuYXBwbHkodGhpcyxhcmd1bWVudHMpfWZ1bmN0aW9uIHMoZSxyLHQpe3ZhciBuLG89ci50b2tlbixpPW5ldyBlKFwiaHR0cHM6Ly9cIityLnByb2plY3RJZCtcIi5hcGkuc2FuaXR5LmlvL3YxL2RhdGEvbGlzdGVuL1wiK3IuZGF0YXNldCtcIj9xdWVyeT0qJmVmZmVjdEZvcm1hdD1tZW5kb3phXCIse3dpdGhDcmVkZW50aWFsczohMCxoZWFkZXJzOm8/e0F1dGhvcml6YXRpb246XCJCZWFyZXIgXCIrb306dm9pZCAwfSk7cmV0dXJuIGkuYWRkRXZlbnRMaXN0ZW5lcihcIndlbGNvbWVcIix0Lm9wZW4sITEpLGkuYWRkRXZlbnRMaXN0ZW5lcihcIm11dGF0aW9uXCIsKG49dC5uZXh0LGZ1bmN0aW9uKGUpe3ZhciByO3RyeXtyPUpTT04ucGFyc2UoZS5kYXRhKX1jYXRjaChlKXtyZXR1cm59bihyKX0pLCExKSxpLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFubmVsRXJyb3JcIixmdW5jdGlvbihlKXt2YXIgcjtpLmNsb3NlKCk7dHJ5e3I9SlNPTi5wYXJzZShlLmRhdGEpfWNhdGNoKGUpe3JldHVybiB2b2lkIHQuZXJyb3IobmV3IEVycm9yKFwiVW5rbm93biBlcnJvciBwYXJzaW5nIGxpc3RlbmVyIG1lc3NhZ2VcIikpfXQuZXJyb3IobmV3IEVycm9yKHIubWVzc2FnZXx8ci5lcnJvcnx8XCJMaXN0ZW5lciByZXR1cm5lZCBIVFRQIFwiK3Iuc3RhdHVzQ29kZSkpfSwhMSksaS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixmdW5jdGlvbihlKXt2YXIgcj1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cubG9jYXRpb24ub3JpZ2luLG49cj9cIiwgYW5kIHRoYXQgdGhlIENPUlMtb3JpZ2luIChcIityK1wiKSBpcyBhbGxvd2VkXCI6XCJcIixvPWZ1bmN0aW9uKGUpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJtZXNzYWdlXCJpbiBlfShlKT9cIiAoXCIrZS5tZXNzYWdlK1wiKVwiOlwiXCI7dC5lcnJvcihuZXcgRXJyb3IoXCJFcnJvciBlc3RhYmxpc2hpbmcgbGlzdGVuZXIgLSBjaGVjayB0aGF0IHRoZSBwcm9qZWN0IElEIGFuZCBkYXRhc2V0IGFyZSBjb3JyZWN0XCIrbitvKSl9LCExKSx7dW5zdWJzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGkuY2xvc2UoKSl9fX1mdW5jdGlvbiBjKGUpe3JldHVybiBlLl9pZC5zdGFydHNXaXRoKFwiZHJhZnRzLlwiKT9lLl9pZC5zbGljZSg3KTplLl9pZH1mdW5jdGlvbiBhKGUscil7dmFyIHQ9dSh7fSxlKTtyZXR1cm4gZGVsZXRlIHQuX3JldixpLmFwcGx5UGF0Y2godCxyKX1mdW5jdGlvbiBmKCl7cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpfWZ1bmN0aW9uIGQoKXt2YXIgZSxyLHQ9KGU9W1wiKltfaWQgPT0gJGlkXVswXVwiXSxyfHwocj1lLnNsaWNlKDApKSxlLnJhdz1yLGUpO3JldHVybiBkPWZ1bmN0aW9uKCl7cmV0dXJuIHR9LHR9ZnVuY3Rpb24gdihlLHIsdCl7aWYoIWUucyl7aWYodCBpbnN0YW5jZW9mIGwpe2lmKCF0LnMpcmV0dXJuIHZvaWQodC5vPXYuYmluZChudWxsLGUscikpOzEmciYmKHI9dC5zKSx0PXQudn1pZih0JiZ0LnRoZW4pcmV0dXJuIHZvaWQgdC50aGVuKHYuYmluZChudWxsLGUsciksdi5iaW5kKG51bGwsZSwyKSk7ZS5zPXIsZS52PXQ7dmFyIG49ZS5vO24mJm4oZSl9fXZhciBsPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5wcm90b3R5cGUudGhlbj1mdW5jdGlvbihyLHQpe3ZhciBuPW5ldyBlLG89dGhpcy5zO2lmKG8pe3ZhciBpPTEmbz9yOnQ7aWYoaSl7dHJ5e3YobiwxLGkodGhpcy52KSl9Y2F0Y2goZSl7dihuLDIsZSl9cmV0dXJuIG59cmV0dXJuIHRoaXN9cmV0dXJuIHRoaXMubz1mdW5jdGlvbihlKXt0cnl7dmFyIG89ZS52OzEmZS5zP3YobiwxLHI/cihvKTpvKTp0P3YobiwxLHQobykpOnYobiwyLG8pfWNhdGNoKGUpe3YobiwyLGUpfX0sbn0sZX0oKTtmdW5jdGlvbiBoKGUpe3JldHVybiBlIGluc3RhbmNlb2YgbCYmMSZlLnN9dmFyIG09ZnVuY3Rpb24oZSl7dmFyIHI9ZS5wcm9qZWN0SWQsdD1lLmRhdGFzZXQsbj1lLnRva2VuLG89ZS5kb2N1bWVudExpbWl0O3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZldGNoKFwiaHR0cHM6Ly9cIityK1wiLmFwaS5zYW5pdHkuaW8vdjEvZGF0YS9leHBvcnQvXCIrdCx7Y3JlZGVudGlhbHM6XCJpbmNsdWRlXCIsaGVhZGVyczpuP3tBdXRob3JpemF0aW9uOlwiQmVhcmVyIFwiK259OnZvaWQgMH0pKS50aGVuKGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIocil7dmFyIHQsbixpPWZ1bmN0aW9uKGUpe2lmKCFlKXRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byByZWFkIGJvZHkgZnJvbSByZXNwb25zZVwiKTt2YXIgcix0PSExO2Z1bmN0aW9uIG4oKXt0PSEwLHImJnIuY2FuY2VsKCl9cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7c3RhcnQ6ZnVuY3Rpb24obyl7cj1lLmdldFJlYWRlcigpO3ZhciBpPW5ldyBUZXh0RGVjb2Rlcix1PVwiXCI7ci5yZWFkKCkudGhlbihmdW5jdGlvbiBlKHMpe3RyeXtpZihzLmRvbmUpcmV0dXJuIHQ/UHJvbWlzZS5yZXNvbHZlKCk6MD09PSh1PXUudHJpbSgpKS5sZW5ndGg/KG8uY2xvc2UoKSxQcm9taXNlLnJlc29sdmUoKSk6KG8uZW5xdWV1ZShKU09OLnBhcnNlKHUpKSxvLmNsb3NlKCksUHJvbWlzZS5yZXNvbHZlKCkpO2Zvcih2YXIgYz0odSs9aS5kZWNvZGUocy52YWx1ZSx7c3RyZWFtOiEwfSkpLnNwbGl0KFwiXFxuXCIpLGE9MDthPGMubGVuZ3RoLTE7KythKXt2YXIgZj1jW2FdLnRyaW0oKTtpZigwPT09Zi5sZW5ndGgpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO3RyeXtvLmVucXVldWUoSlNPTi5wYXJzZShmKSl9Y2F0Y2goZSl7cmV0dXJuIG8uZXJyb3IoZSksbigpLFByb21pc2UucmVzb2x2ZSgpfX1pZih1PWNbYy5sZW5ndGgtMV0sIXIpcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO3ZhciBkPWZ1bmN0aW9uKHQsbil7dHJ5e3ZhciBvPVByb21pc2UucmVzb2x2ZShyLnJlYWQoKSkudGhlbihmdW5jdGlvbihyKXtlKHIpfSl9Y2F0Y2goZSl7cmV0dXJuIG4oZSl9cmV0dXJuIG8mJm8udGhlbj9vLnRoZW4odm9pZCAwLG4pOm99KDAsZnVuY3Rpb24oZSl7by5lcnJvcihlKX0pO3JldHVybiBQcm9taXNlLnJlc29sdmUoZCYmZC50aGVuP2QudGhlbihmdW5jdGlvbigpe30pOnZvaWQgMCl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0pLmNhdGNoKGZ1bmN0aW9uKGUpe3JldHVybiBvLmVycm9yKGUpfSl9LGNhbmNlbDpufSl9KGUuYm9keSkuZ2V0UmVhZGVyKCksdT1bXSxzPWZ1bmN0aW9uKGUscil7dmFyIHQ7ZG97dmFyIG49ZSgpO2lmKG4mJm4udGhlbil7aWYoIWgobikpe3Q9ITA7YnJlYWt9bj1uLnZ9dmFyIG89cigpO2lmKGgobykmJihvPW8udiksIW8pcmV0dXJuIG59d2hpbGUoIW8udGhlbik7dmFyIGk9bmV3IGwsdT12LmJpbmQobnVsbCxpLDIpO3JldHVybih0P24udGhlbihzKTpvLnRoZW4oYykpLnRoZW4odm9pZCAwLHUpLGk7ZnVuY3Rpb24gcyh0KXtmb3Iobj10O2gobz1yKCkpJiYobz1vLnYpLG87KXtpZihvLnRoZW4pcmV0dXJuIHZvaWQgby50aGVuKGMpLnRoZW4odm9pZCAwLHUpO2lmKChuPWUoKSkmJm4udGhlbil7aWYoIWgobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fX12KGksMSxuKX1mdW5jdGlvbiBjKHQpe2lmKHQpe2Rve2lmKChuPWUoKSkmJm4udGhlbil7aWYoIWgobikpcmV0dXJuIHZvaWQgbi50aGVuKHMpLnRoZW4odm9pZCAwLHUpO249bi52fWlmKGgodD1yKCkpJiYodD10LnYpLCF0KXJldHVybiB2b2lkIHYoaSwxLG4pfXdoaWxlKCF0LnRoZW4pO3QudGhlbihjKS50aGVuKHZvaWQgMCx1KX1lbHNlIHYoaSwxLG4pfX0oZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGkucmVhZCgpKS50aGVuKGZ1bmN0aW9uKGUpe2lmKGZ1bmN0aW9uKGUpe3JldHVybiEhZSYmXCJlcnJvclwiaW4gZSYmXCJvYmplY3RcIj09dHlwZW9mIGUuZXJyb3ImJm51bGwhPT1lLmVycm9yJiZcImRlc2NyaXB0aW9uXCJpbiBlLmVycm9yJiZcInN0cmluZ1wiPT10eXBlb2YgZS5lcnJvci5kZXNjcmlwdGlvbiYmIShcIl9pZFwiaW4gZSl9KG49KHQ9ZSkudmFsdWUpKXRocm93IG5ldyBFcnJvcihcIkVycm9yIHN0cmVhbWluZyBkYXRhc2V0OiBcIituLmVycm9yKTtpZihuJiYhbi5faWQuc3RhcnRzV2l0aChcIl8uXCIpJiZ1LnB1c2gobiksbyYmdS5sZW5ndGg+byl0aHJvdyBpLmNhbmNlbChcIlJlYWNoZWQgZG9jdW1lbnQgbGltaXRcIiksbmV3IEVycm9yKFwiRXJyb3Igc3RyZWFtaW5nIGRhdGFzZXQ6IFJlYWNoZWQgbGltaXQgb2YgXCIrbytcIiBkb2N1bWVudHNcIil9KX0sZnVuY3Rpb24oKXtyZXR1cm4hdC5kb25lfSk7cmV0dXJuIHMmJnMudGhlbj9zLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIHV9KTp1fXZhciB0PWZ1bmN0aW9uKCl7aWYoMjAwIT09ZS5zdGF0dXMpcmV0dXJuIFByb21pc2UucmVzb2x2ZShlLmpzb24oKSkudGhlbihmdW5jdGlvbihlKXt0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBzdHJlYW1pbmcgZGF0YXNldDogXCIrKFwib2JqZWN0XCI9PXR5cGVvZihyPWUpJiZcImVycm9yXCJpbiByJiZcIm1lc3NhZ2VcImluIHI/ci5tZXNzYWdlfHxyLmVycm9yOlwiPHVua25vd24gZXJyb3I+XCIpKTt2YXIgcn0pfSgpO3JldHVybiB0JiZ0LnRoZW4/dC50aGVuKHIpOnIoKX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19O2V4cG9ydHMuZ3JvcT1yLGV4cG9ydHMuZ3JvcVN0b3JlPWZ1bmN0aW9uKGUpe2lmKGZ1bmN0aW9uKCl7dmFyIGU9W1wiRXZlbnRTb3VyY2VcIixcIlJlYWRhYmxlU3RyZWFtXCIsXCJmZXRjaFwiXS5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuIShlIGluIHdpbmRvdyl9KTtpZihlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcihcIkJyb3dzZXIgbm90IHN1cHBvcnRlZC4gTWlzc2luZyBicm93c2VyIEFQSXM6IFwiK2Uuam9pbihcIiwgXCIpKX0oKSxlLnRva2VuKXRocm93IG5ldyBFcnJvcihcImB0b2tlbmAgb3B0aW9uIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGluIGJyb3dzZXJcIik7cmV0dXJuIGZ1bmN0aW9uKGUsaSl7dmFyIHYsbD1mdW5jdGlvbihlLHIpe3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGgoKSkudGhlbihmdW5jdGlvbigpe3ZhciB0PW8ucGFyc2UoZSx7cGFyYW1zOnJ9KTtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG8uZXZhbHVhdGUodCx7ZGF0YXNldDptLHBhcmFtczpyfSkpLnRoZW4oZnVuY3Rpb24oZSl7cmV0dXJuIGUuZ2V0KCl9KX0pfWNhdGNoKGUpe3JldHVybiBQcm9taXNlLnJlamVjdChlKX19LGg9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIHZ8fCh2PWZ1bmN0aW9uKGUscix0KXt2YXIgbj10LmdldERvY3VtZW50cyxvPXQuRXZlbnRTb3VyY2UsaT1lLnByb2plY3RJZCxkPWUuZGF0YXNldCx2PWUub3ZlcmxheURyYWZ0cyxsPWUuZG9jdW1lbnRMaW1pdDtpZighZS5saXN0ZW4pcmV0dXJue3Vuc3Vic2NyaWJlOmYsbG9hZGVkOm4oe3Byb2plY3RJZDppLGRhdGFzZXQ6ZCxkb2N1bWVudExpbWl0Omx9KS50aGVuKGopLnRoZW4oZil9O3ZhciBoLG0scCx3LGIsZyx5PW5ldyBNYXAsUD1bXSxFPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGUscil7bT1lLHA9cn0pO3JldHVybnt1bnN1YnNjcmliZTpzKG8sZSx7bmV4dDpmdW5jdGlvbihlKXtoPyhmdW5jdGlvbihlKXtpZihlLmVmZmVjdHMmJiFlLmRvY3VtZW50SWQuc3RhcnRzV2l0aChcIl8uXCIpKXt2YXIgcj15LmdldChlLmRvY3VtZW50SWQpfHxudWxsOyFmdW5jdGlvbihlLHIpe3ZhciB0PXkuZ2V0KGUpLG49aHx8W10sbz10P24uaW5kZXhPZih0KTotMTstMT09PW8mJnI/KG4ucHVzaChyKSx5LnNldChlLHIpKTpyPyhuLnNwbGljZShvLDEscikseS5zZXQoZSxyKSk6KG4uc3BsaWNlKG8sMSkseS5kZWxldGUoZSkpfShlLmRvY3VtZW50SWQsYShyLGUuZWZmZWN0cy5hcHBseSkpfX0oZSksZnVuY3Rpb24oZSxyKXtjbGVhclRpbWVvdXQoZyksYiE9PXIudHJhbnNhY3Rpb25JZCYmdz8oaih3KSxiPXZvaWQgMCk6KGI9ci50cmFuc2FjdGlvbklkLHc9ZS5zbGljZSgpKSxnPXNldFRpbWVvdXQoaiwyNSxlLnNsaWNlKCkpfShoLGUpKTpQLnB1c2goZSl9LG9wZW46ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIFByb21pc2UucmVzb2x2ZShuKHtwcm9qZWN0SWQ6aSxkYXRhc2V0OmQsZG9jdW1lbnRMaW1pdDpsfSkpLnRoZW4oZnVuY3Rpb24oZSl7KGg9ZnVuY3Rpb24oZSxyKXt2YXIgdD1uZXcgTWFwO3JldHVybiByLmZvckVhY2goZnVuY3Rpb24oZSl7dmFyIHI9dC5nZXQoZS5kb2N1bWVudElkKXx8W107ci5wdXNoKGUpLHQuc2V0KGUuZG9jdW1lbnRJZCxyKX0pLHQuZm9yRWFjaChmdW5jdGlvbihyLHQpe3ZhciBuPWUuZmluZChmdW5jdGlvbihlKXtyZXR1cm4gZS5faWQ9PT10fSk7aWYobil7dmFyIG89ITEsaT1uO3IuZm9yRWFjaChmdW5jdGlvbihlKXsobz1vfHxlLnByZXZpb3VzUmV2PT09bi5fcmV2KSYmZS5lZmZlY3RzJiYoaT1hKGksZS5lZmZlY3RzLmFwcGx5KSl9KSxlLnNwbGljZShlLmluZGV4T2YobiksMSxpKX1lbHNlIGNvbnNvbGUud2FybihcIlJlY2VpdmVkIG11dGF0aW9uIGZvciBtaXNzaW5nIGRvY3VtZW50ICVzXCIsdCl9KSxlfShlLFApKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB5LnNldChlLl9pZCxlKX0pLGooaCksbSgpfSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sZXJyb3I6ZnVuY3Rpb24oZSl7cmV0dXJuIHAoZSl9fSkudW5zdWJzY3JpYmUsbG9hZGVkOkV9O2Z1bmN0aW9uIGooZSl7dz12b2lkIDAsZz12b2lkIDAsYj12b2lkIDAscih2P2Z1bmN0aW9uKGUpe3ZhciByPW5ldyBNYXA7cmV0dXJuIGUuZm9yRWFjaChmdW5jdGlvbihlKXt2YXIgdD1yLmdldChjKGUpKTtlLl9pZC5zdGFydHNXaXRoKFwiZHJhZnRzLlwiKT9yLnNldChjKGUpLGZ1bmN0aW9uKGUpe3JldHVybiB1KHt9LGUse19pZDpjKGUpfSl9KGUpKTp0fHxyLnNldChlLl9pZCxlKX0pLEFycmF5LmZyb20oci52YWx1ZXMoKSl9KGUpOmUpfX0oZSxmdW5jdGlvbihlKXttPWUscCgpfSxpKSksUHJvbWlzZS5yZXNvbHZlKHYubG9hZGVkKS50aGVuKGZ1bmN0aW9uKCl7fSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX0sbT1bXSxwPW4udGhyb3R0bGUoZS5zdWJzY3JpcHRpb25UaHJvdHRsZU1zfHw1MCxmdW5jdGlvbigpe3cuZm9yRWFjaChiKX0pLHc9W107ZnVuY3Rpb24gYihlKXtyZXR1cm4gbChlLnF1ZXJ5LGUucGFyYW1zKS50aGVuKGZ1bmN0aW9uKHIpe1wicHJldmlvdXNSZXN1bHRcImluIGUmJnQoZS5wcmV2aW91c1Jlc3VsdCxyKXx8KGUucHJldmlvdXNSZXN1bHQ9cixlLmNhbGxiYWNrKHZvaWQgMCxyKSl9KS5jYXRjaChmdW5jdGlvbihyKXtlLmNhbGxiYWNrKHIpfSl9cmV0dXJue3F1ZXJ5OmwsZ2V0RG9jdW1lbnQ6ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoaCgpKS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIGwocihkKCkpLHtpZDplfSl9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxnZXREb2N1bWVudHM6ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoaCgpKS50aGVuKGZ1bmN0aW9uKCl7dmFyIHI9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuJypbX2lkID09IFwiJytlKydcIl1bMF0nfSkuam9pbihcIixcXG5cIik7cmV0dXJuIGwoXCJbXCIrcitcIl1cIil9KX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fSxzdWJzY3JpYmU6ZnVuY3Rpb24ocix0LG4pe2lmKCFlLmxpc3Rlbil0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgdXNlIGBzdWJzY3JpYmUoKWAgd2l0aG91dCBgbGlzdGVuOiB0cnVlYFwiKTt2YXIgbz17cXVlcnk6cixwYXJhbXM6dCxjYWxsYmFjazpufTt3LnB1c2gobyk7dmFyIGk9ITE7cmV0dXJuIGIobykse3Vuc3Vic2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJuIGl8fChpPSEwLHcuc3BsaWNlKHcuaW5kZXhPZihvKSwxKSksUHJvbWlzZS5yZXNvbHZlKCl9fX0sY2xvc2U6ZnVuY3Rpb24oKXtyZXR1cm4gcC5jYW5jZWwoKSx2P3YudW5zdWJzY3JpYmUoKTpQcm9taXNlLnJlc29sdmUoKX19fShlLHtFdmVudFNvdXJjZTp3aW5kb3cuRXZlbnRTb3VyY2UsZ2V0RG9jdW1lbnRzOm19KX07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyb3Etc3RvcmUuanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@sanity/groq-store/dist/browser/groq-store.js\n");

/***/ }),

/***/ "./node_modules/fast-deep-equal/index.js":
/*!***********************************************!*\
  !*** ./node_modules/fast-deep-equal/index.js ***!
  \***********************************************/
/***/ (function(module) {

"use strict";
eval("\r\n\r\n// do not edit .js files directly - edit src/index.jst\r\n\r\n\r\n\r\nmodule.exports = function equal(a, b) {\r\n  if (a === b) return true;\r\n\r\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\r\n    if (a.constructor !== b.constructor) return false;\r\n\r\n    var length, i, keys;\r\n    if (Array.isArray(a)) {\r\n      length = a.length;\r\n      if (length != b.length) return false;\r\n      for (i = length; i-- !== 0;)\r\n        if (!equal(a[i], b[i])) return false;\r\n      return true;\r\n    }\r\n\r\n\r\n\r\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\r\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\r\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\r\n\r\n    keys = Object.keys(a);\r\n    length = keys.length;\r\n    if (length !== Object.keys(b).length) return false;\r\n\r\n    for (i = length; i-- !== 0;)\r\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\r\n\r\n    for (i = length; i-- !== 0;) {\r\n      var key = keys[i];\r\n\r\n      if (!equal(a[key], b[key])) return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // true if both NaN, false otherwise\r\n  return a!==a && b!==b;\r\n};\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixVQUFVO0FBQy9CO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9mYXN0LWRlZXAtZXF1YWwvaW5kZXguanM/MGJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcclxuXHJcblxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XHJcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xyXG5cclxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XHJcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xyXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcclxuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXHJcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcclxuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcclxuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XHJcblxyXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xyXG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XHJcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcclxuXHJcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXHJcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XHJcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xyXG5cclxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcblxyXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxyXG4gIHJldHVybiBhIT09YSAmJiBiIT09YjtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fast-deep-equal/index.js\n");

/***/ }),

/***/ "./node_modules/groq-js/dist/groq-js.esm.js":
/*!**************************************************!*\
  !*** ./node_modules/groq-js/dist/groq-js.esm.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"evaluate\": function() { return /* binding */ evaluateQuery; },\n/* harmony export */   \"parse\": function() { return /* binding */ parse; }\n/* harmony export */ });\nvar __defProp = Object.defineProperty;\r\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\r\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\r\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\r\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\r\nvar __spreadValues = (a, b) => {\r\n  for (var prop in b || (b = {}))\r\n    if (__hasOwnProp.call(b, prop))\r\n      __defNormalProp(a, prop, b[prop]);\r\n  if (__getOwnPropSymbols)\r\n    for (var prop of __getOwnPropSymbols(b)) {\r\n      if (__propIsEnum.call(b, prop))\r\n        __defNormalProp(a, prop, b[prop]);\r\n    }\r\n  return a;\r\n};\r\nclass MarkProcessor {\r\n  constructor(string3, marks, parseOptions) {\r\n    this.allowBoost = false;\r\n    this.string = string3;\r\n    this.marks = marks;\r\n    this.index = 0;\r\n    this.parseOptions = parseOptions;\r\n  }\r\n  hasMark(pos = 0) {\r\n    return this.index + pos < this.marks.length;\r\n  }\r\n  getMark(pos = 0) {\r\n    return this.marks[this.index + pos];\r\n  }\r\n  shift() {\r\n    this.index += 1;\r\n  }\r\n  process(visitor) {\r\n    const mark = this.marks[this.index];\r\n    this.shift();\r\n    const func = visitor[mark.name];\r\n    if (!func) {\r\n      throw new Error(`Unknown handler: ${mark.name}`);\r\n    }\r\n    return func.call(visitor, this, mark);\r\n  }\r\n  processString() {\r\n    this.shift();\r\n    return this.processStringEnd();\r\n  }\r\n  processStringEnd() {\r\n    const prev = this.marks[this.index - 1];\r\n    const curr = this.marks[this.index];\r\n    this.shift();\r\n    return this.string.slice(prev.position, curr.position);\r\n  }\r\n  slice(len) {\r\n    const pos = this.marks[this.index].position;\r\n    return this.string.slice(pos, pos + len);\r\n  }\r\n}\r\nconst RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/;\r\nfunction parseRFC3339(str) {\r\n  if (RFC3339_REGEX.test(str)) {\r\n    return new Date(str);\r\n  }\r\n  return null;\r\n}\r\nfunction formatRFC3339(d) {\r\n  const year = addLeadingZero(d.getUTCFullYear(), 4);\r\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2);\r\n  const day = addLeadingZero(d.getUTCDate(), 2);\r\n  const hour = addLeadingZero(d.getUTCHours(), 2);\r\n  const minute = addLeadingZero(d.getUTCMinutes(), 2);\r\n  const second = addLeadingZero(d.getUTCSeconds(), 2);\r\n  let fractionalSecond = \"\";\r\n  const millis = d.getMilliseconds();\r\n  if (millis != 0) {\r\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`;\r\n  }\r\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`;\r\n}\r\nfunction addLeadingZero(num, targetLength) {\r\n  let str = num.toString();\r\n  while (str.length < targetLength) {\r\n    str = `0${str}`;\r\n  }\r\n  return str;\r\n}\r\nfunction escapeRegExp(string3) {\r\n  return string3.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\r\n}\r\nfunction pathRegExp(pattern) {\r\n  const re = [];\r\n  for (const part of pattern.split(\".\")) {\r\n    if (part === \"*\") {\r\n      re.push(\"[^.]+\");\r\n    } else if (part === \"**\") {\r\n      re.push(\".*\");\r\n    } else {\r\n      re.push(escapeRegExp(part));\r\n    }\r\n  }\r\n  return new RegExp(`^${re.join(\".\")}$`);\r\n}\r\nclass Path {\r\n  constructor(pattern) {\r\n    this.pattern = pattern;\r\n    this.patternRe = pathRegExp(pattern);\r\n  }\r\n  matches(str) {\r\n    return this.patternRe.test(str);\r\n  }\r\n  toJSON() {\r\n    return this.pattern;\r\n  }\r\n}\r\nclass StreamValue {\r\n  constructor(generator) {\r\n    this.type = \"stream\";\r\n    this.generator = generator;\r\n    this.ticker = null;\r\n    this.isDone = false;\r\n    this.data = [];\r\n  }\r\n  isArray() {\r\n    return true;\r\n  }\r\n  async get() {\r\n    const result = [];\r\n    for await (const value of this) {\r\n      result.push(await value.get());\r\n    }\r\n    return result;\r\n  }\r\n  async *[Symbol.asyncIterator]() {\r\n    let i = 0;\r\n    while (true) {\r\n      for (; i < this.data.length; i++) {\r\n        yield this.data[i];\r\n      }\r\n      if (this.isDone) {\r\n        return;\r\n      }\r\n      await this._nextTick();\r\n    }\r\n  }\r\n  _nextTick() {\r\n    if (this.ticker) {\r\n      return this.ticker;\r\n    }\r\n    let currentResolver;\r\n    const setupTicker = () => {\r\n      this.ticker = new Promise((resolve) => {\r\n        currentResolver = resolve;\r\n      });\r\n    };\r\n    const tick = () => {\r\n      currentResolver();\r\n      setupTicker();\r\n    };\r\n    const fetch = async () => {\r\n      for await (const value of this.generator()) {\r\n        this.data.push(value);\r\n        tick();\r\n      }\r\n      this.isDone = true;\r\n      tick();\r\n    };\r\n    setupTicker();\r\n    fetch();\r\n    return this.ticker;\r\n  }\r\n}\r\nclass StaticValue {\r\n  constructor(data, type) {\r\n    this.data = data;\r\n    this.type = type;\r\n  }\r\n  isArray() {\r\n    return this.type === \"array\";\r\n  }\r\n  async get() {\r\n    return this.data;\r\n  }\r\n  [Symbol.asyncIterator]() {\r\n    if (Array.isArray(this.data)) {\r\n      return function* (data) {\r\n        for (const element of data) {\r\n          yield fromJS(element);\r\n        }\r\n      }(this.data);\r\n    }\r\n    throw new Error(`Cannot iterate over: ${this.type}`);\r\n  }\r\n}\r\nconst NULL_VALUE = new StaticValue(null, \"null\");\r\nconst TRUE_VALUE = new StaticValue(true, \"boolean\");\r\nconst FALSE_VALUE = new StaticValue(false, \"boolean\");\r\nclass DateTime {\r\n  constructor(date) {\r\n    this.date = date;\r\n  }\r\n  static parseToValue(str) {\r\n    const date = parseRFC3339(str);\r\n    if (date) {\r\n      return new StaticValue(new DateTime(date), \"datetime\");\r\n    }\r\n    return NULL_VALUE;\r\n  }\r\n  equals(other) {\r\n    return this.date.getTime() == other.date.getTime();\r\n  }\r\n  add(secs) {\r\n    const copy = new Date(this.date.getTime());\r\n    copy.setTime(copy.getTime() + secs * 1e3);\r\n    return new DateTime(copy);\r\n  }\r\n  difference(other) {\r\n    return (this.date.getTime() - other.date.getTime()) / 1e3;\r\n  }\r\n  compareTo(other) {\r\n    return this.date.getTime() - other.date.getTime();\r\n  }\r\n  toString() {\r\n    return formatRFC3339(this.date);\r\n  }\r\n  toJSON() {\r\n    return this.toString();\r\n  }\r\n}\r\nfunction fromNumber(num) {\r\n  if (Number.isFinite(num)) {\r\n    return new StaticValue(num, \"number\");\r\n  }\r\n  return NULL_VALUE;\r\n}\r\nfunction fromString(str) {\r\n  return new StaticValue(str, \"string\");\r\n}\r\nfunction fromDateTime(dt) {\r\n  return new StaticValue(dt, \"datetime\");\r\n}\r\nfunction fromPath(path2) {\r\n  return new StaticValue(path2, \"path\");\r\n}\r\nfunction isIterator(obj) {\r\n  return obj && typeof obj.next === \"function\";\r\n}\r\nfunction fromJS(val) {\r\n  if (isIterator(val)) {\r\n    return new StreamValue(async function* () {\r\n      for await (const value of val) {\r\n        yield fromJS(value);\r\n      }\r\n    });\r\n  } else if (val === null || val === void 0) {\r\n    return NULL_VALUE;\r\n  }\r\n  return new StaticValue(val, getType(val));\r\n}\r\nfunction getType(data) {\r\n  if (data === null || typeof data === \"undefined\") {\r\n    return \"null\";\r\n  }\r\n  if (Array.isArray(data)) {\r\n    return \"array\";\r\n  }\r\n  if (data instanceof Path) {\r\n    return \"path\";\r\n  }\r\n  if (data instanceof DateTime) {\r\n    return \"datetime\";\r\n  }\r\n  return typeof data;\r\n}\r\nconst TYPE_ORDER = {\r\n  datetime: 1,\r\n  number: 2,\r\n  string: 3,\r\n  boolean: 4\r\n};\r\nfunction partialCompare(a, b) {\r\n  const aType = getType(a);\r\n  const bType = getType(b);\r\n  if (aType !== bType) {\r\n    return null;\r\n  }\r\n  switch (aType) {\r\n    case \"number\":\r\n    case \"boolean\":\r\n      return a - b;\r\n    case \"string\":\r\n      if (a < b)\r\n        return -1;\r\n      if (a > b)\r\n        return 1;\r\n      return 0;\r\n    case \"datetime\":\r\n      return a.compareTo(b);\r\n    default:\r\n      return null;\r\n  }\r\n}\r\nfunction totalCompare(a, b) {\r\n  const aType = getType(a);\r\n  const bType = getType(b);\r\n  const aTypeOrder = TYPE_ORDER[aType] || 100;\r\n  const bTypeOrder = TYPE_ORDER[bType] || 100;\r\n  if (aTypeOrder !== bTypeOrder) {\r\n    return aTypeOrder - bTypeOrder;\r\n  }\r\n  let result = partialCompare(a, b);\r\n  if (result === null) {\r\n    result = 0;\r\n  }\r\n  return result;\r\n}\r\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\r\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g;\r\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g;\r\nconst MAX_TERM_LENGTH = 1024;\r\nfunction matchText(tokens, patterns) {\r\n  if (tokens.length === 0 || patterns.length === 0) {\r\n    return false;\r\n  }\r\n  return patterns.every((pattern) => pattern(tokens));\r\n}\r\nfunction matchTokenize(text) {\r\n  return text.replace(EDGE_CHARS, \"\").match(CHARS) || [];\r\n}\r\nfunction matchAnalyzePattern(text) {\r\n  const termsRe = matchPatternRegex(text);\r\n  return termsRe.map((re) => (tokens) => tokens.some((token) => re.test(token)));\r\n}\r\nfunction matchPatternRegex(text) {\r\n  const terms = text.replace(EDGE_CHARS, \"\").match(CHARS_WITH_WILDCARD) || [];\r\n  return terms.map((term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, \".*\")}$`, \"i\"));\r\n}\r\nasync function gatherText(value, cb) {\r\n  if (value.type === \"string\") {\r\n    cb(value.data);\r\n    return true;\r\n  }\r\n  if (value.isArray()) {\r\n    let success = true;\r\n    for await (const part of value) {\r\n      if (part.type === \"string\") {\r\n        cb(part.data);\r\n      } else {\r\n        success = false;\r\n      }\r\n    }\r\n    return success;\r\n  }\r\n  return false;\r\n}\r\nconst BM25k = 1.2;\r\nasync function evaluateScore(node, scope, execute) {\r\n  if (node.type === \"OpCall\" && node.op === \"match\") {\r\n    return evaluateMatchScore(node.left, node.right, scope, execute);\r\n  }\r\n  if (node.type === \"FuncCall\" && node.name === \"boost\") {\r\n    const innerScore = await evaluateScore(node.args[0], scope, execute);\r\n    const boost2 = await execute(node.args[1], scope);\r\n    if (boost2.type === \"number\" && innerScore > 0) {\r\n      return innerScore + boost2.data;\r\n    }\r\n    return 0;\r\n  }\r\n  switch (node.type) {\r\n    case \"Or\": {\r\n      const leftScore = await evaluateScore(node.left, scope, execute);\r\n      const rightScore = await evaluateScore(node.right, scope, execute);\r\n      return leftScore + rightScore;\r\n    }\r\n    case \"And\": {\r\n      const leftScore = await evaluateScore(node.left, scope, execute);\r\n      const rightScore = await evaluateScore(node.right, scope, execute);\r\n      if (leftScore === 0 || rightScore === 0)\r\n        return 0;\r\n      return leftScore + rightScore;\r\n    }\r\n    default: {\r\n      const res = await execute(node, scope);\r\n      return res.type === \"boolean\" && res.data === true ? 1 : 0;\r\n    }\r\n  }\r\n}\r\nasync function evaluateMatchScore(left, right, scope, execute) {\r\n  const text = await execute(left, scope);\r\n  const pattern = await execute(right, scope);\r\n  let tokens = [];\r\n  let terms = [];\r\n  await gatherText(text, (part) => {\r\n    tokens = tokens.concat(matchTokenize(part));\r\n  });\r\n  const didSucceed = await gatherText(pattern, (part) => {\r\n    terms = terms.concat(matchPatternRegex(part));\r\n  });\r\n  if (!didSucceed) {\r\n    return 0;\r\n  }\r\n  if (tokens.length === 0 || terms.length === 0) {\r\n    return 0;\r\n  }\r\n  let score2 = 0;\r\n  for (const re of terms) {\r\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0);\r\n    score2 += freq * (BM25k + 1) / (freq + BM25k);\r\n  }\r\n  return score2;\r\n}\r\nasync function portableTextContent(value) {\r\n  if (value.type === \"object\") {\r\n    return blockText(value.data);\r\n  } else if (value.isArray()) {\r\n    const texts = await arrayText(value);\r\n    if (texts.length > 0) {\r\n      return texts.join(\"\\n\\n\");\r\n    }\r\n  }\r\n  return null;\r\n}\r\nasync function arrayText(value, result = []) {\r\n  for await (const block of value) {\r\n    if (block.type === \"object\") {\r\n      const text = blockText(block.data);\r\n      if (text !== null)\r\n        result.push(text);\r\n    } else if (block.isArray()) {\r\n      await arrayText(block, result);\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction blockText(obj) {\r\n  if (typeof obj._type !== \"string\")\r\n    return null;\r\n  const children = obj.children;\r\n  if (!Array.isArray(children))\r\n    return null;\r\n  let result = \"\";\r\n  for (const child of children) {\r\n    if (child && typeof child === \"object\" && typeof child._type === \"string\" && child._type === \"span\" && typeof child.text === \"string\") {\r\n      result += child.text;\r\n    }\r\n  }\r\n  return result;\r\n}\r\nfunction hasReference(value, pathSet) {\r\n  switch (getType(value)) {\r\n    case \"array\":\r\n      for (const v of value) {\r\n        if (hasReference(v, pathSet)) {\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n    case \"object\":\r\n      if (value._ref) {\r\n        return pathSet.has(value._ref);\r\n      }\r\n      for (const v of Object.values(value)) {\r\n        if (hasReference(v, pathSet)) {\r\n          return true;\r\n        }\r\n      }\r\n      break;\r\n  }\r\n  return false;\r\n}\r\nfunction countUTF8(str) {\r\n  let count2 = 0;\r\n  for (let i = 0; i < str.length; i++) {\r\n    const code = str.charCodeAt(i);\r\n    if (code >= 55296 && code <= 56319) {\r\n      continue;\r\n    }\r\n    count2++;\r\n  }\r\n  return count2;\r\n}\r\nconst global = {};\r\nglobal.coalesce = async function coalesce(args, scope, execute) {\r\n  for (const arg of args) {\r\n    const value = await execute(arg, scope);\r\n    if (value.type !== \"null\") {\r\n      return value;\r\n    }\r\n  }\r\n  return NULL_VALUE;\r\n};\r\nglobal.count = async function count(args, scope, execute) {\r\n  const inner = await execute(args[0], scope);\r\n  if (!inner.isArray()) {\r\n    return NULL_VALUE;\r\n  }\r\n  let num = 0;\r\n  for await (const _ of inner) {\r\n    num++;\r\n  }\r\n  return fromNumber(num);\r\n};\r\nglobal.count.arity = 1;\r\nglobal.dateTime = async function dateTime(args, scope, execute) {\r\n  const val = await execute(args[0], scope);\r\n  if (val.type === \"datetime\") {\r\n    return val;\r\n  }\r\n  if (val.type !== \"string\") {\r\n    return NULL_VALUE;\r\n  }\r\n  return DateTime.parseToValue(val.data);\r\n};\r\nglobal.dateTime.arity = 1;\r\nglobal.defined = async function defined(args, scope, execute) {\r\n  const inner = await execute(args[0], scope);\r\n  return inner.type === \"null\" ? FALSE_VALUE : TRUE_VALUE;\r\n};\r\nglobal.defined.arity = 1;\r\nglobal.identity = async function identity(args, scope) {\r\n  return fromString(scope.context.identity);\r\n};\r\nglobal.identity.arity = 0;\r\nglobal.length = async function length(args, scope, execute) {\r\n  const inner = await execute(args[0], scope);\r\n  if (inner.type === \"string\") {\r\n    return fromNumber(countUTF8(inner.data));\r\n  }\r\n  if (inner.isArray()) {\r\n    let num = 0;\r\n    for await (const _ of inner) {\r\n      num++;\r\n    }\r\n    return fromNumber(num);\r\n  }\r\n  return NULL_VALUE;\r\n};\r\nglobal.length.arity = 1;\r\nglobal.path = async function path(args, scope, execute) {\r\n  const inner = await execute(args[0], scope);\r\n  if (inner.type !== \"string\") {\r\n    return NULL_VALUE;\r\n  }\r\n  return fromPath(new Path(inner.data));\r\n};\r\nglobal.path.arity = 1;\r\nglobal.string = async function string(args, scope, execute) {\r\n  const value = await execute(args[0], scope);\r\n  switch (value.type) {\r\n    case \"number\":\r\n    case \"string\":\r\n    case \"boolean\":\r\n    case \"datetime\":\r\n      return fromString(`${value.data}`);\r\n    default:\r\n      return NULL_VALUE;\r\n  }\r\n};\r\nglobal.string.arity = 1;\r\nglobal.references = async function references(args, scope, execute) {\r\n  const pathSet = new Set();\r\n  for (const arg of args) {\r\n    const path2 = await execute(arg, scope);\r\n    if (path2.type === \"string\") {\r\n      pathSet.add(path2.data);\r\n    } else if (path2.isArray()) {\r\n      for await (const elem of path2) {\r\n        if (elem.type === \"string\") {\r\n          pathSet.add(elem.data);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  if (pathSet.size === 0) {\r\n    return FALSE_VALUE;\r\n  }\r\n  const scopeValue = await scope.value.get();\r\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE;\r\n};\r\nglobal.references.arity = (c) => c >= 1;\r\nglobal.round = async function round(args, scope, execute) {\r\n  const value = await execute(args[0], scope);\r\n  if (value.type !== \"number\") {\r\n    return NULL_VALUE;\r\n  }\r\n  const num = value.data;\r\n  let prec = 0;\r\n  if (args.length === 2) {\r\n    const precValue = await execute(args[1], scope);\r\n    if (precValue.type !== \"number\" || precValue.data < 0 || !Number.isInteger(precValue.data)) {\r\n      return NULL_VALUE;\r\n    }\r\n    prec = precValue.data;\r\n  }\r\n  if (prec === 0) {\r\n    if (num < 0) {\r\n      return fromNumber(-Math.round(-num));\r\n    }\r\n    return fromNumber(Math.round(num));\r\n  }\r\n  return fromNumber(Number(num.toFixed(prec)));\r\n};\r\nglobal.round.arity = (count2) => count2 >= 1 && count2 <= 2;\r\nglobal.now = async function now(args, scope) {\r\n  return fromString(scope.context.timestamp.toISOString());\r\n};\r\nglobal.now.arity = 0;\r\nglobal.boost = async function boost() {\r\n  throw new Error(\"unexpected boost call\");\r\n};\r\nglobal.boost.arity = 2;\r\nconst string2 = {};\r\nstring2.lower = async function(args, scope, execute) {\r\n  const value = await execute(args[0], scope);\r\n  if (value.type !== \"string\") {\r\n    return NULL_VALUE;\r\n  }\r\n  return fromString(value.data.toLowerCase());\r\n};\r\nstring2.lower.arity = 1;\r\nstring2.upper = async function(args, scope, execute) {\r\n  const value = await execute(args[0], scope);\r\n  if (value.type !== \"string\") {\r\n    return NULL_VALUE;\r\n  }\r\n  return fromString(value.data.toUpperCase());\r\n};\r\nstring2.upper.arity = 1;\r\nglobal.lower = string2.lower;\r\nglobal.upper = string2.upper;\r\nconst pt = {};\r\npt.text = async function(args, scope, execute) {\r\n  const value = await execute(args[0], scope);\r\n  const text = await portableTextContent(value);\r\n  if (text === null) {\r\n    return NULL_VALUE;\r\n  }\r\n  return fromString(text);\r\n};\r\npt.text.arity = 1;\r\nconst sanity = {};\r\nsanity.projectId = async function(args, scope) {\r\n  if (scope.context.sanity) {\r\n    return fromString(scope.context.sanity.projectId);\r\n  }\r\n  return NULL_VALUE;\r\n};\r\nsanity.dataset = async function(args, scope) {\r\n  if (scope.context.sanity) {\r\n    return fromString(scope.context.sanity.dataset);\r\n  }\r\n  return NULL_VALUE;\r\n};\r\nconst pipeFunctions = {};\r\npipeFunctions.order = async function order(base, args, scope, execute) {\r\n  await true;\r\n  if (!base.isArray()) {\r\n    return NULL_VALUE;\r\n  }\r\n  const mappers = [];\r\n  const directions = [];\r\n  let n = 0;\r\n  for (let mapper of args) {\r\n    let direction = \"asc\";\r\n    if (mapper.type === \"Desc\") {\r\n      direction = \"desc\";\r\n      mapper = mapper.base;\r\n    } else if (mapper.type === \"Asc\") {\r\n      mapper = mapper.base;\r\n    }\r\n    mappers.push(mapper);\r\n    directions.push(direction);\r\n    n++;\r\n  }\r\n  const aux = [];\r\n  let idx = 0;\r\n  for await (const value of base) {\r\n    const newScope = scope.createNested(value);\r\n    const tuple = [await value.get(), idx];\r\n    for (let i = 0; i < n; i++) {\r\n      const result = await execute(mappers[i], newScope);\r\n      tuple.push(await result.get());\r\n    }\r\n    aux.push(tuple);\r\n    idx++;\r\n  }\r\n  aux.sort((aTuple, bTuple) => {\r\n    for (let i = 0; i < n; i++) {\r\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2]);\r\n      if (directions[i] === \"desc\") {\r\n        c = -c;\r\n      }\r\n      if (c !== 0) {\r\n        return c;\r\n      }\r\n    }\r\n    return aTuple[1] - bTuple[1];\r\n  });\r\n  return fromJS(aux.map((v) => v[0]));\r\n};\r\npipeFunctions.order.arity = (count2) => count2 >= 1;\r\npipeFunctions.score = async function score(base, args, scope, execute) {\r\n  if (!base.isArray())\r\n    return NULL_VALUE;\r\n  const unknown = [];\r\n  const scored = [];\r\n  for await (const value of base) {\r\n    if (value.type !== \"object\") {\r\n      unknown.push(await value.get());\r\n      continue;\r\n    }\r\n    const newScope = scope.createNested(value);\r\n    let valueScore = typeof value.data._score === \"number\" ? value.data._score : 0;\r\n    for (const arg of args) {\r\n      valueScore += await evaluateScore(arg, newScope, execute);\r\n    }\r\n    const newObject = Object.assign({}, value.data, { _score: valueScore });\r\n    scored.push(newObject);\r\n  }\r\n  scored.sort((a, b) => b._score - a._score);\r\n  return fromJS(scored);\r\n};\r\npipeFunctions.score.arity = (count2) => count2 >= 1;\r\nconst delta = {};\r\ndelta.operation = async function(args, scope) {\r\n  const hasBefore = scope.context.before !== null;\r\n  const hasAfter = scope.context.after !== null;\r\n  if (hasBefore && hasAfter) {\r\n    return fromString(\"update\");\r\n  }\r\n  if (hasAfter) {\r\n    return fromString(\"create\");\r\n  }\r\n  if (hasBefore) {\r\n    return fromString(\"delete\");\r\n  }\r\n  return NULL_VALUE;\r\n};\r\ndelta.changedAny = () => {\r\n  throw new Error(\"not implemented\");\r\n};\r\ndelta.changedAny.arity = 1;\r\ndelta.changedAny.mode = \"delta\";\r\ndelta.changedOnly = () => {\r\n  throw new Error(\"not implemented\");\r\n};\r\ndelta.changedOnly.arity = 1;\r\ndelta.changedOnly.mode = \"delta\";\r\nconst diff = {};\r\ndiff.changedAny = () => {\r\n  throw new Error(\"not implemented\");\r\n};\r\ndiff.changedAny.arity = 3;\r\ndiff.changedOnly = () => {\r\n  throw new Error(\"not implemented\");\r\n};\r\ndiff.changedOnly.arity = 3;\r\nconst namespaces = {\r\n  global,\r\n  string: string2,\r\n  pt,\r\n  delta,\r\n  diff,\r\n  sanity\r\n};\r\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/;\r\nconst NUM = /^\\d+/;\r\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/;\r\nconst PREC_PAIR = 1;\r\nconst PREC_OR = 2;\r\nconst PREC_AND = 3;\r\nconst PREC_COMP = 4;\r\nconst PREC_ORDER = 4;\r\nconst PREC_ADD = 6;\r\nconst PREC_SUB = 6;\r\nconst PREC_MUL = 7;\r\nconst PREC_DIV = 7;\r\nconst PREC_MOD = 7;\r\nconst PREC_POW = 8;\r\nconst PREC_POS = 10;\r\nconst PREC_NOT = 10;\r\nconst PREC_NEG = 8;\r\nfunction parse$1(str) {\r\n  let pos = 0;\r\n  pos = skipWS(str, pos);\r\n  let result = parseExpr(str, pos, 0);\r\n  if (result.type === \"error\")\r\n    return result;\r\n  pos = skipWS(str, result.position);\r\n  if (pos !== str.length) {\r\n    if (result.failPosition) {\r\n      pos = result.failPosition - 1;\r\n    }\r\n    return { type: \"error\", position: pos };\r\n  }\r\n  delete result.position;\r\n  delete result.failPosition;\r\n  return result;\r\n}\r\nfunction parseExpr(str, pos, level) {\r\n  let startPos = pos;\r\n  let token = str[pos];\r\n  let marks;\r\n  switch (token) {\r\n    case \"+\": {\r\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS);\r\n      if (rhs.type === \"error\")\r\n        return rhs;\r\n      marks = [{ name: \"pos\", position: startPos }].concat(rhs.marks);\r\n      pos = rhs.position;\r\n      break;\r\n    }\r\n    case \"-\": {\r\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG);\r\n      if (rhs.type === \"error\")\r\n        return rhs;\r\n      marks = [{ name: \"neg\", position: startPos }].concat(rhs.marks);\r\n      pos = rhs.position;\r\n      break;\r\n    }\r\n    case \"(\": {\r\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0);\r\n      if (rhs.type === \"error\")\r\n        return rhs;\r\n      pos = skipWS(str, rhs.position);\r\n      switch (str[pos]) {\r\n        case \",\": {\r\n          marks = [{ name: \"tuple\", position: startPos }].concat(rhs.marks);\r\n          pos = skipWS(str, pos + 1);\r\n          while (true) {\r\n            rhs = parseExpr(str, pos, 0);\r\n            if (rhs.type === \"error\")\r\n              return rhs;\r\n            pos = skipWS(str, rhs.position);\r\n            if (str[pos] !== \",\")\r\n              break;\r\n            pos = skipWS(str, pos + 1);\r\n          }\r\n          if (str[pos] !== \")\")\r\n            return { type: \"error\", position: pos };\r\n          pos++;\r\n          marks.push({ name: \"tuple_end\", position: pos });\r\n          break;\r\n        }\r\n        case \")\": {\r\n          pos++;\r\n          marks = [{ name: \"group\", position: startPos }].concat(rhs.marks);\r\n          break;\r\n        }\r\n        default:\r\n          return { type: \"error\", position: pos };\r\n      }\r\n      break;\r\n    }\r\n    case \"!\": {\r\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT);\r\n      if (rhs.type === \"error\")\r\n        return rhs;\r\n      marks = [{ name: \"not\", position: startPos }].concat(rhs.marks);\r\n      pos = rhs.position;\r\n      break;\r\n    }\r\n    case \"{\": {\r\n      let result = parseObject(str, pos);\r\n      if (result.type === \"error\")\r\n        return result;\r\n      marks = result.marks;\r\n      pos = result.position;\r\n      break;\r\n    }\r\n    case \"[\":\r\n      marks = [{ name: \"array\", position: pos }];\r\n      pos = skipWS(str, pos + 1);\r\n      if (str[pos] !== \"]\") {\r\n        while (true) {\r\n          if (str.slice(pos, pos + 3) === \"...\") {\r\n            marks.push({ name: \"array_splat\", position: pos });\r\n            pos = skipWS(str, pos + 3);\r\n          }\r\n          let res = parseExpr(str, pos, 0);\r\n          if (res.type === \"error\")\r\n            return res;\r\n          marks = marks.concat(res.marks);\r\n          pos = res.position;\r\n          pos = skipWS(str, pos);\r\n          if (str[pos] !== \",\")\r\n            break;\r\n          pos = skipWS(str, pos + 1);\r\n          if (str[pos] === \"]\")\r\n            break;\r\n        }\r\n      }\r\n      if (str[pos] === \"]\") {\r\n        pos++;\r\n        marks.push({ name: \"array_end\", position: pos });\r\n      } else {\r\n        return { type: \"error\", position: pos };\r\n      }\r\n      break;\r\n    case \"'\":\r\n    case '\"': {\r\n      let result = parseString(str, pos);\r\n      if (result.type === \"error\")\r\n        return result;\r\n      marks = result.marks;\r\n      pos = result.position;\r\n      break;\r\n    }\r\n    case \"^\": {\r\n      pos++;\r\n      marks = [];\r\n      while (str[pos] === \".\" && str[pos + 1] === \"^\") {\r\n        marks.push({ name: \"dblparent\", position: startPos });\r\n        pos += 2;\r\n      }\r\n      marks.push({ name: \"parent\", position: startPos });\r\n      break;\r\n    }\r\n    case \"@\":\r\n      marks = [{ name: \"this\", position: startPos }];\r\n      pos++;\r\n      break;\r\n    case \"*\":\r\n      marks = [{ name: \"everything\", position: startPos }];\r\n      pos++;\r\n      break;\r\n    case \"$\": {\r\n      let identLen = parseRegex(str, pos + 1, IDENT);\r\n      if (identLen) {\r\n        pos += 1 + identLen;\r\n        marks = [\r\n          { name: \"param\", position: startPos },\r\n          { name: \"ident\", position: startPos + 1 },\r\n          { name: \"ident_end\", position: pos }\r\n        ];\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      let numLen = parseRegex(str, pos, NUM);\r\n      if (numLen) {\r\n        pos += numLen;\r\n        let name = \"integer\";\r\n        if (str[pos] === \".\") {\r\n          let fracLen = parseRegex(str, pos + 1, NUM);\r\n          if (fracLen) {\r\n            name = \"float\";\r\n            pos += 1 + fracLen;\r\n          }\r\n        }\r\n        if (str[pos] === \"e\" || str[pos] === \"E\") {\r\n          name = \"sci\";\r\n          pos++;\r\n          if (str[pos] === \"+\" || str[pos] === \"-\") {\r\n            pos++;\r\n          }\r\n          let expLen = parseRegex(str, pos, NUM);\r\n          if (!expLen)\r\n            return { type: \"error\", position: pos };\r\n          pos += expLen;\r\n        }\r\n        marks = [\r\n          { name, position: startPos },\r\n          { name: name + \"_end\", position: pos }\r\n        ];\r\n        break;\r\n      }\r\n      let identLen = parseRegex(str, pos, IDENT);\r\n      if (identLen) {\r\n        pos += identLen;\r\n        switch (str[pos]) {\r\n          case \":\":\r\n          case \"(\": {\r\n            let result = parseFuncCall(str, startPos, pos);\r\n            if (result.type === \"error\")\r\n              return result;\r\n            marks = result.marks;\r\n            pos = result.position;\r\n            break;\r\n          }\r\n          default: {\r\n            marks = [\r\n              { name: \"this_attr\", position: startPos },\r\n              { name: \"ident\", position: startPos },\r\n              { name: \"ident_end\", position: pos }\r\n            ];\r\n          }\r\n        }\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  if (!marks) {\r\n    return { type: \"error\", position: pos };\r\n  }\r\n  let lhsLevel = 12;\r\n  let trav;\r\n  loop:\r\n    while (true) {\r\n      let innerPos = skipWS(str, pos);\r\n      if (innerPos === str.length) {\r\n        pos = innerPos;\r\n        break;\r\n      }\r\n      trav = parseTraversal(str, innerPos);\r\n      if (trav.type === \"success\") {\r\n        marks.unshift({ name: \"traverse\", position: startPos });\r\n        while (trav.type === \"success\") {\r\n          marks = marks.concat(trav.marks);\r\n          pos = trav.position;\r\n          trav = parseTraversal(str, skipWS(str, pos));\r\n        }\r\n        marks.push({ name: \"traversal_end\", position: pos });\r\n        continue;\r\n      }\r\n      let token2 = str[innerPos];\r\n      switch (token2) {\r\n        case \"=\": {\r\n          let nextToken = str[innerPos + 1];\r\n          switch (nextToken) {\r\n            case \">\": {\r\n              if (level > PREC_PAIR || lhsLevel <= PREC_PAIR)\r\n                break loop;\r\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR);\r\n              if (rhs.type === \"error\")\r\n                return rhs;\r\n              marks = marks.concat(rhs.marks);\r\n              marks.unshift({ name: \"pair\", position: startPos });\r\n              pos = rhs.position;\r\n              lhsLevel = PREC_PAIR;\r\n              break;\r\n            }\r\n            case \"=\": {\r\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\r\n                break loop;\r\n              let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5);\r\n              if (rhs.type === \"error\")\r\n                return rhs;\r\n              marks.unshift({ name: \"comp\", position: startPos });\r\n              marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\r\n              marks = marks.concat(rhs.marks);\r\n              pos = rhs.position;\r\n              lhsLevel = PREC_COMP;\r\n              break;\r\n            }\r\n            default:\r\n              break loop;\r\n          }\r\n          break;\r\n        }\r\n        case \"+\": {\r\n          if (level > PREC_ADD || lhsLevel < PREC_ADD)\r\n            break loop;\r\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1);\r\n          if (rhs.type === \"error\")\r\n            return rhs;\r\n          marks = marks.concat(rhs.marks);\r\n          marks.unshift({ name: \"add\", position: startPos });\r\n          pos = rhs.position;\r\n          lhsLevel = PREC_ADD;\r\n          break;\r\n        }\r\n        case \"-\": {\r\n          if (level > PREC_SUB || lhsLevel < PREC_SUB)\r\n            break loop;\r\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1);\r\n          if (rhs.type === \"error\")\r\n            return rhs;\r\n          marks = marks.concat(rhs.marks);\r\n          marks.unshift({ name: \"sub\", position: startPos });\r\n          pos = rhs.position;\r\n          lhsLevel = PREC_SUB;\r\n          break;\r\n        }\r\n        case \"*\": {\r\n          if (str[innerPos + 1] === \"*\") {\r\n            if (level > PREC_POW || lhsLevel <= PREC_POW)\r\n              break loop;\r\n            let rhs2 = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW);\r\n            if (rhs2.type === \"error\")\r\n              return rhs2;\r\n            marks = marks.concat(rhs2.marks);\r\n            marks.unshift({ name: \"pow\", position: startPos });\r\n            pos = rhs2.position;\r\n            lhsLevel = PREC_POW;\r\n            break;\r\n          }\r\n          if (level > PREC_MUL || lhsLevel < PREC_MUL)\r\n            break loop;\r\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1);\r\n          if (rhs.type === \"error\")\r\n            return rhs;\r\n          marks = marks.concat(rhs.marks);\r\n          marks.unshift({ name: \"mul\", position: startPos });\r\n          pos = rhs.position;\r\n          lhsLevel = PREC_MUL;\r\n          break;\r\n        }\r\n        case \"/\": {\r\n          if (level > PREC_DIV || lhsLevel < PREC_DIV)\r\n            break loop;\r\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1);\r\n          if (rhs.type === \"error\")\r\n            return rhs;\r\n          marks = marks.concat(rhs.marks);\r\n          marks.unshift({ name: \"div\", position: startPos });\r\n          pos = rhs.position;\r\n          lhsLevel = PREC_DIV;\r\n          break;\r\n        }\r\n        case \"%\": {\r\n          if (level > PREC_MOD || lhsLevel < PREC_MOD)\r\n            break loop;\r\n          let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1);\r\n          if (rhs.type === \"error\")\r\n            return rhs;\r\n          marks = marks.concat(rhs.marks);\r\n          marks.unshift({ name: \"mod\", position: startPos });\r\n          pos = rhs.position;\r\n          lhsLevel = PREC_MOD;\r\n          break;\r\n        }\r\n        case \"<\":\r\n        case \">\": {\r\n          if (level > PREC_COMP || lhsLevel <= PREC_COMP)\r\n            break loop;\r\n          let nextPos = innerPos + 1;\r\n          if (str[nextPos] === \"=\") {\r\n            nextPos++;\r\n          }\r\n          let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1);\r\n          if (rhs.type === \"error\")\r\n            return rhs;\r\n          marks.unshift({ name: \"comp\", position: startPos });\r\n          marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: nextPos });\r\n          marks = marks.concat(rhs.marks);\r\n          pos = rhs.position;\r\n          lhsLevel = PREC_COMP;\r\n          break;\r\n        }\r\n        case \"|\": {\r\n          if (str[innerPos + 1] === \"|\") {\r\n            if (level > PREC_OR || lhsLevel < PREC_OR)\r\n              break loop;\r\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1);\r\n            if (rhs.type === \"error\")\r\n              return rhs;\r\n            marks = marks.concat(rhs.marks);\r\n            marks.unshift({ name: \"or\", position: startPos });\r\n            pos = rhs.position;\r\n            lhsLevel = PREC_OR;\r\n          } else {\r\n            if (level > 11 || lhsLevel < 11)\r\n              break loop;\r\n            let identPos = skipWS(str, innerPos + 1);\r\n            let identLen = parseRegex(str, identPos, IDENT);\r\n            if (!identLen)\r\n              return { type: \"error\", position: identPos };\r\n            pos = identPos + identLen;\r\n            if (str[pos] === \"(\" || str[pos] === \":\") {\r\n              let result = parseFuncCall(str, identPos, pos);\r\n              if (result.type === \"error\")\r\n                return result;\r\n              marks = marks.concat(result.marks);\r\n              marks.unshift({ name: \"pipecall\", position: startPos });\r\n              pos = result.position;\r\n              lhsLevel = 11;\r\n            }\r\n          }\r\n          break;\r\n        }\r\n        case \"&\": {\r\n          if (str[innerPos + 1] != \"&\")\r\n            break loop;\r\n          if (level > PREC_AND || lhsLevel < PREC_AND)\r\n            break loop;\r\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1);\r\n          if (rhs.type === \"error\")\r\n            return rhs;\r\n          marks = marks.concat(rhs.marks);\r\n          marks.unshift({ name: \"and\", position: startPos });\r\n          pos = rhs.position;\r\n          lhsLevel = PREC_AND;\r\n          break;\r\n        }\r\n        case \"!\": {\r\n          if (str[innerPos + 1] !== \"=\")\r\n            break loop;\r\n          if (level > PREC_COMP || lhsLevel < PREC_COMP)\r\n            break loop;\r\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1);\r\n          if (rhs.type === \"error\")\r\n            return rhs;\r\n          marks.unshift({ name: \"comp\", position: startPos });\r\n          marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\r\n          marks = marks.concat(rhs.marks);\r\n          pos = rhs.position;\r\n          lhsLevel = PREC_COMP;\r\n          break;\r\n        }\r\n        case \"d\": {\r\n          if (str.slice(innerPos, innerPos + 4) !== \"desc\")\r\n            break loop;\r\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)\r\n            break loop;\r\n          marks.unshift({ name: \"desc\", position: startPos });\r\n          pos = innerPos + 4;\r\n          lhsLevel = PREC_ORDER;\r\n          break;\r\n        }\r\n        case \"a\": {\r\n          if (str.slice(innerPos, innerPos + 3) !== \"asc\")\r\n            break loop;\r\n          if (level > PREC_ORDER || lhsLevel < PREC_ORDER)\r\n            break loop;\r\n          marks.unshift({ name: \"asc\", position: startPos });\r\n          pos = innerPos + 3;\r\n          lhsLevel = PREC_ORDER;\r\n          break;\r\n        }\r\n        default: {\r\n          let ident = parseRegexStr(str, innerPos, IDENT);\r\n          switch (ident) {\r\n            case \"in\": {\r\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\r\n                break loop;\r\n              pos = skipWS(str, innerPos + 2);\r\n              let isGroup = false;\r\n              if (str[pos] === \"(\") {\r\n                isGroup = true;\r\n                pos = skipWS(str, pos + 1);\r\n              }\r\n              let rangePos = pos;\r\n              let result = parseExpr(str, pos, PREC_COMP + 1);\r\n              if (result.type === \"error\")\r\n                return result;\r\n              pos = skipWS(str, result.position);\r\n              if (str[pos] === \".\" && str[pos + 1] === \".\") {\r\n                let type = \"inc_range\";\r\n                if (str[pos + 2] === \".\") {\r\n                  type = \"exc_range\";\r\n                  pos = skipWS(str, pos + 3);\r\n                } else {\r\n                  pos = skipWS(str, pos + 2);\r\n                }\r\n                let rhs = parseExpr(str, pos, PREC_COMP + 1);\r\n                if (rhs.type === \"error\")\r\n                  return rhs;\r\n                marks.unshift({ name: \"in_range\", position: startPos });\r\n                marks = marks.concat({ name: type, position: rangePos }, result.marks, rhs.marks);\r\n                pos = rhs.position;\r\n              } else {\r\n                marks.unshift({ name: \"comp\", position: startPos });\r\n                marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 2 });\r\n                marks = marks.concat(result.marks);\r\n              }\r\n              if (isGroup) {\r\n                pos = skipWS(str, pos);\r\n                if (str[pos] !== \")\")\r\n                  return { type: \"error\", position: pos };\r\n                pos++;\r\n              }\r\n              lhsLevel = PREC_COMP;\r\n              break;\r\n            }\r\n            case \"match\": {\r\n              if (level > PREC_COMP || lhsLevel <= PREC_COMP)\r\n                break loop;\r\n              let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1);\r\n              if (rhs.type === \"error\")\r\n                return rhs;\r\n              marks.unshift({ name: \"comp\", position: startPos });\r\n              marks.push({ name: \"op\", position: innerPos }, { name: \"op_end\", position: innerPos + 5 });\r\n              marks = marks.concat(rhs.marks);\r\n              pos = rhs.position;\r\n              lhsLevel = 4;\r\n              break;\r\n            }\r\n            default: {\r\n              break loop;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  let failPosition = (trav == null ? void 0 : trav.type) === \"error\" && trav.position;\r\n  return { type: \"success\", marks, position: pos, failPosition };\r\n}\r\nfunction parseTraversal(str, pos) {\r\n  let startPos = pos;\r\n  switch (str[pos]) {\r\n    case \".\": {\r\n      pos = skipWS(str, pos + 1);\r\n      let identStart = pos;\r\n      let identLen2 = parseRegex(str, pos, IDENT);\r\n      if (!identLen2)\r\n        return { type: \"error\", position: pos };\r\n      pos += identLen2;\r\n      return {\r\n        type: \"success\",\r\n        marks: [\r\n          { name: \"attr_access\", position: startPos },\r\n          { name: \"ident\", position: identStart },\r\n          { name: \"ident_end\", position: pos }\r\n        ],\r\n        position: pos\r\n      };\r\n    }\r\n    case \"-\":\r\n      if (str[pos + 1] !== \">\")\r\n        return { type: \"error\", position: pos };\r\n      let marks = [{ name: \"deref\", position: startPos }];\r\n      pos += 2;\r\n      let identPos = skipWS(str, pos);\r\n      let identLen = parseRegex(str, identPos, IDENT);\r\n      if (identLen) {\r\n        pos = identPos + identLen;\r\n        marks.push({ name: \"deref_attr\", position: identPos }, { name: \"ident\", position: identPos }, { name: \"ident_end\", position: pos });\r\n      }\r\n      return {\r\n        type: \"success\",\r\n        marks,\r\n        position: pos\r\n      };\r\n    case \"[\": {\r\n      pos = skipWS(str, pos + 1);\r\n      if (str[pos] === \"]\") {\r\n        return {\r\n          type: \"success\",\r\n          marks: [{ name: \"array_postfix\", position: startPos }],\r\n          position: pos + 1\r\n        };\r\n      }\r\n      let rangePos = pos;\r\n      let result = parseExpr(str, pos, 0);\r\n      if (result.type === \"error\")\r\n        return result;\r\n      pos = skipWS(str, result.position);\r\n      if (str[pos] === \".\" && str[pos + 1] === \".\") {\r\n        let type = \"inc_range\";\r\n        if (str[pos + 2] === \".\") {\r\n          type = \"exc_range\";\r\n          pos += 3;\r\n        } else {\r\n          pos += 2;\r\n        }\r\n        pos = skipWS(str, pos);\r\n        let rhs = parseExpr(str, pos, 0);\r\n        if (rhs.type === \"error\")\r\n          return rhs;\r\n        pos = skipWS(str, rhs.position);\r\n        if (str[pos] !== \"]\")\r\n          return { type: \"error\", position: pos };\r\n        return {\r\n          type: \"success\",\r\n          marks: [\r\n            { name: \"slice\", position: startPos },\r\n            { name: type, position: rangePos }\r\n          ].concat(result.marks, rhs.marks),\r\n          position: pos + 1\r\n        };\r\n      }\r\n      if (str[pos] !== \"]\")\r\n        return { type: \"error\", position: pos };\r\n      return {\r\n        type: \"success\",\r\n        marks: [{ name: \"square_bracket\", position: startPos }].concat(result.marks),\r\n        position: pos + 1\r\n      };\r\n    }\r\n    case \"|\": {\r\n      pos = skipWS(str, pos + 1);\r\n      if (str[pos] === \"{\") {\r\n        let result = parseObject(str, pos);\r\n        if (result.type === \"error\")\r\n          return result;\r\n        result.marks.unshift({ name: \"projection\", position: startPos });\r\n        return result;\r\n      }\r\n      break;\r\n    }\r\n    case \"{\": {\r\n      let result = parseObject(str, pos);\r\n      if (result.type === \"error\")\r\n        return result;\r\n      result.marks.unshift({ name: \"projection\", position: startPos });\r\n      return result;\r\n    }\r\n  }\r\n  return { type: \"error\", position: pos };\r\n}\r\nfunction parseFuncCall(str, startPos, pos) {\r\n  let marks = [];\r\n  marks.push({ name: \"func_call\", position: startPos });\r\n  if (str[pos] === \":\" && str[pos + 1] === \":\") {\r\n    marks.push({ name: \"namespace\", position: startPos });\r\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos });\r\n    pos = skipWS(str, pos + 2);\r\n    let nameLen = parseRegex(str, pos, IDENT);\r\n    if (!nameLen)\r\n      return { type: \"error\", position: pos };\r\n    marks.push({ name: \"ident\", position: pos }, { name: \"ident_end\", position: pos + nameLen });\r\n    pos = skipWS(str, pos + nameLen);\r\n    if (str[pos] !== \"(\")\r\n      return { type: \"error\", position: pos };\r\n    pos++;\r\n  } else {\r\n    marks.push({ name: \"ident\", position: startPos }, { name: \"ident_end\", position: pos });\r\n    pos = skipWS(str, pos + 1);\r\n  }\r\n  let lastPos = pos;\r\n  if (str[pos] !== \")\") {\r\n    while (true) {\r\n      let result = parseExpr(str, pos, 0);\r\n      if (result.type === \"error\")\r\n        return result;\r\n      marks = marks.concat(result.marks);\r\n      lastPos = result.position;\r\n      pos = skipWS(str, result.position);\r\n      if (str[pos] !== \",\")\r\n        break;\r\n      pos = skipWS(str, pos + 1);\r\n      if (str[pos] === \")\")\r\n        break;\r\n    }\r\n  }\r\n  if (str[pos] !== \")\") {\r\n    return { type: \"error\", position: pos };\r\n  }\r\n  marks.push({ name: \"func_args_end\", position: lastPos });\r\n  return {\r\n    type: \"success\",\r\n    marks,\r\n    position: pos + 1\r\n  };\r\n}\r\nfunction parseObject(str, pos) {\r\n  let marks = [{ name: \"object\", position: pos }];\r\n  pos = skipWS(str, pos + 1);\r\n  while (str[pos] !== \"}\") {\r\n    let pairPos = pos;\r\n    if (str.slice(pos, pos + 3) === \"...\") {\r\n      pos = skipWS(str, pos + 3);\r\n      if (str[pos] !== \"}\" && str[pos] !== \",\") {\r\n        let expr = parseExpr(str, pos, 0);\r\n        if (expr.type === \"error\")\r\n          return expr;\r\n        marks.push({ name: \"object_splat\", position: pairPos });\r\n        marks = marks.concat(expr.marks);\r\n        pos = expr.position;\r\n      } else {\r\n        marks.push({ name: \"object_splat_this\", position: pairPos });\r\n      }\r\n    } else {\r\n      let expr = parseExpr(str, pos, 0);\r\n      if (expr.type === \"error\")\r\n        return expr;\r\n      let nextPos = skipWS(str, expr.position);\r\n      if (expr.marks[0].name === \"str\" && str[nextPos] === \":\") {\r\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0);\r\n        if (value.type === \"error\")\r\n          return value;\r\n        marks.push({ name: \"object_pair\", position: pairPos });\r\n        marks = marks.concat(expr.marks, value.marks);\r\n        pos = value.position;\r\n      } else {\r\n        marks = marks.concat({ name: \"object_expr\", position: pos }, expr.marks);\r\n        pos = expr.position;\r\n      }\r\n    }\r\n    pos = skipWS(str, pos);\r\n    if (str[pos] !== \",\")\r\n      break;\r\n    pos = skipWS(str, pos + 1);\r\n  }\r\n  if (str[pos] !== \"}\") {\r\n    return { type: \"error\", position: pos };\r\n  }\r\n  pos++;\r\n  marks.push({ name: \"object_end\", position: pos });\r\n  return { type: \"success\", marks, position: pos };\r\n}\r\nfunction parseString(str, pos) {\r\n  let token = str[pos];\r\n  pos = pos + 1;\r\n  const marks = [{ name: \"str\", position: pos }];\r\n  str:\r\n    for (; ; pos++) {\r\n      if (pos > str.length)\r\n        return { type: \"error\", position: pos };\r\n      switch (str[pos]) {\r\n        case token: {\r\n          marks.push({ name: \"str_end\", position: pos });\r\n          pos++;\r\n          break str;\r\n        }\r\n        case \"\\\\\": {\r\n          marks.push({ name: \"str_pause\", position: pos });\r\n          if (str[pos + 1] === \"u\") {\r\n            if (str[pos + 2] === \"{\") {\r\n              marks.push({ name: \"unicode_hex\", position: pos + 3 });\r\n              pos = str.indexOf(\"}\", pos + 3);\r\n              marks.push({ name: \"unicode_hex_end\", position: pos });\r\n              pos++;\r\n            } else {\r\n              marks.push({ name: \"unicode_hex\", position: pos + 2 });\r\n              marks.push({ name: \"unicode_hex_end\", position: pos + 6 });\r\n              pos += 5;\r\n            }\r\n          } else {\r\n            marks.push({ name: \"single_escape\", position: pos + 1 });\r\n            pos += 1;\r\n          }\r\n          marks.push({ name: \"str_start\", position: pos + 1 });\r\n        }\r\n      }\r\n    }\r\n  return { type: \"success\", marks, position: pos };\r\n}\r\nfunction skipWS(str, pos) {\r\n  return pos + parseRegex(str, pos, WS);\r\n}\r\nfunction parseRegex(str, pos, re) {\r\n  let m = re.exec(str.slice(pos));\r\n  return m ? m[0].length : 0;\r\n}\r\nfunction parseRegexStr(str, pos, re) {\r\n  let m = re.exec(str.slice(pos));\r\n  return m ? m[0] : null;\r\n}\r\nfunction join(a, b) {\r\n  return (base) => b(a(base));\r\n}\r\nfunction map(inner) {\r\n  return (base) => ({ type: \"Map\", base, expr: inner({ type: \"This\" }) });\r\n}\r\nfunction flatMap(inner) {\r\n  return (base) => ({ type: \"FlatMap\", base, expr: inner({ type: \"This\" }) });\r\n}\r\nfunction traverseArray(build, right) {\r\n  if (!right) {\r\n    return {\r\n      type: \"a-a\",\r\n      build\r\n    };\r\n  }\r\n  switch (right.type) {\r\n    case \"a-a\":\r\n      return {\r\n        type: \"a-a\",\r\n        build: join(build, right.build)\r\n      };\r\n    case \"a-b\":\r\n      return {\r\n        type: \"a-b\",\r\n        build: join(build, right.build)\r\n      };\r\n    case \"b-b\":\r\n      return {\r\n        type: \"a-a\",\r\n        build: join(build, map(right.build))\r\n      };\r\n    case \"b-a\":\r\n      return {\r\n        type: \"a-a\",\r\n        build: join(build, flatMap(right.build))\r\n      };\r\n    default:\r\n      throw new Error(`unknown type: ${right.type}`);\r\n  }\r\n}\r\nfunction traversePlain(mapper, right) {\r\n  if (!right) {\r\n    return {\r\n      type: \"b-b\",\r\n      build: mapper\r\n    };\r\n  }\r\n  switch (right.type) {\r\n    case \"a-a\":\r\n    case \"b-a\":\r\n      return {\r\n        type: \"b-a\",\r\n        build: join(mapper, right.build)\r\n      };\r\n    case \"a-b\":\r\n    case \"b-b\":\r\n      return {\r\n        type: \"b-b\",\r\n        build: join(mapper, right.build)\r\n      };\r\n    default:\r\n      throw new Error(`unknown type: ${right.type}`);\r\n  }\r\n}\r\nfunction traverseElement(mapper, right) {\r\n  if (!right) {\r\n    return {\r\n      type: \"a-b\",\r\n      build: mapper\r\n    };\r\n  }\r\n  switch (right.type) {\r\n    case \"a-a\":\r\n    case \"b-a\":\r\n      return {\r\n        type: \"a-a\",\r\n        build: join(mapper, right.build)\r\n      };\r\n    case \"a-b\":\r\n    case \"b-b\":\r\n      return {\r\n        type: \"a-b\",\r\n        build: join(mapper, right.build)\r\n      };\r\n    default:\r\n      throw new Error(`unknown type: ${right.type}`);\r\n  }\r\n}\r\nfunction traverseProjection(mapper, right) {\r\n  if (!right) {\r\n    return {\r\n      type: \"b-b\",\r\n      build: mapper\r\n    };\r\n  }\r\n  switch (right.type) {\r\n    case \"a-a\":\r\n      return {\r\n        type: \"a-a\",\r\n        build: join(map(mapper), right.build)\r\n      };\r\n    case \"a-b\":\r\n      return {\r\n        type: \"a-b\",\r\n        build: join(map(mapper), right.build)\r\n      };\r\n    case \"b-a\":\r\n      return {\r\n        type: \"b-a\",\r\n        build: join(mapper, right.build)\r\n      };\r\n    case \"b-b\":\r\n      return {\r\n        type: \"b-b\",\r\n        build: join(mapper, right.build)\r\n      };\r\n    default:\r\n      throw new Error(`unknown type: ${right.type}`);\r\n  }\r\n}\r\nconst isEqual = equality;\r\nfunction equality(a, b) {\r\n  if (a.type === \"string\" && b.type === \"string\" || a.type === \"boolean\" && b.type === \"boolean\" || a.type === \"null\" && b.type === \"null\" || a.type === \"number\" && b.type === \"number\") {\r\n    return a.data === b.data;\r\n  }\r\n  if (a.type === \"datetime\" && b.type === \"datetime\") {\r\n    return a.data.equals(b.data);\r\n  }\r\n  return false;\r\n}\r\nconst operators = {\r\n  \"==\": function eq(left, right) {\r\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE;\r\n  },\r\n  \"!=\": function neq(left, right) {\r\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE;\r\n  },\r\n  \">\": function gt(left, right) {\r\n    if (left.type === \"stream\" || right.type === \"stream\")\r\n      return NULL_VALUE;\r\n    const result = partialCompare(left.data, right.data);\r\n    if (result === null) {\r\n      return NULL_VALUE;\r\n    }\r\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE;\r\n  },\r\n  \">=\": function gte(left, right) {\r\n    if (left.type === \"stream\" || right.type === \"stream\")\r\n      return NULL_VALUE;\r\n    const result = partialCompare(left.data, right.data);\r\n    if (result === null) {\r\n      return NULL_VALUE;\r\n    }\r\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE;\r\n  },\r\n  \"<\": function lt(left, right) {\r\n    if (left.type === \"stream\" || right.type === \"stream\")\r\n      return NULL_VALUE;\r\n    const result = partialCompare(left.data, right.data);\r\n    if (result === null) {\r\n      return NULL_VALUE;\r\n    }\r\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE;\r\n  },\r\n  \"<=\": function lte(left, right) {\r\n    if (left.type === \"stream\" || right.type === \"stream\")\r\n      return NULL_VALUE;\r\n    const result = partialCompare(left.data, right.data);\r\n    if (result === null) {\r\n      return NULL_VALUE;\r\n    }\r\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE;\r\n  },\r\n  in: async function inop(left, right) {\r\n    if (right.type === \"path\") {\r\n      if (left.type !== \"string\") {\r\n        return NULL_VALUE;\r\n      }\r\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE;\r\n    }\r\n    if (right.isArray()) {\r\n      for await (const b of right) {\r\n        if (isEqual(left, b)) {\r\n          return TRUE_VALUE;\r\n        }\r\n      }\r\n      return FALSE_VALUE;\r\n    }\r\n    return NULL_VALUE;\r\n  },\r\n  match: async function match(left, right) {\r\n    let tokens = [];\r\n    let patterns = [];\r\n    await gatherText(left, (part) => {\r\n      tokens = tokens.concat(matchTokenize(part));\r\n    });\r\n    const didSucceed = await gatherText(right, (part) => {\r\n      patterns = patterns.concat(matchAnalyzePattern(part));\r\n    });\r\n    if (!didSucceed) {\r\n      return FALSE_VALUE;\r\n    }\r\n    const matched = matchText(tokens, patterns);\r\n    return matched ? TRUE_VALUE : FALSE_VALUE;\r\n  },\r\n  \"+\": function plus(left, right) {\r\n    if (left.type === \"datetime\" && right.type === \"number\") {\r\n      return fromDateTime(left.data.add(right.data));\r\n    }\r\n    if (left.type === \"number\" && right.type === \"number\") {\r\n      return fromNumber(left.data + right.data);\r\n    }\r\n    if (left.type === \"string\" && right.type === \"string\") {\r\n      return fromString(left.data + right.data);\r\n    }\r\n    if (left.type === \"object\" && right.type === \"object\") {\r\n      return fromJS(__spreadValues(__spreadValues({}, left.data), right.data));\r\n    }\r\n    if (left.type === \"array\" && right.type === \"array\") {\r\n      return fromJS(left.data.concat(right.data));\r\n    }\r\n    if (left.isArray() && right.isArray()) {\r\n      return new StreamValue(async function* () {\r\n        for await (const val of left) {\r\n          yield val;\r\n        }\r\n        for await (const val of right) {\r\n          yield val;\r\n        }\r\n      });\r\n    }\r\n    return NULL_VALUE;\r\n  },\r\n  \"-\": function minus(left, right) {\r\n    if (left.type === \"datetime\" && right.type === \"number\") {\r\n      return fromDateTime(left.data.add(-right.data));\r\n    }\r\n    if (left.type === \"datetime\" && right.type === \"datetime\") {\r\n      return fromNumber(left.data.difference(right.data));\r\n    }\r\n    if (left.type === \"number\" && right.type === \"number\") {\r\n      return fromNumber(left.data - right.data);\r\n    }\r\n    return NULL_VALUE;\r\n  },\r\n  \"*\": numericOperator((a, b) => a * b),\r\n  \"/\": numericOperator((a, b) => a / b),\r\n  \"%\": numericOperator((a, b) => a % b),\r\n  \"**\": numericOperator((a, b) => Math.pow(a, b))\r\n};\r\nfunction numericOperator(impl) {\r\n  return function(left, right) {\r\n    if (left.type === \"number\" && right.type === \"number\") {\r\n      const result = impl(left.data, right.data);\r\n      return fromNumber(result);\r\n    }\r\n    return NULL_VALUE;\r\n  };\r\n}\r\nclass Scope {\r\n  constructor(params, source, value, context, parent) {\r\n    this.isHidden = false;\r\n    this.params = params;\r\n    this.source = source;\r\n    this.value = value;\r\n    this.context = context;\r\n    this.parent = parent;\r\n  }\r\n  createNested(value) {\r\n    if (this.isHidden) {\r\n      return new Scope(this.params, this.source, value, this.context, this.parent);\r\n    }\r\n    return new Scope(this.params, this.source, value, this.context, this);\r\n  }\r\n  createHidden(value) {\r\n    const result = this.createNested(value);\r\n    result.isHidden = true;\r\n    return result;\r\n  }\r\n}\r\nfunction evaluate(node, scope, execute = evaluate) {\r\n  const func = EXECUTORS[node.type];\r\n  return func(node, scope, execute);\r\n}\r\nfunction promiselessApply(value, cb) {\r\n  if (\"then\" in value) {\r\n    return value.then(cb);\r\n  }\r\n  return cb(value);\r\n}\r\nconst EXECUTORS = {\r\n  This(_, scope) {\r\n    return scope.value;\r\n  },\r\n  Everything(_, scope) {\r\n    return scope.source;\r\n  },\r\n  Parameter({ name }, scope) {\r\n    return fromJS(scope.params[name]);\r\n  },\r\n  Context({ key }, scope) {\r\n    if (key === \"before\" || key === \"after\") {\r\n      const value = scope.context[key];\r\n      return value || NULL_VALUE;\r\n    }\r\n    throw new Error(`unknown context key: ${key}`);\r\n  },\r\n  Parent({ n }, scope) {\r\n    let current = scope;\r\n    for (let i = 0; i < n; i++) {\r\n      if (!current.parent) {\r\n        return NULL_VALUE;\r\n      }\r\n      current = current.parent;\r\n    }\r\n    return current.value;\r\n  },\r\n  OpCall({ op, left, right }, scope, execute) {\r\n    const func = operators[op];\r\n    if (!func) {\r\n      throw new Error(`Unknown operator: ${op}`);\r\n    }\r\n    const leftValue = execute(left, scope);\r\n    const rightValue = execute(right, scope);\r\n    if (\"then\" in leftValue || \"then\" in rightValue) {\r\n      return (async () => func(await leftValue, await rightValue))();\r\n    }\r\n    return func(leftValue, rightValue);\r\n  },\r\n  async Select({ alternatives, fallback }, scope, execute) {\r\n    for (const alt of alternatives) {\r\n      const altCond = await execute(alt.condition, scope);\r\n      if (altCond.type === \"boolean\" && altCond.data === true) {\r\n        return execute(alt.value, scope);\r\n      }\r\n    }\r\n    if (fallback) {\r\n      return execute(fallback, scope);\r\n    }\r\n    return NULL_VALUE;\r\n  },\r\n  async InRange({ base, left, right, isInclusive }, scope, execute) {\r\n    const value = await execute(base, scope);\r\n    const leftValue = await execute(left, scope);\r\n    const rightValue = await execute(right, scope);\r\n    const leftCmp = partialCompare(await value.get(), await leftValue.get());\r\n    if (leftCmp === null) {\r\n      return NULL_VALUE;\r\n    }\r\n    const rightCmp = partialCompare(await value.get(), await rightValue.get());\r\n    if (rightCmp === null) {\r\n      return NULL_VALUE;\r\n    }\r\n    if (isInclusive) {\r\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE;\r\n    }\r\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE;\r\n  },\r\n  async Filter({ base, expr }, scope, execute) {\r\n    const baseValue = await execute(base, scope);\r\n    if (!baseValue.isArray()) {\r\n      return NULL_VALUE;\r\n    }\r\n    return new StreamValue(async function* () {\r\n      for await (const elem of baseValue) {\r\n        const newScope = scope.createNested(elem);\r\n        const exprValue = await execute(expr, newScope);\r\n        if (exprValue.type === \"boolean\" && exprValue.data === true) {\r\n          yield elem;\r\n        }\r\n      }\r\n    });\r\n  },\r\n  async Projection({ base, expr }, scope, execute) {\r\n    const baseValue = await execute(base, scope);\r\n    if (baseValue.type !== \"object\") {\r\n      return NULL_VALUE;\r\n    }\r\n    const newScope = scope.createNested(baseValue);\r\n    return execute(expr, newScope);\r\n  },\r\n  FuncCall({ func, args }, scope, execute) {\r\n    return func(args, scope, execute);\r\n  },\r\n  async PipeFuncCall({ func, base, args }, scope, execute) {\r\n    const baseValue = await execute(base, scope);\r\n    return func(baseValue, args, scope, execute);\r\n  },\r\n  async AccessAttribute({ base, name }, scope, execute) {\r\n    let value = scope.value;\r\n    if (base) {\r\n      value = await execute(base, scope);\r\n    }\r\n    if (value.type === \"object\") {\r\n      if (value.data.hasOwnProperty(name)) {\r\n        return fromJS(value.data[name]);\r\n      }\r\n    }\r\n    return NULL_VALUE;\r\n  },\r\n  async AccessElement({ base, index }, scope, execute) {\r\n    const baseValue = await execute(base, scope);\r\n    if (!baseValue.isArray()) {\r\n      return NULL_VALUE;\r\n    }\r\n    const data = await baseValue.get();\r\n    const finalIndex = index < 0 ? index + data.length : index;\r\n    return fromJS(data[finalIndex]);\r\n  },\r\n  async Slice({ base, left, right, isInclusive }, scope, execute) {\r\n    const baseValue = await execute(base, scope);\r\n    if (!baseValue.isArray()) {\r\n      return NULL_VALUE;\r\n    }\r\n    const array = await baseValue.get();\r\n    let leftIdx = left;\r\n    let rightIdx = right;\r\n    if (leftIdx < 0) {\r\n      leftIdx = array.length + leftIdx;\r\n    }\r\n    if (rightIdx < 0) {\r\n      rightIdx = array.length + rightIdx;\r\n    }\r\n    if (isInclusive) {\r\n      rightIdx++;\r\n    }\r\n    if (leftIdx < 0) {\r\n      leftIdx = 0;\r\n    }\r\n    if (rightIdx < 0) {\r\n      rightIdx = 0;\r\n    }\r\n    return fromJS(array.slice(leftIdx, rightIdx));\r\n  },\r\n  async Deref({ base }, scope, execute) {\r\n    const value = await execute(base, scope);\r\n    if (!scope.source.isArray()) {\r\n      return NULL_VALUE;\r\n    }\r\n    if (value.type !== \"object\") {\r\n      return NULL_VALUE;\r\n    }\r\n    const id = value.data._ref;\r\n    if (typeof id !== \"string\") {\r\n      return NULL_VALUE;\r\n    }\r\n    for await (const doc of scope.source) {\r\n      if (doc.type === \"object\" && id === doc.data._id) {\r\n        return doc;\r\n      }\r\n    }\r\n    return NULL_VALUE;\r\n  },\r\n  Value({ value }) {\r\n    return fromJS(value);\r\n  },\r\n  Group({ base }, scope, execute) {\r\n    return execute(base, scope);\r\n  },\r\n  async Object({ attributes }, scope, execute) {\r\n    const result = {};\r\n    for (const attr of attributes) {\r\n      const attrType = attr.type;\r\n      switch (attr.type) {\r\n        case \"ObjectAttributeValue\": {\r\n          const value = await execute(attr.value, scope);\r\n          result[attr.name] = await value.get();\r\n          break;\r\n        }\r\n        case \"ObjectConditionalSplat\": {\r\n          const cond = await execute(attr.condition, scope);\r\n          if (cond.type !== \"boolean\" || cond.data === false) {\r\n            continue;\r\n          }\r\n          const value = await execute(attr.value, scope);\r\n          if (value.type === \"object\") {\r\n            Object.assign(result, value.data);\r\n          }\r\n          break;\r\n        }\r\n        case \"ObjectSplat\": {\r\n          const value = await execute(attr.value, scope);\r\n          if (value.type === \"object\") {\r\n            Object.assign(result, value.data);\r\n          }\r\n          break;\r\n        }\r\n        default:\r\n          throw new Error(`Unknown node type: ${attrType}`);\r\n      }\r\n    }\r\n    return fromJS(result);\r\n  },\r\n  Array({ elements }, scope, execute) {\r\n    return new StreamValue(async function* () {\r\n      for (const element of elements) {\r\n        const value = await execute(element.value, scope);\r\n        if (element.isSplat) {\r\n          if (value.isArray()) {\r\n            for await (const v of value) {\r\n              yield v;\r\n            }\r\n          }\r\n        } else {\r\n          yield value;\r\n        }\r\n      }\r\n    });\r\n  },\r\n  Tuple() {\r\n    throw new Error(\"tuples can not be evaluated\");\r\n  },\r\n  async Or({ left, right }, scope, execute) {\r\n    const leftValue = await execute(left, scope);\r\n    const rightValue = await execute(right, scope);\r\n    if (leftValue.type === \"boolean\") {\r\n      if (leftValue.data === true) {\r\n        return TRUE_VALUE;\r\n      }\r\n    }\r\n    if (rightValue.type === \"boolean\") {\r\n      if (rightValue.data === true) {\r\n        return TRUE_VALUE;\r\n      }\r\n    }\r\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\r\n      return NULL_VALUE;\r\n    }\r\n    return FALSE_VALUE;\r\n  },\r\n  async And({ left, right }, scope, execute) {\r\n    const leftValue = await execute(left, scope);\r\n    const rightValue = await execute(right, scope);\r\n    if (leftValue.type === \"boolean\") {\r\n      if (leftValue.data === false) {\r\n        return FALSE_VALUE;\r\n      }\r\n    }\r\n    if (rightValue.type === \"boolean\") {\r\n      if (rightValue.data === false) {\r\n        return FALSE_VALUE;\r\n      }\r\n    }\r\n    if (leftValue.type !== \"boolean\" || rightValue.type !== \"boolean\") {\r\n      return NULL_VALUE;\r\n    }\r\n    return TRUE_VALUE;\r\n  },\r\n  async Not({ base }, scope, execute) {\r\n    const value = await execute(base, scope);\r\n    if (value.type !== \"boolean\") {\r\n      return NULL_VALUE;\r\n    }\r\n    return value.data ? FALSE_VALUE : TRUE_VALUE;\r\n  },\r\n  Neg({ base }, scope, execute) {\r\n    return promiselessApply(execute(base, scope), (value) => {\r\n      if (value.type !== \"number\") {\r\n        return NULL_VALUE;\r\n      }\r\n      return fromNumber(-value.data);\r\n    });\r\n  },\r\n  Pos({ base }, scope, execute) {\r\n    return promiselessApply(execute(base, scope), (value) => {\r\n      if (value.type !== \"number\") {\r\n        return NULL_VALUE;\r\n      }\r\n      return fromNumber(value.data);\r\n    });\r\n  },\r\n  Asc() {\r\n    return NULL_VALUE;\r\n  },\r\n  Desc() {\r\n    return NULL_VALUE;\r\n  },\r\n  async ArrayCoerce({ base }, scope, execute) {\r\n    const value = await execute(base, scope);\r\n    return value.isArray() ? value : NULL_VALUE;\r\n  },\r\n  async Map({ base, expr }, scope, execute) {\r\n    const value = await execute(base, scope);\r\n    if (!value.isArray()) {\r\n      return NULL_VALUE;\r\n    }\r\n    return new StreamValue(async function* () {\r\n      for await (const elem of value) {\r\n        const newScope = scope.createHidden(elem);\r\n        yield await execute(expr, newScope);\r\n      }\r\n    });\r\n  },\r\n  async FlatMap({ base, expr }, scope, execute) {\r\n    const value = await execute(base, scope);\r\n    if (!value.isArray()) {\r\n      return NULL_VALUE;\r\n    }\r\n    return new StreamValue(async function* () {\r\n      for await (const elem of value) {\r\n        const newScope = scope.createHidden(elem);\r\n        const innerValue = await execute(expr, newScope);\r\n        if (innerValue.isArray()) {\r\n          for await (const inner of innerValue) {\r\n            yield inner;\r\n          }\r\n        } else {\r\n          yield innerValue;\r\n        }\r\n      }\r\n    });\r\n  }\r\n};\r\nfunction evaluateQuery(tree, options = {}) {\r\n  const root = fromJS(options.root);\r\n  const dataset = fromJS(options.dataset);\r\n  const params = __spreadValues({}, options.params);\r\n  const scope = new Scope(params, dataset, root, {\r\n    timestamp: options.timestamp || new Date(),\r\n    identity: options.identity === void 0 ? \"me\" : options.identity,\r\n    sanity: options.sanity,\r\n    after: options.after ? fromJS(options.after) : null,\r\n    before: options.before ? fromJS(options.before) : null\r\n  }, null);\r\n  return evaluate(tree, scope);\r\n}\r\nfunction canConstantEvaluate(node) {\r\n  switch (node.type) {\r\n    case \"Group\":\r\n    case \"Value\":\r\n    case \"Parameter\":\r\n    case \"Pos\":\r\n    case \"Neg\":\r\n      return true;\r\n    case \"OpCall\":\r\n      switch (node.op) {\r\n        case \"+\":\r\n        case \"-\":\r\n        case \"*\":\r\n        case \"/\":\r\n        case \"%\":\r\n        case \"**\":\r\n          return true;\r\n        default:\r\n          return false;\r\n      }\r\n    default:\r\n      return false;\r\n  }\r\n}\r\nconst DUMMY_SCOPE = new Scope({}, NULL_VALUE, NULL_VALUE, { timestamp: new Date(0), identity: \"me\", before: null, after: null }, null);\r\nclass ConstantEvaluateError extends Error {\r\n  constructor() {\r\n    super(...arguments);\r\n    this.name = \"ConstantEvaluateError\";\r\n  }\r\n}\r\nfunction tryConstantEvaluate(node) {\r\n  try {\r\n    return constantEvaluate(node);\r\n  } catch (err) {\r\n    if (err.name === \"ConstantEvaluateError\") {\r\n      return null;\r\n    }\r\n    throw err;\r\n  }\r\n}\r\nfunction constantEvaluate(node) {\r\n  if (!canConstantEvaluate(node)) {\r\n    throw new ConstantEvaluateError(\"cannot constant evaluate\");\r\n  }\r\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate);\r\n  if (\"then\" in value) {\r\n    throw new Error(\"BUG: constant evaluate should never return a promise\");\r\n  }\r\n  return value;\r\n}\r\nconst ESCAPE_SEQUENCE = {\r\n  \"'\": \"'\",\r\n  '\"': '\"',\r\n  \"\\\\\": \"\\\\\",\r\n  \"/\": \"/\",\r\n  b: \"\\b\",\r\n  f: \"\\f\",\r\n  n: \"\\n\",\r\n  r: \"\\r\",\r\n  t: \"\t\"\r\n};\r\nfunction expandHex(str) {\r\n  const charCode = parseInt(str, 16);\r\n  return String.fromCharCode(charCode);\r\n}\r\nclass GroqQueryError extends Error {\r\n  constructor() {\r\n    super(...arguments);\r\n    this.name = \"GroqQueryError\";\r\n  }\r\n}\r\nconst EXPR_BUILDER = {\r\n  group(p) {\r\n    const inner = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"Group\",\r\n      base: inner\r\n    };\r\n  },\r\n  everything() {\r\n    return { type: \"Everything\" };\r\n  },\r\n  this() {\r\n    return { type: \"This\" };\r\n  },\r\n  parent() {\r\n    return {\r\n      type: \"Parent\",\r\n      n: 1\r\n    };\r\n  },\r\n  dblparent(p) {\r\n    const next = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"Parent\",\r\n      n: next.n + 1\r\n    };\r\n  },\r\n  traverse(p) {\r\n    const base = p.process(EXPR_BUILDER);\r\n    const traversalList = [];\r\n    while (p.getMark().name !== \"traversal_end\") {\r\n      traversalList.push(p.process(TRAVERSE_BUILDER));\r\n    }\r\n    p.shift();\r\n    let traversal = null;\r\n    for (let i = traversalList.length - 1; i >= 0; i--) {\r\n      traversal = traversalList[i](traversal);\r\n    }\r\n    if (base.type === \"Everything\" || base.type === \"Array\" || base.type === \"PipeFuncCall\") {\r\n      traversal = traverseArray((val) => val, traversal);\r\n    }\r\n    if (traversal === null)\r\n      throw new Error(\"BUG: unexpected empty traversal\");\r\n    return traversal.build(base);\r\n  },\r\n  this_attr(p) {\r\n    const name = p.processString();\r\n    if (name === \"null\") {\r\n      return { type: \"Value\", value: null };\r\n    }\r\n    if (name === \"true\") {\r\n      return { type: \"Value\", value: true };\r\n    }\r\n    if (name === \"false\") {\r\n      return { type: \"Value\", value: false };\r\n    }\r\n    return {\r\n      type: \"AccessAttribute\",\r\n      name\r\n    };\r\n  },\r\n  neg(p) {\r\n    const base = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"Neg\",\r\n      base\r\n    };\r\n  },\r\n  pos(p) {\r\n    const base = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"Pos\",\r\n      base\r\n    };\r\n  },\r\n  add(p) {\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"OpCall\",\r\n      op: \"+\",\r\n      left,\r\n      right\r\n    };\r\n  },\r\n  sub(p) {\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"OpCall\",\r\n      op: \"-\",\r\n      left,\r\n      right\r\n    };\r\n  },\r\n  mul(p) {\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"OpCall\",\r\n      op: \"*\",\r\n      left,\r\n      right\r\n    };\r\n  },\r\n  div(p) {\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"OpCall\",\r\n      op: \"/\",\r\n      left,\r\n      right\r\n    };\r\n  },\r\n  mod(p) {\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"OpCall\",\r\n      op: \"%\",\r\n      left,\r\n      right\r\n    };\r\n  },\r\n  pow(p) {\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"OpCall\",\r\n      op: \"**\",\r\n      left,\r\n      right\r\n    };\r\n  },\r\n  comp(p) {\r\n    const left = p.process(EXPR_BUILDER);\r\n    const op = p.processString();\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"OpCall\",\r\n      op,\r\n      left,\r\n      right\r\n    };\r\n  },\r\n  in_range(p) {\r\n    const base = p.process(EXPR_BUILDER);\r\n    const isInclusive = p.getMark().name === \"inc_range\";\r\n    p.shift();\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"InRange\",\r\n      base,\r\n      left,\r\n      right,\r\n      isInclusive\r\n    };\r\n  },\r\n  str(p) {\r\n    let value = \"\";\r\n    loop:\r\n      while (p.hasMark()) {\r\n        const mark = p.getMark();\r\n        switch (mark.name) {\r\n          case \"str_end\":\r\n            value += p.processStringEnd();\r\n            break loop;\r\n          case \"str_pause\":\r\n            value += p.processStringEnd();\r\n            break;\r\n          case \"str_start\":\r\n            p.shift();\r\n            break;\r\n          case \"single_escape\": {\r\n            const char = p.slice(1);\r\n            p.shift();\r\n            value += ESCAPE_SEQUENCE[char];\r\n            break;\r\n          }\r\n          case \"unicode_hex\":\r\n            p.shift();\r\n            value += expandHex(p.processStringEnd());\r\n            break;\r\n          default:\r\n            throw new Error(`unexpected mark: ${mark.name}`);\r\n        }\r\n      }\r\n    return { type: \"Value\", value };\r\n  },\r\n  integer(p) {\r\n    const strValue = p.processStringEnd();\r\n    return {\r\n      type: \"Value\",\r\n      value: Number(strValue)\r\n    };\r\n  },\r\n  float(p) {\r\n    const strValue = p.processStringEnd();\r\n    return {\r\n      type: \"Value\",\r\n      value: Number(strValue)\r\n    };\r\n  },\r\n  sci(p) {\r\n    const strValue = p.processStringEnd();\r\n    return {\r\n      type: \"Value\",\r\n      value: Number(strValue)\r\n    };\r\n  },\r\n  object(p) {\r\n    const attributes = [];\r\n    while (p.getMark().name !== \"object_end\") {\r\n      attributes.push(p.process(OBJECT_BUILDER));\r\n    }\r\n    p.shift();\r\n    return {\r\n      type: \"Object\",\r\n      attributes\r\n    };\r\n  },\r\n  array(p) {\r\n    const elements = [];\r\n    while (p.getMark().name !== \"array_end\") {\r\n      let isSplat = false;\r\n      if (p.getMark().name === \"array_splat\") {\r\n        isSplat = true;\r\n        p.shift();\r\n      }\r\n      const value = p.process(EXPR_BUILDER);\r\n      elements.push({\r\n        type: \"ArrayElement\",\r\n        value,\r\n        isSplat\r\n      });\r\n    }\r\n    p.shift();\r\n    return {\r\n      type: \"Array\",\r\n      elements\r\n    };\r\n  },\r\n  tuple(p) {\r\n    const members = [];\r\n    while (p.getMark().name !== \"tuple_end\") {\r\n      members.push(p.process(EXPR_BUILDER));\r\n    }\r\n    p.shift();\r\n    return {\r\n      type: \"Tuple\",\r\n      members\r\n    };\r\n  },\r\n  func_call(p) {\r\n    let namespace = \"global\";\r\n    if (p.getMark().name === \"namespace\") {\r\n      p.shift();\r\n      namespace = p.processString();\r\n    }\r\n    const name = p.processString();\r\n    if (namespace === \"global\" && name === \"select\") {\r\n      const result = {\r\n        type: \"Select\",\r\n        alternatives: []\r\n      };\r\n      while (p.getMark().name !== \"func_args_end\") {\r\n        if (p.getMark().name === \"pair\") {\r\n          if (result.fallback)\r\n            throw new GroqQueryError(`unexpected argument to select()`);\r\n          p.shift();\r\n          const condition = p.process(EXPR_BUILDER);\r\n          const value = p.process(EXPR_BUILDER);\r\n          result.alternatives.push({\r\n            type: \"SelectAlternative\",\r\n            condition,\r\n            value\r\n          });\r\n        } else {\r\n          if (result.fallback)\r\n            throw new GroqQueryError(`unexpected argument to select()`);\r\n          const value = p.process(EXPR_BUILDER);\r\n          result.fallback = value;\r\n        }\r\n      }\r\n      p.shift();\r\n      return result;\r\n    }\r\n    const args = [];\r\n    while (p.getMark().name !== \"func_args_end\") {\r\n      args.push(p.process(EXPR_BUILDER));\r\n    }\r\n    p.shift();\r\n    if (namespace === \"global\" && (name === \"before\" || name === \"after\")) {\r\n      if (p.parseOptions.mode === \"delta\") {\r\n        return {\r\n          type: \"Context\",\r\n          key: name\r\n        };\r\n      }\r\n    }\r\n    if (namespace === \"global\" && name === \"boost\" && !p.allowBoost)\r\n      throw new GroqQueryError(\"unexpected boost\");\r\n    const funcs = namespaces[namespace];\r\n    if (!funcs) {\r\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\r\n    }\r\n    const func = funcs[name];\r\n    if (!func) {\r\n      throw new GroqQueryError(`Undefined function: ${name}`);\r\n    }\r\n    if (func.arity !== void 0) {\r\n      validateArity(name, func.arity, args.length);\r\n    }\r\n    if (func.mode !== void 0 && func.mode !== p.parseOptions.mode) {\r\n      throw new GroqQueryError(`Undefined function: ${name}`);\r\n    }\r\n    return {\r\n      type: \"FuncCall\",\r\n      func,\r\n      name,\r\n      args\r\n    };\r\n  },\r\n  pipecall(p) {\r\n    const base = p.process(EXPR_BUILDER);\r\n    p.shift();\r\n    let namespace = \"global\";\r\n    if (p.getMark().name === \"namespace\") {\r\n      p.shift();\r\n      namespace = p.processString();\r\n    }\r\n    if (namespace !== \"global\") {\r\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`);\r\n    }\r\n    const name = p.processString();\r\n    const args = [];\r\n    const oldAllowBoost = p.allowBoost;\r\n    if (name === \"score\") {\r\n      p.allowBoost = true;\r\n    }\r\n    for (; ; ) {\r\n      const markName = p.getMark().name;\r\n      if (markName === \"func_args_end\") {\r\n        break;\r\n      }\r\n      if (name === \"order\") {\r\n        if (markName === \"asc\") {\r\n          p.shift();\r\n          args.push({ type: \"Asc\", base: p.process(EXPR_BUILDER) });\r\n          continue;\r\n        } else if (markName === \"desc\") {\r\n          p.shift();\r\n          args.push({ type: \"Desc\", base: p.process(EXPR_BUILDER) });\r\n          continue;\r\n        }\r\n      }\r\n      args.push(p.process(EXPR_BUILDER));\r\n    }\r\n    p.shift();\r\n    p.allowBoost = oldAllowBoost;\r\n    const func = pipeFunctions[name];\r\n    if (!func) {\r\n      throw new GroqQueryError(`Undefined pipe function: ${name}`);\r\n    }\r\n    if (func.arity) {\r\n      validateArity(name, func.arity, args.length);\r\n    }\r\n    return {\r\n      type: \"PipeFuncCall\",\r\n      func,\r\n      base,\r\n      name,\r\n      args\r\n    };\r\n  },\r\n  pair(p) {\r\n    throw new GroqQueryError(`unexpected =>`);\r\n  },\r\n  and(p) {\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"And\",\r\n      left,\r\n      right\r\n    };\r\n  },\r\n  or(p) {\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"Or\",\r\n      left,\r\n      right\r\n    };\r\n  },\r\n  not(p) {\r\n    const base = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"Not\",\r\n      base\r\n    };\r\n  },\r\n  asc(p) {\r\n    throw new GroqQueryError(\"unexpected asc\");\r\n  },\r\n  desc(p) {\r\n    throw new GroqQueryError(\"unexpected desc\");\r\n  },\r\n  param(p) {\r\n    const name = p.processString();\r\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\r\n      return {\r\n        type: \"Value\",\r\n        value: p.parseOptions.params[name]\r\n      };\r\n    }\r\n    return {\r\n      type: \"Parameter\",\r\n      name\r\n    };\r\n  }\r\n};\r\nconst OBJECT_BUILDER = {\r\n  object_expr(p) {\r\n    if (p.getMark().name === \"pair\") {\r\n      p.shift();\r\n      const condition = p.process(EXPR_BUILDER);\r\n      const value2 = p.process(EXPR_BUILDER);\r\n      return {\r\n        type: \"ObjectConditionalSplat\",\r\n        condition,\r\n        value: value2\r\n      };\r\n    }\r\n    const value = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"ObjectAttributeValue\",\r\n      name: extractPropertyKey(value),\r\n      value\r\n    };\r\n  },\r\n  object_pair(p) {\r\n    const name = p.process(EXPR_BUILDER);\r\n    if (name.type !== \"Value\")\r\n      throw new Error(\"name must be string\");\r\n    const value = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"ObjectAttributeValue\",\r\n      name: name.value,\r\n      value\r\n    };\r\n  },\r\n  object_splat(p) {\r\n    const value = p.process(EXPR_BUILDER);\r\n    return {\r\n      type: \"ObjectSplat\",\r\n      value\r\n    };\r\n  },\r\n  object_splat_this() {\r\n    return {\r\n      type: \"ObjectSplat\",\r\n      value: { type: \"This\" }\r\n    };\r\n  }\r\n};\r\nconst TRAVERSE_BUILDER = {\r\n  square_bracket(p) {\r\n    const expr = p.process(EXPR_BUILDER);\r\n    const value = tryConstantEvaluate(expr);\r\n    if (value && value.type === \"number\") {\r\n      return (right) => traverseElement((base) => ({ type: \"AccessElement\", base, index: value.data }), right);\r\n    }\r\n    if (value && value.type === \"string\") {\r\n      return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name: value.data }), right);\r\n    }\r\n    return (right) => traverseArray((base) => ({\r\n      type: \"Filter\",\r\n      base,\r\n      expr\r\n    }), right);\r\n  },\r\n  slice(p) {\r\n    const isInclusive = p.getMark().name === \"inc_range\";\r\n    p.shift();\r\n    const left = p.process(EXPR_BUILDER);\r\n    const right = p.process(EXPR_BUILDER);\r\n    const leftValue = tryConstantEvaluate(left);\r\n    const rightValue = tryConstantEvaluate(right);\r\n    if (!leftValue || !rightValue || leftValue.type !== \"number\" || rightValue.type !== \"number\") {\r\n      throw new GroqQueryError(\"slicing must use constant numbers\");\r\n    }\r\n    return (rhs) => traverseArray((base) => ({\r\n      type: \"Slice\",\r\n      base,\r\n      left: leftValue.data,\r\n      right: rightValue.data,\r\n      isInclusive\r\n    }), rhs);\r\n  },\r\n  projection(p) {\r\n    const obj = p.process(EXPR_BUILDER);\r\n    return (right) => traverseProjection((base) => ({ type: \"Projection\", base, expr: obj }), right);\r\n  },\r\n  attr_access(p) {\r\n    const name = p.processString();\r\n    return (right) => traversePlain((base) => ({ type: \"AccessAttribute\", base, name }), right);\r\n  },\r\n  deref(p) {\r\n    let attr = null;\r\n    if (p.getMark().name === \"deref_attr\") {\r\n      p.shift();\r\n      attr = p.processString();\r\n    }\r\n    const wrap = (base) => attr ? { type: \"AccessAttribute\", base, name: attr } : base;\r\n    return (right) => traversePlain((base) => wrap({\r\n      type: \"Deref\",\r\n      base\r\n    }), right);\r\n  },\r\n  array_postfix(p) {\r\n    return (right) => traverseArray((base) => ({ type: \"ArrayCoerce\", base }), right);\r\n  }\r\n};\r\nfunction extractPropertyKey(node) {\r\n  if (node.type === \"AccessAttribute\" && !node.base) {\r\n    return node.name;\r\n  }\r\n  if (node.type === \"Deref\" || node.type === \"Map\" || node.type === \"Projection\" || node.type === \"Slice\" || node.type === \"Filter\" || node.type === \"AccessElement\" || node.type === \"ArrayCoerce\") {\r\n    return extractPropertyKey(node.base);\r\n  }\r\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`);\r\n}\r\nfunction validateArity(name, arity, count2) {\r\n  if (typeof arity === \"number\") {\r\n    if (count2 !== arity) {\r\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count2}.`);\r\n    }\r\n  } else if (arity) {\r\n    if (!arity(count2)) {\r\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`);\r\n    }\r\n  }\r\n}\r\nclass GroqSyntaxError extends Error {\r\n  constructor(position) {\r\n    super(`Syntax error in GROQ query at position ${position}`);\r\n    this.name = \"GroqSyntaxError\";\r\n    this.position = position;\r\n  }\r\n}\r\nfunction parse(input, options = {}) {\r\n  const result = parse$1(input);\r\n  if (result.type === \"error\") {\r\n    throw new GroqSyntaxError(result.position);\r\n  }\r\n  const processor = new MarkProcessor(input, result.marks, options);\r\n  return processor.process(EXPR_BUILDER);\r\n}\r\n\r\n//# sourceMappingURL=groq-js.esm.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0L2dyb3EtanMuZXNtLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxtQkFBbUIsRUFBRSxJQUFJLEVBQUU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEJBQTBCO0FBQ3JEO0FBQ0EsWUFBWSxLQUFLLEdBQUcsTUFBTSxHQUFHLElBQUksR0FBRyxLQUFLLEdBQUcsT0FBTyxHQUFHLE9BQU8sRUFBRSxpQkFBaUI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxHQUFHO0FBQ3RDLGdEQUFnRCxHQUFHO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsb0RBQW9EO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQixvQkFBb0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUNBQWlDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsdUJBQXVCLGtDQUFrQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQ0FBbUM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlDQUFpQztBQUNsRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0NBQW9DO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0NBQWtDO0FBQ3ZELFFBQVE7QUFDUixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVDQUF1QztBQUM1RDtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0NBQWtDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3Q0FBd0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1DQUFtQztBQUMvQyxZQUFZLHVDQUF1QztBQUNuRCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEJBQTBCO0FBQ3RDLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUNBQXVDO0FBQ3ZELGdCQUFnQixtQ0FBbUM7QUFDbkQsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNDQUFzQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrQ0FBa0M7QUFDaEUsMkJBQTJCLGdDQUFnQyxJQUFJLHdDQUF3QztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0NBQWtDO0FBQzVELHVCQUF1QixnQ0FBZ0MsSUFBSSxtQ0FBbUM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0NBQWdDO0FBQzVEO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQ0FBaUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RCx1QkFBdUIsZ0NBQWdDLElBQUksd0NBQXdDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxzQ0FBc0M7QUFDdEUsdUNBQXVDLGdDQUFnQztBQUN2RTtBQUNBLGdCQUFnQjtBQUNoQixnQ0FBZ0Msa0NBQWtDO0FBQ2xFLDZCQUE2QixnQ0FBZ0MsSUFBSSx3Q0FBd0M7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtDQUFrQztBQUNoRSwyQkFBMkIsZ0NBQWdDLElBQUksd0NBQXdDO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUNBQXlDO0FBQ3JELFlBQVkscUNBQXFDO0FBQ2pELFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdDQUF3QyxJQUFJLG1DQUFtQyxJQUFJLGtDQUFrQztBQUMxSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJDQUEyQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUNBQW1DO0FBQ2pELGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHdDQUF3QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsd0NBQXdDO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVDQUF1QztBQUN0RDtBQUNBLGlCQUFpQix1Q0FBdUM7QUFDeEQsaUJBQWlCLG1DQUFtQyxJQUFJLGtDQUFrQztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsaUJBQWlCLDhCQUE4QixJQUFJLDRDQUE0QztBQUMvRjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsSUFBSTtBQUNKLGlCQUFpQixtQ0FBbUMsSUFBSSxrQ0FBa0M7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxlQUFlLDBDQUEwQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwrQkFBK0I7QUFDaEQ7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix5Q0FBeUM7QUFDOUQ7QUFDQTtBQUNBLFFBQVE7QUFDUixxQkFBcUIsOENBQThDO0FBQ25FO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0NBQXdDO0FBQzdEO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0JBQStCLG9DQUFvQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBLGFBQWE7QUFDYjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsdUJBQXVCLGdDQUFnQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQ0FBa0M7QUFDekQ7QUFDQSxtQ0FBbUM7QUFDbkMsMkJBQTJCLHdDQUF3QztBQUNuRSxrQ0FBa0M7QUFDbEMsMkJBQTJCLHdDQUF3QztBQUNuRTtBQUNBLGNBQWM7QUFDZCwyQkFBMkIsd0NBQXdDO0FBQ25FLDJCQUEyQiw0Q0FBNEM7QUFDdkU7QUFDQTtBQUNBLFlBQVk7QUFDWix5QkFBeUIsMENBQTBDO0FBQ25FO0FBQ0E7QUFDQSx1QkFBdUIsc0NBQXNDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQ0FBaUMsY0FBYyxHQUFHO0FBQ3hFO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDLGNBQWMsR0FBRztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsV0FBVztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxXQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsY0FBYyxNQUFNO0FBQ3BCO0FBQ0EsR0FBRztBQUNILFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxJQUFJO0FBQ2hELEdBQUc7QUFDSCxXQUFXLEdBQUc7QUFDZDtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0EsMkNBQTJDLEdBQUc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsZ0NBQWdDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxhQUFhLFlBQVk7QUFDekI7QUFDQSxHQUFHO0FBQ0gsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNILDBCQUEwQixZQUFZO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFVBQVUsT0FBTztBQUNqQjtBQUNBLEdBQUc7QUFDSCxVQUFVLE1BQU07QUFDaEI7QUFDQSxHQUFHO0FBQ0gsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsU0FBUztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxRQUFRLE1BQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLE1BQU07QUFDNUI7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSCxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw0QkFBNEIsbUVBQW1FO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBLGFBQWE7QUFDYixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFVBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxVQUFVO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRDQUE0QztBQUNsRTtBQUNBLFVBQVU7QUFDVjtBQUNBLHNCQUFzQiw2Q0FBNkM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGdEQUFnRDtBQUNyRztBQUNBO0FBQ0EsbURBQW1ELGlEQUFpRDtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLHNEQUFzRCxxQ0FBcUM7QUFDM0YsR0FBRztBQUNIO0FBQ0E7QUFDQSxpREFBaUQscUNBQXFDO0FBQ3RGLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNENBQTRDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxpREFBaUQsMkJBQTJCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxVQUFVO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLEtBQUssZUFBZSxNQUFNLFFBQVEsT0FBTztBQUNySDtBQUNBLElBQUk7QUFDSjtBQUNBLDRFQUE0RSxLQUFLO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsU0FBUztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM0QztBQUM1QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZ3JvcS1qcy9kaXN0L2dyb3EtanMuZXNtLmpzPzZkNzkiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcclxudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xyXG52YXIgX19oYXNPd25Qcm9wID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XHJcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcclxudmFyIF9fc3ByZWFkVmFsdWVzID0gKGEsIGIpID0+IHtcclxuICBmb3IgKHZhciBwcm9wIGluIGIgfHwgKGIgPSB7fSkpXHJcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhLCBwcm9wLCBiW3Byb3BdKTtcclxuICBpZiAoX19nZXRPd25Qcm9wU3ltYm9scylcclxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xyXG4gICAgICBpZiAoX19wcm9wSXNFbnVtLmNhbGwoYiwgcHJvcCkpXHJcbiAgICAgICAgX19kZWZOb3JtYWxQcm9wKGEsIHByb3AsIGJbcHJvcF0pO1xyXG4gICAgfVxyXG4gIHJldHVybiBhO1xyXG59O1xyXG5jbGFzcyBNYXJrUHJvY2Vzc29yIHtcclxuICBjb25zdHJ1Y3RvcihzdHJpbmczLCBtYXJrcywgcGFyc2VPcHRpb25zKSB7XHJcbiAgICB0aGlzLmFsbG93Qm9vc3QgPSBmYWxzZTtcclxuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nMztcclxuICAgIHRoaXMubWFya3MgPSBtYXJrcztcclxuICAgIHRoaXMuaW5kZXggPSAwO1xyXG4gICAgdGhpcy5wYXJzZU9wdGlvbnMgPSBwYXJzZU9wdGlvbnM7XHJcbiAgfVxyXG4gIGhhc01hcmsocG9zID0gMCkge1xyXG4gICAgcmV0dXJuIHRoaXMuaW5kZXggKyBwb3MgPCB0aGlzLm1hcmtzLmxlbmd0aDtcclxuICB9XHJcbiAgZ2V0TWFyayhwb3MgPSAwKSB7XHJcbiAgICByZXR1cm4gdGhpcy5tYXJrc1t0aGlzLmluZGV4ICsgcG9zXTtcclxuICB9XHJcbiAgc2hpZnQoKSB7XHJcbiAgICB0aGlzLmluZGV4ICs9IDE7XHJcbiAgfVxyXG4gIHByb2Nlc3ModmlzaXRvcikge1xyXG4gICAgY29uc3QgbWFyayA9IHRoaXMubWFya3NbdGhpcy5pbmRleF07XHJcbiAgICB0aGlzLnNoaWZ0KCk7XHJcbiAgICBjb25zdCBmdW5jID0gdmlzaXRvclttYXJrLm5hbWVdO1xyXG4gICAgaWYgKCFmdW5jKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBoYW5kbGVyOiAke21hcmsubmFtZX1gKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jLmNhbGwodmlzaXRvciwgdGhpcywgbWFyayk7XHJcbiAgfVxyXG4gIHByb2Nlc3NTdHJpbmcoKSB7XHJcbiAgICB0aGlzLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzU3RyaW5nRW5kKCk7XHJcbiAgfVxyXG4gIHByb2Nlc3NTdHJpbmdFbmQoKSB7XHJcbiAgICBjb25zdCBwcmV2ID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4IC0gMV07XHJcbiAgICBjb25zdCBjdXJyID0gdGhpcy5tYXJrc1t0aGlzLmluZGV4XTtcclxuICAgIHRoaXMuc2hpZnQoKTtcclxuICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShwcmV2LnBvc2l0aW9uLCBjdXJyLnBvc2l0aW9uKTtcclxuICB9XHJcbiAgc2xpY2UobGVuKSB7XHJcbiAgICBjb25zdCBwb3MgPSB0aGlzLm1hcmtzW3RoaXMuaW5kZXhdLnBvc2l0aW9uO1xyXG4gICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKHBvcywgcG9zICsgbGVuKTtcclxuICB9XHJcbn1cclxuY29uc3QgUkZDMzMzOV9SRUdFWCA9IC9eXFxkezR9LVxcZHsyfS1cXGR7Mn1UXFxkezJ9OlxcZHsyfTpcXGR7Mn0oXFwuXFxkKyk/KFp8KFstK11cXGR7Mn06XFxkezJ9KSkkLztcclxuZnVuY3Rpb24gcGFyc2VSRkMzMzM5KHN0cikge1xyXG4gIGlmIChSRkMzMzM5X1JFR0VYLnRlc3Qoc3RyKSkge1xyXG4gICAgcmV0dXJuIG5ldyBEYXRlKHN0cik7XHJcbiAgfVxyXG4gIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGZvcm1hdFJGQzMzMzkoZCkge1xyXG4gIGNvbnN0IHllYXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0Z1bGxZZWFyKCksIDQpO1xyXG4gIGNvbnN0IG1vbnRoID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENNb250aCgpICsgMSwgMik7XHJcbiAgY29uc3QgZGF5ID0gYWRkTGVhZGluZ1plcm8oZC5nZXRVVENEYXRlKCksIDIpO1xyXG4gIGNvbnN0IGhvdXIgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ0hvdXJzKCksIDIpO1xyXG4gIGNvbnN0IG1pbnV0ZSA9IGFkZExlYWRpbmdaZXJvKGQuZ2V0VVRDTWludXRlcygpLCAyKTtcclxuICBjb25zdCBzZWNvbmQgPSBhZGRMZWFkaW5nWmVybyhkLmdldFVUQ1NlY29uZHMoKSwgMik7XHJcbiAgbGV0IGZyYWN0aW9uYWxTZWNvbmQgPSBcIlwiO1xyXG4gIGNvbnN0IG1pbGxpcyA9IGQuZ2V0TWlsbGlzZWNvbmRzKCk7XHJcbiAgaWYgKG1pbGxpcyAhPSAwKSB7XHJcbiAgICBmcmFjdGlvbmFsU2Vjb25kID0gYC4ke2FkZExlYWRpbmdaZXJvKG1pbGxpcywgMyl9YDtcclxuICB9XHJcbiAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fVQke2hvdXJ9OiR7bWludXRlfToke3NlY29uZH0ke2ZyYWN0aW9uYWxTZWNvbmR9WmA7XHJcbn1cclxuZnVuY3Rpb24gYWRkTGVhZGluZ1plcm8obnVtLCB0YXJnZXRMZW5ndGgpIHtcclxuICBsZXQgc3RyID0gbnVtLnRvU3RyaW5nKCk7XHJcbiAgd2hpbGUgKHN0ci5sZW5ndGggPCB0YXJnZXRMZW5ndGgpIHtcclxuICAgIHN0ciA9IGAwJHtzdHJ9YDtcclxuICB9XHJcbiAgcmV0dXJuIHN0cjtcclxufVxyXG5mdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nMykge1xyXG4gIHJldHVybiBzdHJpbmczLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcclxufVxyXG5mdW5jdGlvbiBwYXRoUmVnRXhwKHBhdHRlcm4pIHtcclxuICBjb25zdCByZSA9IFtdO1xyXG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXR0ZXJuLnNwbGl0KFwiLlwiKSkge1xyXG4gICAgaWYgKHBhcnQgPT09IFwiKlwiKSB7XHJcbiAgICAgIHJlLnB1c2goXCJbXi5dK1wiKTtcclxuICAgIH0gZWxzZSBpZiAocGFydCA9PT0gXCIqKlwiKSB7XHJcbiAgICAgIHJlLnB1c2goXCIuKlwiKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJlLnB1c2goZXNjYXBlUmVnRXhwKHBhcnQpKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlLmpvaW4oXCIuXCIpfSRgKTtcclxufVxyXG5jbGFzcyBQYXRoIHtcclxuICBjb25zdHJ1Y3RvcihwYXR0ZXJuKSB7XHJcbiAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xyXG4gICAgdGhpcy5wYXR0ZXJuUmUgPSBwYXRoUmVnRXhwKHBhdHRlcm4pO1xyXG4gIH1cclxuICBtYXRjaGVzKHN0cikge1xyXG4gICAgcmV0dXJuIHRoaXMucGF0dGVyblJlLnRlc3Qoc3RyKTtcclxuICB9XHJcbiAgdG9KU09OKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucGF0dGVybjtcclxuICB9XHJcbn1cclxuY2xhc3MgU3RyZWFtVmFsdWUge1xyXG4gIGNvbnN0cnVjdG9yKGdlbmVyYXRvcikge1xyXG4gICAgdGhpcy50eXBlID0gXCJzdHJlYW1cIjtcclxuICAgIHRoaXMuZ2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xyXG4gICAgdGhpcy50aWNrZXIgPSBudWxsO1xyXG4gICAgdGhpcy5pc0RvbmUgPSBmYWxzZTtcclxuICAgIHRoaXMuZGF0YSA9IFtdO1xyXG4gIH1cclxuICBpc0FycmF5KCkge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGFzeW5jIGdldCgpIHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzKSB7XHJcbiAgICAgIHJlc3VsdC5wdXNoKGF3YWl0IHZhbHVlLmdldCgpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG4gIGFzeW5jICpbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgZm9yICg7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB5aWVsZCB0aGlzLmRhdGFbaV07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuaXNEb25lKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGF3YWl0IHRoaXMuX25leHRUaWNrKCk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIF9uZXh0VGljaygpIHtcclxuICAgIGlmICh0aGlzLnRpY2tlcikge1xyXG4gICAgICByZXR1cm4gdGhpcy50aWNrZXI7XHJcbiAgICB9XHJcbiAgICBsZXQgY3VycmVudFJlc29sdmVyO1xyXG4gICAgY29uc3Qgc2V0dXBUaWNrZXIgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMudGlja2VyID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICBjdXJyZW50UmVzb2x2ZXIgPSByZXNvbHZlO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgICBjb25zdCB0aWNrID0gKCkgPT4ge1xyXG4gICAgICBjdXJyZW50UmVzb2x2ZXIoKTtcclxuICAgICAgc2V0dXBUaWNrZXIoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBmZXRjaCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiB0aGlzLmdlbmVyYXRvcigpKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xyXG4gICAgICAgIHRpY2soKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmlzRG9uZSA9IHRydWU7XHJcbiAgICAgIHRpY2soKTtcclxuICAgIH07XHJcbiAgICBzZXR1cFRpY2tlcigpO1xyXG4gICAgZmV0Y2goKTtcclxuICAgIHJldHVybiB0aGlzLnRpY2tlcjtcclxuICB9XHJcbn1cclxuY2xhc3MgU3RhdGljVmFsdWUge1xyXG4gIGNvbnN0cnVjdG9yKGRhdGEsIHR5cGUpIHtcclxuICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gIH1cclxuICBpc0FycmF5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gXCJhcnJheVwiO1xyXG4gIH1cclxuICBhc3luYyBnZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gIH1cclxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5kYXRhKSkge1xyXG4gICAgICByZXR1cm4gZnVuY3Rpb24qIChkYXRhKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpIHtcclxuICAgICAgICAgIHlpZWxkIGZyb21KUyhlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0odGhpcy5kYXRhKTtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGl0ZXJhdGUgb3ZlcjogJHt0aGlzLnR5cGV9YCk7XHJcbiAgfVxyXG59XHJcbmNvbnN0IE5VTExfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUobnVsbCwgXCJudWxsXCIpO1xyXG5jb25zdCBUUlVFX1ZBTFVFID0gbmV3IFN0YXRpY1ZhbHVlKHRydWUsIFwiYm9vbGVhblwiKTtcclxuY29uc3QgRkFMU0VfVkFMVUUgPSBuZXcgU3RhdGljVmFsdWUoZmFsc2UsIFwiYm9vbGVhblwiKTtcclxuY2xhc3MgRGF0ZVRpbWUge1xyXG4gIGNvbnN0cnVjdG9yKGRhdGUpIHtcclxuICAgIHRoaXMuZGF0ZSA9IGRhdGU7XHJcbiAgfVxyXG4gIHN0YXRpYyBwYXJzZVRvVmFsdWUoc3RyKSB7XHJcbiAgICBjb25zdCBkYXRlID0gcGFyc2VSRkMzMzM5KHN0cik7XHJcbiAgICBpZiAoZGF0ZSkge1xyXG4gICAgICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKG5ldyBEYXRlVGltZShkYXRlKSwgXCJkYXRldGltZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH1cclxuICBlcXVhbHMob3RoZXIpIHtcclxuICAgIHJldHVybiB0aGlzLmRhdGUuZ2V0VGltZSgpID09IG90aGVyLmRhdGUuZ2V0VGltZSgpO1xyXG4gIH1cclxuICBhZGQoc2Vjcykge1xyXG4gICAgY29uc3QgY29weSA9IG5ldyBEYXRlKHRoaXMuZGF0ZS5nZXRUaW1lKCkpO1xyXG4gICAgY29weS5zZXRUaW1lKGNvcHkuZ2V0VGltZSgpICsgc2VjcyAqIDFlMyk7XHJcbiAgICByZXR1cm4gbmV3IERhdGVUaW1lKGNvcHkpO1xyXG4gIH1cclxuICBkaWZmZXJlbmNlKG90aGVyKSB7XHJcbiAgICByZXR1cm4gKHRoaXMuZGF0ZS5nZXRUaW1lKCkgLSBvdGhlci5kYXRlLmdldFRpbWUoKSkgLyAxZTM7XHJcbiAgfVxyXG4gIGNvbXBhcmVUbyhvdGhlcikge1xyXG4gICAgcmV0dXJuIHRoaXMuZGF0ZS5nZXRUaW1lKCkgLSBvdGhlci5kYXRlLmdldFRpbWUoKTtcclxuICB9XHJcbiAgdG9TdHJpbmcoKSB7XHJcbiAgICByZXR1cm4gZm9ybWF0UkZDMzMzOSh0aGlzLmRhdGUpO1xyXG4gIH1cclxuICB0b0pTT04oKSB7XHJcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBmcm9tTnVtYmVyKG51bSkge1xyXG4gIGlmIChOdW1iZXIuaXNGaW5pdGUobnVtKSkge1xyXG4gICAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShudW0sIFwibnVtYmVyXCIpO1xyXG4gIH1cclxuICByZXR1cm4gTlVMTF9WQUxVRTtcclxufVxyXG5mdW5jdGlvbiBmcm9tU3RyaW5nKHN0cikge1xyXG4gIHJldHVybiBuZXcgU3RhdGljVmFsdWUoc3RyLCBcInN0cmluZ1wiKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRGF0ZVRpbWUoZHQpIHtcclxuICByZXR1cm4gbmV3IFN0YXRpY1ZhbHVlKGR0LCBcImRhdGV0aW1lXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGZyb21QYXRoKHBhdGgyKSB7XHJcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZShwYXRoMiwgXCJwYXRoXCIpO1xyXG59XHJcbmZ1bmN0aW9uIGlzSXRlcmF0b3Iob2JqKSB7XHJcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqLm5leHQgPT09IFwiZnVuY3Rpb25cIjtcclxufVxyXG5mdW5jdGlvbiBmcm9tSlModmFsKSB7XHJcbiAgaWYgKGlzSXRlcmF0b3IodmFsKSkge1xyXG4gICAgcmV0dXJuIG5ldyBTdHJlYW1WYWx1ZShhc3luYyBmdW5jdGlvbiogKCkge1xyXG4gICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHZhbCkge1xyXG4gICAgICAgIHlpZWxkIGZyb21KUyh2YWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdm9pZCAwKSB7XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9XHJcbiAgcmV0dXJuIG5ldyBTdGF0aWNWYWx1ZSh2YWwsIGdldFR5cGUodmFsKSk7XHJcbn1cclxuZnVuY3Rpb24gZ2V0VHlwZShkYXRhKSB7XHJcbiAgaWYgKGRhdGEgPT09IG51bGwgfHwgdHlwZW9mIGRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcclxuICAgIHJldHVybiBcIm51bGxcIjtcclxuICB9XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgIHJldHVybiBcImFycmF5XCI7XHJcbiAgfVxyXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgUGF0aCkge1xyXG4gICAgcmV0dXJuIFwicGF0aFwiO1xyXG4gIH1cclxuICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGVUaW1lKSB7XHJcbiAgICByZXR1cm4gXCJkYXRldGltZVwiO1xyXG4gIH1cclxuICByZXR1cm4gdHlwZW9mIGRhdGE7XHJcbn1cclxuY29uc3QgVFlQRV9PUkRFUiA9IHtcclxuICBkYXRldGltZTogMSxcclxuICBudW1iZXI6IDIsXHJcbiAgc3RyaW5nOiAzLFxyXG4gIGJvb2xlYW46IDRcclxufTtcclxuZnVuY3Rpb24gcGFydGlhbENvbXBhcmUoYSwgYikge1xyXG4gIGNvbnN0IGFUeXBlID0gZ2V0VHlwZShhKTtcclxuICBjb25zdCBiVHlwZSA9IGdldFR5cGUoYik7XHJcbiAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG4gIHN3aXRjaCAoYVR5cGUpIHtcclxuICAgIGNhc2UgXCJudW1iZXJcIjpcclxuICAgIGNhc2UgXCJib29sZWFuXCI6XHJcbiAgICAgIHJldHVybiBhIC0gYjtcclxuICAgIGNhc2UgXCJzdHJpbmdcIjpcclxuICAgICAgaWYgKGEgPCBiKVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgICAgaWYgKGEgPiBiKVxyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIGNhc2UgXCJkYXRldGltZVwiOlxyXG4gICAgICByZXR1cm4gYS5jb21wYXJlVG8oYik7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdG90YWxDb21wYXJlKGEsIGIpIHtcclxuICBjb25zdCBhVHlwZSA9IGdldFR5cGUoYSk7XHJcbiAgY29uc3QgYlR5cGUgPSBnZXRUeXBlKGIpO1xyXG4gIGNvbnN0IGFUeXBlT3JkZXIgPSBUWVBFX09SREVSW2FUeXBlXSB8fCAxMDA7XHJcbiAgY29uc3QgYlR5cGVPcmRlciA9IFRZUEVfT1JERVJbYlR5cGVdIHx8IDEwMDtcclxuICBpZiAoYVR5cGVPcmRlciAhPT0gYlR5cGVPcmRlcikge1xyXG4gICAgcmV0dXJuIGFUeXBlT3JkZXIgLSBiVHlwZU9yZGVyO1xyXG4gIH1cclxuICBsZXQgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUoYSwgYik7XHJcbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xyXG4gICAgcmVzdWx0ID0gMDtcclxuICB9XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5jb25zdCBDSEFSUyA9IC8oW14hQCMkJV4mKigpLFxcXFwvP1wiOzp7fXxbXFxdKzw+XFxzLV0pKy9nO1xyXG5jb25zdCBDSEFSU19XSVRIX1dJTERDQVJEID0gLyhbXiFAIyQlXiYoKSxcXFxcLz9cIjs6e318W1xcXSs8Plxccy1dKSsvZztcclxuY29uc3QgRURHRV9DSEFSUyA9IC8oXFxiXFwuK3xcXC4rXFxiKS9nO1xyXG5jb25zdCBNQVhfVEVSTV9MRU5HVEggPSAxMDI0O1xyXG5mdW5jdGlvbiBtYXRjaFRleHQodG9rZW5zLCBwYXR0ZXJucykge1xyXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHBhdHRlcm5zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuICByZXR1cm4gcGF0dGVybnMuZXZlcnkoKHBhdHRlcm4pID0+IHBhdHRlcm4odG9rZW5zKSk7XHJcbn1cclxuZnVuY3Rpb24gbWF0Y2hUb2tlbml6ZSh0ZXh0KSB7XHJcbiAgcmV0dXJuIHRleHQucmVwbGFjZShFREdFX0NIQVJTLCBcIlwiKS5tYXRjaChDSEFSUykgfHwgW107XHJcbn1cclxuZnVuY3Rpb24gbWF0Y2hBbmFseXplUGF0dGVybih0ZXh0KSB7XHJcbiAgY29uc3QgdGVybXNSZSA9IG1hdGNoUGF0dGVyblJlZ2V4KHRleHQpO1xyXG4gIHJldHVybiB0ZXJtc1JlLm1hcCgocmUpID0+ICh0b2tlbnMpID0+IHRva2Vucy5zb21lKCh0b2tlbikgPT4gcmUudGVzdCh0b2tlbikpKTtcclxufVxyXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm5SZWdleCh0ZXh0KSB7XHJcbiAgY29uc3QgdGVybXMgPSB0ZXh0LnJlcGxhY2UoRURHRV9DSEFSUywgXCJcIikubWF0Y2goQ0hBUlNfV0lUSF9XSUxEQ0FSRCkgfHwgW107XHJcbiAgcmV0dXJuIHRlcm1zLm1hcCgodGVybSkgPT4gbmV3IFJlZ0V4cChgXiR7dGVybS5zbGljZSgwLCBNQVhfVEVSTV9MRU5HVEgpLnJlcGxhY2UoL1xcKi9nLCBcIi4qXCIpfSRgLCBcImlcIikpO1xyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGdhdGhlclRleHQodmFsdWUsIGNiKSB7XHJcbiAgaWYgKHZhbHVlLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgIGNiKHZhbHVlLmRhdGEpO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG4gIGlmICh2YWx1ZS5pc0FycmF5KCkpIHtcclxuICAgIGxldCBzdWNjZXNzID0gdHJ1ZTtcclxuICAgIGZvciBhd2FpdCAoY29uc3QgcGFydCBvZiB2YWx1ZSkge1xyXG4gICAgICBpZiAocGFydC50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgY2IocGFydC5kYXRhKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzdWNjZXNzID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBzdWNjZXNzO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuY29uc3QgQk0yNWsgPSAxLjI7XHJcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlU2NvcmUobm9kZSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBpZiAobm9kZS50eXBlID09PSBcIk9wQ2FsbFwiICYmIG5vZGUub3AgPT09IFwibWF0Y2hcIikge1xyXG4gICAgcmV0dXJuIGV2YWx1YXRlTWF0Y2hTY29yZShub2RlLmxlZnQsIG5vZGUucmlnaHQsIHNjb3BlLCBleGVjdXRlKTtcclxuICB9XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJGdW5jQ2FsbFwiICYmIG5vZGUubmFtZSA9PT0gXCJib29zdFwiKSB7XHJcbiAgICBjb25zdCBpbm5lclNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmFyZ3NbMF0sIHNjb3BlLCBleGVjdXRlKTtcclxuICAgIGNvbnN0IGJvb3N0MiA9IGF3YWl0IGV4ZWN1dGUobm9kZS5hcmdzWzFdLCBzY29wZSk7XHJcbiAgICBpZiAoYm9vc3QyLnR5cGUgPT09IFwibnVtYmVyXCIgJiYgaW5uZXJTY29yZSA+IDApIHtcclxuICAgICAgcmV0dXJuIGlubmVyU2NvcmUgKyBib29zdDIuZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuICBzd2l0Y2ggKG5vZGUudHlwZSkge1xyXG4gICAgY2FzZSBcIk9yXCI6IHtcclxuICAgICAgY29uc3QgbGVmdFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLmxlZnQsIHNjb3BlLCBleGVjdXRlKTtcclxuICAgICAgY29uc3QgcmlnaHRTY29yZSA9IGF3YWl0IGV2YWx1YXRlU2NvcmUobm9kZS5yaWdodCwgc2NvcGUsIGV4ZWN1dGUpO1xyXG4gICAgICByZXR1cm4gbGVmdFNjb3JlICsgcmlnaHRTY29yZTtcclxuICAgIH1cclxuICAgIGNhc2UgXCJBbmRcIjoge1xyXG4gICAgICBjb25zdCBsZWZ0U2NvcmUgPSBhd2FpdCBldmFsdWF0ZVNjb3JlKG5vZGUubGVmdCwgc2NvcGUsIGV4ZWN1dGUpO1xyXG4gICAgICBjb25zdCByaWdodFNjb3JlID0gYXdhaXQgZXZhbHVhdGVTY29yZShub2RlLnJpZ2h0LCBzY29wZSwgZXhlY3V0ZSk7XHJcbiAgICAgIGlmIChsZWZ0U2NvcmUgPT09IDAgfHwgcmlnaHRTY29yZSA9PT0gMClcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgICAgcmV0dXJuIGxlZnRTY29yZSArIHJpZ2h0U2NvcmU7XHJcbiAgICB9XHJcbiAgICBkZWZhdWx0OiB7XHJcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGV4ZWN1dGUobm9kZSwgc2NvcGUpO1xyXG4gICAgICByZXR1cm4gcmVzLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIHJlcy5kYXRhID09PSB0cnVlID8gMSA6IDA7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlTWF0Y2hTY29yZShsZWZ0LCByaWdodCwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCB0ZXh0ID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XHJcbiAgY29uc3QgcGF0dGVybiA9IGF3YWl0IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcclxuICBsZXQgdG9rZW5zID0gW107XHJcbiAgbGV0IHRlcm1zID0gW107XHJcbiAgYXdhaXQgZ2F0aGVyVGV4dCh0ZXh0LCAocGFydCkgPT4ge1xyXG4gICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChtYXRjaFRva2VuaXplKHBhcnQpKTtcclxuICB9KTtcclxuICBjb25zdCBkaWRTdWNjZWVkID0gYXdhaXQgZ2F0aGVyVGV4dChwYXR0ZXJuLCAocGFydCkgPT4ge1xyXG4gICAgdGVybXMgPSB0ZXJtcy5jb25jYXQobWF0Y2hQYXR0ZXJuUmVnZXgocGFydCkpO1xyXG4gIH0pO1xyXG4gIGlmICghZGlkU3VjY2VlZCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIGlmICh0b2tlbnMubGVuZ3RoID09PSAwIHx8IHRlcm1zLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG4gIGxldCBzY29yZTIgPSAwO1xyXG4gIGZvciAoY29uc3QgcmUgb2YgdGVybXMpIHtcclxuICAgIGNvbnN0IGZyZXEgPSB0b2tlbnMucmVkdWNlKChjLCB0b2tlbikgPT4gYyArIChyZS50ZXN0KHRva2VuKSA/IDEgOiAwKSwgMCk7XHJcbiAgICBzY29yZTIgKz0gZnJlcSAqIChCTTI1ayArIDEpIC8gKGZyZXEgKyBCTTI1ayk7XHJcbiAgfVxyXG4gIHJldHVybiBzY29yZTI7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gcG9ydGFibGVUZXh0Q29udGVudCh2YWx1ZSkge1xyXG4gIGlmICh2YWx1ZS50eXBlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICByZXR1cm4gYmxvY2tUZXh0KHZhbHVlLmRhdGEpO1xyXG4gIH0gZWxzZSBpZiAodmFsdWUuaXNBcnJheSgpKSB7XHJcbiAgICBjb25zdCB0ZXh0cyA9IGF3YWl0IGFycmF5VGV4dCh2YWx1ZSk7XHJcbiAgICBpZiAodGV4dHMubGVuZ3RoID4gMCkge1xyXG4gICAgICByZXR1cm4gdGV4dHMuam9pbihcIlxcblxcblwiKTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIG51bGw7XHJcbn1cclxuYXN5bmMgZnVuY3Rpb24gYXJyYXlUZXh0KHZhbHVlLCByZXN1bHQgPSBbXSkge1xyXG4gIGZvciBhd2FpdCAoY29uc3QgYmxvY2sgb2YgdmFsdWUpIHtcclxuICAgIGlmIChibG9jay50eXBlID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIGNvbnN0IHRleHQgPSBibG9ja1RleHQoYmxvY2suZGF0YSk7XHJcbiAgICAgIGlmICh0ZXh0ICE9PSBudWxsKVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHRleHQpO1xyXG4gICAgfSBlbHNlIGlmIChibG9jay5pc0FycmF5KCkpIHtcclxuICAgICAgYXdhaXQgYXJyYXlUZXh0KGJsb2NrLCByZXN1bHQpO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIGJsb2NrVGV4dChvYmopIHtcclxuICBpZiAodHlwZW9mIG9iai5fdHlwZSAhPT0gXCJzdHJpbmdcIilcclxuICAgIHJldHVybiBudWxsO1xyXG4gIGNvbnN0IGNoaWxkcmVuID0gb2JqLmNoaWxkcmVuO1xyXG4gIGlmICghQXJyYXkuaXNBcnJheShjaGlsZHJlbikpXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XHJcbiAgICBpZiAoY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBjaGlsZC5fdHlwZSA9PT0gXCJzdHJpbmdcIiAmJiBjaGlsZC5fdHlwZSA9PT0gXCJzcGFuXCIgJiYgdHlwZW9mIGNoaWxkLnRleHQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgcmVzdWx0ICs9IGNoaWxkLnRleHQ7XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gaGFzUmVmZXJlbmNlKHZhbHVlLCBwYXRoU2V0KSB7XHJcbiAgc3dpdGNoIChnZXRUeXBlKHZhbHVlKSkge1xyXG4gICAgY2FzZSBcImFycmF5XCI6XHJcbiAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChoYXNSZWZlcmVuY2UodiwgcGF0aFNldCkpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgXCJvYmplY3RcIjpcclxuICAgICAgaWYgKHZhbHVlLl9yZWYpIHtcclxuICAgICAgICByZXR1cm4gcGF0aFNldC5oYXModmFsdWUuX3JlZik7XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCB2IG9mIE9iamVjdC52YWx1ZXModmFsdWUpKSB7XHJcbiAgICAgICAgaWYgKGhhc1JlZmVyZW5jZSh2LCBwYXRoU2V0KSkge1xyXG4gICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gIH1cclxuICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gY291bnRVVEY4KHN0cikge1xyXG4gIGxldCBjb3VudDIgPSAwO1xyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjb25zdCBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XHJcbiAgICBpZiAoY29kZSA+PSA1NTI5NiAmJiBjb2RlIDw9IDU2MzE5KSB7XHJcbiAgICAgIGNvbnRpbnVlO1xyXG4gICAgfVxyXG4gICAgY291bnQyKys7XHJcbiAgfVxyXG4gIHJldHVybiBjb3VudDI7XHJcbn1cclxuY29uc3QgZ2xvYmFsID0ge307XHJcbmdsb2JhbC5jb2FsZXNjZSA9IGFzeW5jIGZ1bmN0aW9uIGNvYWxlc2NlKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xyXG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZywgc2NvcGUpO1xyXG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwibnVsbFwiKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbn07XHJcbmdsb2JhbC5jb3VudCA9IGFzeW5jIGZ1bmN0aW9uIGNvdW50KGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcclxuICBpZiAoIWlubmVyLmlzQXJyYXkoKSkge1xyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfVxyXG4gIGxldCBudW0gPSAwO1xyXG4gIGZvciBhd2FpdCAoY29uc3QgXyBvZiBpbm5lcikge1xyXG4gICAgbnVtKys7XHJcbiAgfVxyXG4gIHJldHVybiBmcm9tTnVtYmVyKG51bSk7XHJcbn07XHJcbmdsb2JhbC5jb3VudC5hcml0eSA9IDE7XHJcbmdsb2JhbC5kYXRlVGltZSA9IGFzeW5jIGZ1bmN0aW9uIGRhdGVUaW1lKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgY29uc3QgdmFsID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XHJcbiAgaWYgKHZhbC50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcclxuICAgIHJldHVybiB2YWw7XHJcbiAgfVxyXG4gIGlmICh2YWwudHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfVxyXG4gIHJldHVybiBEYXRlVGltZS5wYXJzZVRvVmFsdWUodmFsLmRhdGEpO1xyXG59O1xyXG5nbG9iYWwuZGF0ZVRpbWUuYXJpdHkgPSAxO1xyXG5nbG9iYWwuZGVmaW5lZCA9IGFzeW5jIGZ1bmN0aW9uIGRlZmluZWQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCBpbm5lciA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xyXG4gIHJldHVybiBpbm5lci50eXBlID09PSBcIm51bGxcIiA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcclxufTtcclxuZ2xvYmFsLmRlZmluZWQuYXJpdHkgPSAxO1xyXG5nbG9iYWwuaWRlbnRpdHkgPSBhc3luYyBmdW5jdGlvbiBpZGVudGl0eShhcmdzLCBzY29wZSkge1xyXG4gIHJldHVybiBmcm9tU3RyaW5nKHNjb3BlLmNvbnRleHQuaWRlbnRpdHkpO1xyXG59O1xyXG5nbG9iYWwuaWRlbnRpdHkuYXJpdHkgPSAwO1xyXG5nbG9iYWwubGVuZ3RoID0gYXN5bmMgZnVuY3Rpb24gbGVuZ3RoKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgY29uc3QgaW5uZXIgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcclxuICBpZiAoaW5uZXIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgcmV0dXJuIGZyb21OdW1iZXIoY291bnRVVEY4KGlubmVyLmRhdGEpKTtcclxuICB9XHJcbiAgaWYgKGlubmVyLmlzQXJyYXkoKSkge1xyXG4gICAgbGV0IG51bSA9IDA7XHJcbiAgICBmb3IgYXdhaXQgKGNvbnN0IF8gb2YgaW5uZXIpIHtcclxuICAgICAgbnVtKys7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnJvbU51bWJlcihudW0pO1xyXG4gIH1cclxuICByZXR1cm4gTlVMTF9WQUxVRTtcclxufTtcclxuZ2xvYmFsLmxlbmd0aC5hcml0eSA9IDE7XHJcbmdsb2JhbC5wYXRoID0gYXN5bmMgZnVuY3Rpb24gcGF0aChhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGNvbnN0IGlubmVyID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XHJcbiAgaWYgKGlubmVyLnR5cGUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH1cclxuICByZXR1cm4gZnJvbVBhdGgobmV3IFBhdGgoaW5uZXIuZGF0YSkpO1xyXG59O1xyXG5nbG9iYWwucGF0aC5hcml0eSA9IDE7XHJcbmdsb2JhbC5zdHJpbmcgPSBhc3luYyBmdW5jdGlvbiBzdHJpbmcoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xyXG4gIHN3aXRjaCAodmFsdWUudHlwZSkge1xyXG4gICAgY2FzZSBcIm51bWJlclwiOlxyXG4gICAgY2FzZSBcInN0cmluZ1wiOlxyXG4gICAgY2FzZSBcImJvb2xlYW5cIjpcclxuICAgIGNhc2UgXCJkYXRldGltZVwiOlxyXG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhgJHt2YWx1ZS5kYXRhfWApO1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfVxyXG59O1xyXG5nbG9iYWwuc3RyaW5nLmFyaXR5ID0gMTtcclxuZ2xvYmFsLnJlZmVyZW5jZXMgPSBhc3luYyBmdW5jdGlvbiByZWZlcmVuY2VzKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgY29uc3QgcGF0aFNldCA9IG5ldyBTZXQoKTtcclxuICBmb3IgKGNvbnN0IGFyZyBvZiBhcmdzKSB7XHJcbiAgICBjb25zdCBwYXRoMiA9IGF3YWl0IGV4ZWN1dGUoYXJnLCBzY29wZSk7XHJcbiAgICBpZiAocGF0aDIudHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICBwYXRoU2V0LmFkZChwYXRoMi5kYXRhKTtcclxuICAgIH0gZWxzZSBpZiAocGF0aDIuaXNBcnJheSgpKSB7XHJcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBwYXRoMikge1xyXG4gICAgICAgIGlmIChlbGVtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgIHBhdGhTZXQuYWRkKGVsZW0uZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGlmIChwYXRoU2V0LnNpemUgPT09IDApIHtcclxuICAgIHJldHVybiBGQUxTRV9WQUxVRTtcclxuICB9XHJcbiAgY29uc3Qgc2NvcGVWYWx1ZSA9IGF3YWl0IHNjb3BlLnZhbHVlLmdldCgpO1xyXG4gIHJldHVybiBoYXNSZWZlcmVuY2Uoc2NvcGVWYWx1ZSwgcGF0aFNldCkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XHJcbn07XHJcbmdsb2JhbC5yZWZlcmVuY2VzLmFyaXR5ID0gKGMpID0+IGMgPj0gMTtcclxuZ2xvYmFsLnJvdW5kID0gYXN5bmMgZnVuY3Rpb24gcm91bmQoYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xyXG4gIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9XHJcbiAgY29uc3QgbnVtID0gdmFsdWUuZGF0YTtcclxuICBsZXQgcHJlYyA9IDA7XHJcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XHJcbiAgICBjb25zdCBwcmVjVmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMV0sIHNjb3BlKTtcclxuICAgIGlmIChwcmVjVmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIiB8fCBwcmVjVmFsdWUuZGF0YSA8IDAgfHwgIU51bWJlci5pc0ludGVnZXIocHJlY1ZhbHVlLmRhdGEpKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgcHJlYyA9IHByZWNWYWx1ZS5kYXRhO1xyXG4gIH1cclxuICBpZiAocHJlYyA9PT0gMCkge1xyXG4gICAgaWYgKG51bSA8IDApIHtcclxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLU1hdGgucm91bmQoLW51bSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZyb21OdW1iZXIoTWF0aC5yb3VuZChudW0pKTtcclxuICB9XHJcbiAgcmV0dXJuIGZyb21OdW1iZXIoTnVtYmVyKG51bS50b0ZpeGVkKHByZWMpKSk7XHJcbn07XHJcbmdsb2JhbC5yb3VuZC5hcml0eSA9IChjb3VudDIpID0+IGNvdW50MiA+PSAxICYmIGNvdW50MiA8PSAyO1xyXG5nbG9iYWwubm93ID0gYXN5bmMgZnVuY3Rpb24gbm93KGFyZ3MsIHNjb3BlKSB7XHJcbiAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC50aW1lc3RhbXAudG9JU09TdHJpbmcoKSk7XHJcbn07XHJcbmdsb2JhbC5ub3cuYXJpdHkgPSAwO1xyXG5nbG9iYWwuYm9vc3QgPSBhc3luYyBmdW5jdGlvbiBib29zdCgpIHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV4cGVjdGVkIGJvb3N0IGNhbGxcIik7XHJcbn07XHJcbmdsb2JhbC5ib29zdC5hcml0eSA9IDI7XHJcbmNvbnN0IHN0cmluZzIgPSB7fTtcclxuc3RyaW5nMi5sb3dlciA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGFyZ3NbMF0sIHNjb3BlKTtcclxuICBpZiAodmFsdWUudHlwZSAhPT0gXCJzdHJpbmdcIikge1xyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfVxyXG4gIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLmRhdGEudG9Mb3dlckNhc2UoKSk7XHJcbn07XHJcbnN0cmluZzIubG93ZXIuYXJpdHkgPSAxO1xyXG5zdHJpbmcyLnVwcGVyID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXJnc1swXSwgc2NvcGUpO1xyXG4gIGlmICh2YWx1ZS50eXBlICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9XHJcbiAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUuZGF0YS50b1VwcGVyQ2FzZSgpKTtcclxufTtcclxuc3RyaW5nMi51cHBlci5hcml0eSA9IDE7XHJcbmdsb2JhbC5sb3dlciA9IHN0cmluZzIubG93ZXI7XHJcbmdsb2JhbC51cHBlciA9IHN0cmluZzIudXBwZXI7XHJcbmNvbnN0IHB0ID0ge307XHJcbnB0LnRleHQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhcmdzWzBdLCBzY29wZSk7XHJcbiAgY29uc3QgdGV4dCA9IGF3YWl0IHBvcnRhYmxlVGV4dENvbnRlbnQodmFsdWUpO1xyXG4gIGlmICh0ZXh0ID09PSBudWxsKSB7XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9XHJcbiAgcmV0dXJuIGZyb21TdHJpbmcodGV4dCk7XHJcbn07XHJcbnB0LnRleHQuYXJpdHkgPSAxO1xyXG5jb25zdCBzYW5pdHkgPSB7fTtcclxuc2FuaXR5LnByb2plY3RJZCA9IGFzeW5jIGZ1bmN0aW9uKGFyZ3MsIHNjb3BlKSB7XHJcbiAgaWYgKHNjb3BlLmNvbnRleHQuc2FuaXR5KSB7XHJcbiAgICByZXR1cm4gZnJvbVN0cmluZyhzY29wZS5jb250ZXh0LnNhbml0eS5wcm9qZWN0SWQpO1xyXG4gIH1cclxuICByZXR1cm4gTlVMTF9WQUxVRTtcclxufTtcclxuc2FuaXR5LmRhdGFzZXQgPSBhc3luYyBmdW5jdGlvbihhcmdzLCBzY29wZSkge1xyXG4gIGlmIChzY29wZS5jb250ZXh0LnNhbml0eSkge1xyXG4gICAgcmV0dXJuIGZyb21TdHJpbmcoc2NvcGUuY29udGV4dC5zYW5pdHkuZGF0YXNldCk7XHJcbiAgfVxyXG4gIHJldHVybiBOVUxMX1ZBTFVFO1xyXG59O1xyXG5jb25zdCBwaXBlRnVuY3Rpb25zID0ge307XHJcbnBpcGVGdW5jdGlvbnMub3JkZXIgPSBhc3luYyBmdW5jdGlvbiBvcmRlcihiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGF3YWl0IHRydWU7XHJcbiAgaWYgKCFiYXNlLmlzQXJyYXkoKSkge1xyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfVxyXG4gIGNvbnN0IG1hcHBlcnMgPSBbXTtcclxuICBjb25zdCBkaXJlY3Rpb25zID0gW107XHJcbiAgbGV0IG4gPSAwO1xyXG4gIGZvciAobGV0IG1hcHBlciBvZiBhcmdzKSB7XHJcbiAgICBsZXQgZGlyZWN0aW9uID0gXCJhc2NcIjtcclxuICAgIGlmIChtYXBwZXIudHlwZSA9PT0gXCJEZXNjXCIpIHtcclxuICAgICAgZGlyZWN0aW9uID0gXCJkZXNjXCI7XHJcbiAgICAgIG1hcHBlciA9IG1hcHBlci5iYXNlO1xyXG4gICAgfSBlbHNlIGlmIChtYXBwZXIudHlwZSA9PT0gXCJBc2NcIikge1xyXG4gICAgICBtYXBwZXIgPSBtYXBwZXIuYmFzZTtcclxuICAgIH1cclxuICAgIG1hcHBlcnMucHVzaChtYXBwZXIpO1xyXG4gICAgZGlyZWN0aW9ucy5wdXNoKGRpcmVjdGlvbik7XHJcbiAgICBuKys7XHJcbiAgfVxyXG4gIGNvbnN0IGF1eCA9IFtdO1xyXG4gIGxldCBpZHggPSAwO1xyXG4gIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2YgYmFzZSkge1xyXG4gICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVOZXN0ZWQodmFsdWUpO1xyXG4gICAgY29uc3QgdHVwbGUgPSBbYXdhaXQgdmFsdWUuZ2V0KCksIGlkeF07XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBleGVjdXRlKG1hcHBlcnNbaV0sIG5ld1Njb3BlKTtcclxuICAgICAgdHVwbGUucHVzaChhd2FpdCByZXN1bHQuZ2V0KCkpO1xyXG4gICAgfVxyXG4gICAgYXV4LnB1c2godHVwbGUpO1xyXG4gICAgaWR4Kys7XHJcbiAgfVxyXG4gIGF1eC5zb3J0KChhVHVwbGUsIGJUdXBsZSkgPT4ge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgbGV0IGMgPSB0b3RhbENvbXBhcmUoYVR1cGxlW2kgKyAyXSwgYlR1cGxlW2kgKyAyXSk7XHJcbiAgICAgIGlmIChkaXJlY3Rpb25zW2ldID09PSBcImRlc2NcIikge1xyXG4gICAgICAgIGMgPSAtYztcclxuICAgICAgfVxyXG4gICAgICBpZiAoYyAhPT0gMCkge1xyXG4gICAgICAgIHJldHVybiBjO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYVR1cGxlWzFdIC0gYlR1cGxlWzFdO1xyXG4gIH0pO1xyXG4gIHJldHVybiBmcm9tSlMoYXV4Lm1hcCgodikgPT4gdlswXSkpO1xyXG59O1xyXG5waXBlRnVuY3Rpb25zLm9yZGVyLmFyaXR5ID0gKGNvdW50MikgPT4gY291bnQyID49IDE7XHJcbnBpcGVGdW5jdGlvbnMuc2NvcmUgPSBhc3luYyBmdW5jdGlvbiBzY29yZShiYXNlLCBhcmdzLCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gIGlmICghYmFzZS5pc0FycmF5KCkpXHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICBjb25zdCB1bmtub3duID0gW107XHJcbiAgY29uc3Qgc2NvcmVkID0gW107XHJcbiAgZm9yIGF3YWl0IChjb25zdCB2YWx1ZSBvZiBiYXNlKSB7XHJcbiAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICB1bmtub3duLnB1c2goYXdhaXQgdmFsdWUuZ2V0KCkpO1xyXG4gICAgICBjb250aW51ZTtcclxuICAgIH1cclxuICAgIGNvbnN0IG5ld1Njb3BlID0gc2NvcGUuY3JlYXRlTmVzdGVkKHZhbHVlKTtcclxuICAgIGxldCB2YWx1ZVNjb3JlID0gdHlwZW9mIHZhbHVlLmRhdGEuX3Njb3JlID09PSBcIm51bWJlclwiID8gdmFsdWUuZGF0YS5fc2NvcmUgOiAwO1xyXG4gICAgZm9yIChjb25zdCBhcmcgb2YgYXJncykge1xyXG4gICAgICB2YWx1ZVNjb3JlICs9IGF3YWl0IGV2YWx1YXRlU2NvcmUoYXJnLCBuZXdTY29wZSwgZXhlY3V0ZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZS5kYXRhLCB7IF9zY29yZTogdmFsdWVTY29yZSB9KTtcclxuICAgIHNjb3JlZC5wdXNoKG5ld09iamVjdCk7XHJcbiAgfVxyXG4gIHNjb3JlZC5zb3J0KChhLCBiKSA9PiBiLl9zY29yZSAtIGEuX3Njb3JlKTtcclxuICByZXR1cm4gZnJvbUpTKHNjb3JlZCk7XHJcbn07XHJcbnBpcGVGdW5jdGlvbnMuc2NvcmUuYXJpdHkgPSAoY291bnQyKSA9PiBjb3VudDIgPj0gMTtcclxuY29uc3QgZGVsdGEgPSB7fTtcclxuZGVsdGEub3BlcmF0aW9uID0gYXN5bmMgZnVuY3Rpb24oYXJncywgc2NvcGUpIHtcclxuICBjb25zdCBoYXNCZWZvcmUgPSBzY29wZS5jb250ZXh0LmJlZm9yZSAhPT0gbnVsbDtcclxuICBjb25zdCBoYXNBZnRlciA9IHNjb3BlLmNvbnRleHQuYWZ0ZXIgIT09IG51bGw7XHJcbiAgaWYgKGhhc0JlZm9yZSAmJiBoYXNBZnRlcikge1xyXG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJ1cGRhdGVcIik7XHJcbiAgfVxyXG4gIGlmIChoYXNBZnRlcikge1xyXG4gICAgcmV0dXJuIGZyb21TdHJpbmcoXCJjcmVhdGVcIik7XHJcbiAgfVxyXG4gIGlmIChoYXNCZWZvcmUpIHtcclxuICAgIHJldHVybiBmcm9tU3RyaW5nKFwiZGVsZXRlXCIpO1xyXG4gIH1cclxuICByZXR1cm4gTlVMTF9WQUxVRTtcclxufTtcclxuZGVsdGEuY2hhbmdlZEFueSA9ICgpID0+IHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XHJcbn07XHJcbmRlbHRhLmNoYW5nZWRBbnkuYXJpdHkgPSAxO1xyXG5kZWx0YS5jaGFuZ2VkQW55Lm1vZGUgPSBcImRlbHRhXCI7XHJcbmRlbHRhLmNoYW5nZWRPbmx5ID0gKCkgPT4ge1xyXG4gIHRocm93IG5ldyBFcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTtcclxufTtcclxuZGVsdGEuY2hhbmdlZE9ubHkuYXJpdHkgPSAxO1xyXG5kZWx0YS5jaGFuZ2VkT25seS5tb2RlID0gXCJkZWx0YVwiO1xyXG5jb25zdCBkaWZmID0ge307XHJcbmRpZmYuY2hhbmdlZEFueSA9ICgpID0+IHtcclxuICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XHJcbn07XHJcbmRpZmYuY2hhbmdlZEFueS5hcml0eSA9IDM7XHJcbmRpZmYuY2hhbmdlZE9ubHkgPSAoKSA9PiB7XHJcbiAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xyXG59O1xyXG5kaWZmLmNoYW5nZWRPbmx5LmFyaXR5ID0gMztcclxuY29uc3QgbmFtZXNwYWNlcyA9IHtcclxuICBnbG9iYWwsXHJcbiAgc3RyaW5nOiBzdHJpbmcyLFxyXG4gIHB0LFxyXG4gIGRlbHRhLFxyXG4gIGRpZmYsXHJcbiAgc2FuaXR5XHJcbn07XHJcbmNvbnN0IFdTID0gL14oW1xcdFxcblxcdlxcZlxcciBcXHUwMDg1XFx1MDBBMF18KFxcL1xcL1teXFxuXSpcXG4pKSsvO1xyXG5jb25zdCBOVU0gPSAvXlxcZCsvO1xyXG5jb25zdCBJREVOVCA9IC9eW2EtekEtWl9dW2EtekEtWl8wLTldKi87XHJcbmNvbnN0IFBSRUNfUEFJUiA9IDE7XHJcbmNvbnN0IFBSRUNfT1IgPSAyO1xyXG5jb25zdCBQUkVDX0FORCA9IDM7XHJcbmNvbnN0IFBSRUNfQ09NUCA9IDQ7XHJcbmNvbnN0IFBSRUNfT1JERVIgPSA0O1xyXG5jb25zdCBQUkVDX0FERCA9IDY7XHJcbmNvbnN0IFBSRUNfU1VCID0gNjtcclxuY29uc3QgUFJFQ19NVUwgPSA3O1xyXG5jb25zdCBQUkVDX0RJViA9IDc7XHJcbmNvbnN0IFBSRUNfTU9EID0gNztcclxuY29uc3QgUFJFQ19QT1cgPSA4O1xyXG5jb25zdCBQUkVDX1BPUyA9IDEwO1xyXG5jb25zdCBQUkVDX05PVCA9IDEwO1xyXG5jb25zdCBQUkVDX05FRyA9IDg7XHJcbmZ1bmN0aW9uIHBhcnNlJDEoc3RyKSB7XHJcbiAgbGV0IHBvcyA9IDA7XHJcbiAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcclxuICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcclxuICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcclxuICBpZiAocG9zICE9PSBzdHIubGVuZ3RoKSB7XHJcbiAgICBpZiAocmVzdWx0LmZhaWxQb3NpdGlvbikge1xyXG4gICAgICBwb3MgPSByZXN1bHQuZmFpbFBvc2l0aW9uIC0gMTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xyXG4gIH1cclxuICBkZWxldGUgcmVzdWx0LnBvc2l0aW9uO1xyXG4gIGRlbGV0ZSByZXN1bHQuZmFpbFBvc2l0aW9uO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VFeHByKHN0ciwgcG9zLCBsZXZlbCkge1xyXG4gIGxldCBzdGFydFBvcyA9IHBvcztcclxuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcclxuICBsZXQgbWFya3M7XHJcbiAgc3dpdGNoICh0b2tlbikge1xyXG4gICAgY2FzZSBcIitcIjoge1xyXG4gICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgcG9zICsgMSksIFBSRUNfUE9TKTtcclxuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcInBvc1wiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBjYXNlIFwiLVwiOiB7XHJcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19ORUcpO1xyXG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibmVnXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGNhc2UgXCIoXCI6IHtcclxuICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIHBvcyArIDEpLCAwKTtcclxuICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcclxuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xyXG4gICAgICAgIGNhc2UgXCIsXCI6IHtcclxuICAgICAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJ0dXBsZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcclxuICAgICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIHJocyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XHJcbiAgICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJocy5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIilcIilcclxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgICAgICAgICBwb3MrKztcclxuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInR1cGxlX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCIpXCI6IHtcclxuICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImdyb3VwXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBjYXNlIFwiIVwiOiB7XHJcbiAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBwb3MgKyAxKSwgUFJFQ19OT1QpO1xyXG4gICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwibm90XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XS5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGNhc2UgXCJ7XCI6IHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcclxuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgbWFya3MgPSByZXN1bHQubWFya3M7XHJcbiAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBjYXNlIFwiW1wiOlxyXG4gICAgICBtYXJrcyA9IFt7IG5hbWU6IFwiYXJyYXlcIiwgcG9zaXRpb246IHBvcyB9XTtcclxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XHJcbiAgICAgIGlmIChzdHJbcG9zXSAhPT0gXCJdXCIpIHtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgaWYgKHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSBcIi4uLlwiKSB7XHJcbiAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcImFycmF5X3NwbGF0XCIsIHBvc2l0aW9uOiBwb3MgfSk7XHJcbiAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IHJlcyA9IHBhcnNlRXhwcihzdHIsIHBvcywgMCk7XHJcbiAgICAgICAgICBpZiAocmVzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlcy5tYXJrcyk7XHJcbiAgICAgICAgICBwb3MgPSByZXMucG9zaXRpb247XHJcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xyXG4gICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIixcIilcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcclxuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJdXCIpXHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSB7XHJcbiAgICAgICAgcG9zKys7XHJcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiYXJyYXlfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiJ1wiOlxyXG4gICAgY2FzZSAnXCInOiB7XHJcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZVN0cmluZyhzdHIsIHBvcyk7XHJcbiAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICAgIG1hcmtzID0gcmVzdWx0Lm1hcmtzO1xyXG4gICAgICBwb3MgPSByZXN1bHQucG9zaXRpb247XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgY2FzZSBcIl5cIjoge1xyXG4gICAgICBwb3MrKztcclxuICAgICAgbWFya3MgPSBbXTtcclxuICAgICAgd2hpbGUgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiXlwiKSB7XHJcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGJscGFyZW50XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICBwb3MgKz0gMjtcclxuICAgICAgfVxyXG4gICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJwYXJlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGNhc2UgXCJAXCI6XHJcbiAgICAgIG1hcmtzID0gW3sgbmFtZTogXCJ0aGlzXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9XTtcclxuICAgICAgcG9zKys7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgY2FzZSBcIipcIjpcclxuICAgICAgbWFya3MgPSBbeyBuYW1lOiBcImV2ZXJ5dGhpbmdcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xyXG4gICAgICBwb3MrKztcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIFwiJFwiOiB7XHJcbiAgICAgIGxldCBpZGVudExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBJREVOVCk7XHJcbiAgICAgIGlmIChpZGVudExlbikge1xyXG4gICAgICAgIHBvcyArPSAxICsgaWRlbnRMZW47XHJcbiAgICAgICAgbWFya3MgPSBbXHJcbiAgICAgICAgICB7IG5hbWU6IFwicGFyYW1cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXHJcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zICsgMSB9LFxyXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cclxuICAgICAgICBdO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgZGVmYXVsdDoge1xyXG4gICAgICBsZXQgbnVtTGVuID0gcGFyc2VSZWdleChzdHIsIHBvcywgTlVNKTtcclxuICAgICAgaWYgKG51bUxlbikge1xyXG4gICAgICAgIHBvcyArPSBudW1MZW47XHJcbiAgICAgICAgbGV0IG5hbWUgPSBcImludGVnZXJcIjtcclxuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiLlwiKSB7XHJcbiAgICAgICAgICBsZXQgZnJhY0xlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MgKyAxLCBOVU0pO1xyXG4gICAgICAgICAgaWYgKGZyYWNMZW4pIHtcclxuICAgICAgICAgICAgbmFtZSA9IFwiZmxvYXRcIjtcclxuICAgICAgICAgICAgcG9zICs9IDEgKyBmcmFjTGVuO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiZVwiIHx8IHN0cltwb3NdID09PSBcIkVcIikge1xyXG4gICAgICAgICAgbmFtZSA9IFwic2NpXCI7XHJcbiAgICAgICAgICBwb3MrKztcclxuICAgICAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCIrXCIgfHwgc3RyW3Bvc10gPT09IFwiLVwiKSB7XHJcbiAgICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgbGV0IGV4cExlbiA9IHBhcnNlUmVnZXgoc3RyLCBwb3MsIE5VTSk7XHJcbiAgICAgICAgICBpZiAoIWV4cExlbilcclxuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgICAgICAgICBwb3MgKz0gZXhwTGVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtYXJrcyA9IFtcclxuICAgICAgICAgIHsgbmFtZSwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXHJcbiAgICAgICAgICB7IG5hbWU6IG5hbWUgKyBcIl9lbmRcIiwgcG9zaXRpb246IHBvcyB9XHJcbiAgICAgICAgXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XHJcbiAgICAgIGlmIChpZGVudExlbikge1xyXG4gICAgICAgIHBvcyArPSBpZGVudExlbjtcclxuICAgICAgICBzd2l0Y2ggKHN0cltwb3NdKSB7XHJcbiAgICAgICAgICBjYXNlIFwiOlwiOlxyXG4gICAgICAgICAgY2FzZSBcIihcIjoge1xyXG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VGdW5jQ2FsbChzdHIsIHN0YXJ0UG9zLCBwb3MpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICBtYXJrcyA9IHJlc3VsdC5tYXJrcztcclxuICAgICAgICAgICAgcG9zID0gcmVzdWx0LnBvc2l0aW9uO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgbWFya3MgPSBbXHJcbiAgICAgICAgICAgICAgeyBuYW1lOiBcInRoaXNfYXR0clwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSxcclxuICAgICAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sXHJcbiAgICAgICAgICAgICAgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH1cclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbiAgaWYgKCFtYXJrcykge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgfVxyXG4gIGxldCBsaHNMZXZlbCA9IDEyO1xyXG4gIGxldCB0cmF2O1xyXG4gIGxvb3A6XHJcbiAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICBsZXQgaW5uZXJQb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xyXG4gICAgICBpZiAoaW5uZXJQb3MgPT09IHN0ci5sZW5ndGgpIHtcclxuICAgICAgICBwb3MgPSBpbm5lclBvcztcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBpbm5lclBvcyk7XHJcbiAgICAgIGlmICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XHJcbiAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwidHJhdmVyc2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgIHdoaWxlICh0cmF2LnR5cGUgPT09IFwic3VjY2Vzc1wiKSB7XHJcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh0cmF2Lm1hcmtzKTtcclxuICAgICAgICAgIHBvcyA9IHRyYXYucG9zaXRpb247XHJcbiAgICAgICAgICB0cmF2ID0gcGFyc2VUcmF2ZXJzYWwoc3RyLCBza2lwV1Moc3RyLCBwb3MpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidHJhdmVyc2FsX2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xyXG4gICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICB9XHJcbiAgICAgIGxldCB0b2tlbjIgPSBzdHJbaW5uZXJQb3NdO1xyXG4gICAgICBzd2l0Y2ggKHRva2VuMikge1xyXG4gICAgICAgIGNhc2UgXCI9XCI6IHtcclxuICAgICAgICAgIGxldCBuZXh0VG9rZW4gPSBzdHJbaW5uZXJQb3MgKyAxXTtcclxuICAgICAgICAgIHN3aXRjaCAobmV4dFRva2VuKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCI+XCI6IHtcclxuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BBSVIgfHwgbGhzTGV2ZWwgPD0gUFJFQ19QQUlSKVxyXG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19QQUlSKTtcclxuICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJwYWlyXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1BBSVI7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcIj1cIjoge1xyXG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXHJcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCA1KTtcclxuICAgICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KTtcclxuICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICBsaHNMZXZlbCA9IFBSRUNfQ09NUDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIitcIjoge1xyXG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19BREQgfHwgbGhzTGV2ZWwgPCBQUkVDX0FERClcclxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX0FERCArIDEpO1xyXG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYWRkXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BREQ7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIi1cIjoge1xyXG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19TVUIgfHwgbGhzTGV2ZWwgPCBQUkVDX1NVQilcclxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpLCBQUkVDX1NVQiArIDEpO1xyXG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwic3ViXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19TVUI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIipcIjoge1xyXG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcIipcIikge1xyXG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX1BPVyB8fCBsaHNMZXZlbCA8PSBQUkVDX1BPVylcclxuICAgICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgICBsZXQgcmhzMiA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMiksIFBSRUNfUE9XKTtcclxuICAgICAgICAgICAgaWYgKHJoczIudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICAgIHJldHVybiByaHMyO1xyXG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMyLm1hcmtzKTtcclxuICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicG93XCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgICAgcG9zID0gcmhzMi5wb3NpdGlvbjtcclxuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX1BPVztcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX01VTCB8fCBsaHNMZXZlbCA8IFBSRUNfTVVMKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTVVMICsgMSk7XHJcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJtdWxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01VTDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiL1wiOiB7XHJcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0RJViB8fCBsaHNMZXZlbCA8IFBSRUNfRElWKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfRElWICsgMSk7XHJcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJkaXZcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0RJVjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiJVwiOiB7XHJcbiAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX01PRCB8fCBsaHNMZXZlbCA8IFBSRUNfTU9EKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgbGV0IHJocyA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIGlubmVyUG9zICsgMSksIFBSRUNfTU9EICsgMSk7XHJcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJocy5tYXJrcyk7XHJcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJtb2RcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX01PRDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiPFwiOlxyXG4gICAgICAgIGNhc2UgXCI+XCI6IHtcclxuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBsZXQgbmV4dFBvcyA9IGlubmVyUG9zICsgMTtcclxuICAgICAgICAgIGlmIChzdHJbbmV4dFBvc10gPT09IFwiPVwiKSB7XHJcbiAgICAgICAgICAgIG5leHRQb3MrKztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBuZXh0UG9zKSwgUFJFQ19DT01QICsgMSk7XHJcbiAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgcmV0dXJuIHJocztcclxuICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IG5leHRQb3MgfSk7XHJcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgcG9zID0gcmhzLnBvc2l0aW9uO1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcInxcIjoge1xyXG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdID09PSBcInxcIikge1xyXG4gICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX09SIHx8IGxoc0xldmVsIDwgUFJFQ19PUilcclxuICAgICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyAyKSwgUFJFQ19PUiArIDEpO1xyXG4gICAgICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJvclwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGxldmVsID4gMTEgfHwgbGhzTGV2ZWwgPCAxMSlcclxuICAgICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgICBsZXQgaWRlbnRQb3MgPSBza2lwV1Moc3RyLCBpbm5lclBvcyArIDEpO1xyXG4gICAgICAgICAgICBsZXQgaWRlbnRMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgaWRlbnRQb3MsIElERU5UKTtcclxuICAgICAgICAgICAgaWYgKCFpZGVudExlbilcclxuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9O1xyXG4gICAgICAgICAgICBwb3MgPSBpZGVudFBvcyArIGlkZW50TGVuO1xyXG4gICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiKFwiIHx8IHN0cltwb3NdID09PSBcIjpcIikge1xyXG4gICAgICAgICAgICAgIGxldCByZXN1bHQgPSBwYXJzZUZ1bmNDYWxsKHN0ciwgaWRlbnRQb3MsIHBvcyk7XHJcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XHJcbiAgICAgICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwicGlwZWNhbGxcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgICAgIHBvcyA9IHJlc3VsdC5wb3NpdGlvbjtcclxuICAgICAgICAgICAgICBsaHNMZXZlbCA9IDExO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIiZcIjoge1xyXG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9IFwiJlwiKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19BTkQgfHwgbGhzTGV2ZWwgPCBQUkVDX0FORClcclxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0FORCArIDEpO1xyXG4gICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyaHMubWFya3MpO1xyXG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiYW5kXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19BTkQ7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIiFcIjoge1xyXG4gICAgICAgICAgaWYgKHN0cltpbm5lclBvcyArIDFdICE9PSBcIj1cIilcclxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8IFBSRUNfQ09NUClcclxuICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBza2lwV1Moc3RyLCBpbm5lclBvcyArIDIpLCBQUkVDX0NPTVAgKyAxKTtcclxuICAgICAgICAgIGlmIChyaHMudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICAgICAgbWFya3MudW5zaGlmdCh7IG5hbWU6IFwiY29tcFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvcFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgfSwgeyBuYW1lOiBcIm9wX2VuZFwiLCBwb3NpdGlvbjogaW5uZXJQb3MgKyAyIH0pO1xyXG4gICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgICAgIHBvcyA9IHJocy5wb3NpdGlvbjtcclxuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19DT01QO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgXCJkXCI6IHtcclxuICAgICAgICAgIGlmIChzdHIuc2xpY2UoaW5uZXJQb3MsIGlubmVyUG9zICsgNCkgIT09IFwiZGVzY1wiKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpXHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJkZXNjXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9KTtcclxuICAgICAgICAgIHBvcyA9IGlubmVyUG9zICsgNDtcclxuICAgICAgICAgIGxoc0xldmVsID0gUFJFQ19PUkRFUjtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiYVwiOiB7XHJcbiAgICAgICAgICBpZiAoc3RyLnNsaWNlKGlubmVyUG9zLCBpbm5lclBvcyArIDMpICE9PSBcImFzY1wiKVxyXG4gICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgaWYgKGxldmVsID4gUFJFQ19PUkRFUiB8fCBsaHNMZXZlbCA8IFBSRUNfT1JERVIpXHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJhc2NcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgcG9zID0gaW5uZXJQb3MgKyAzO1xyXG4gICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX09SREVSO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgIGxldCBpZGVudCA9IHBhcnNlUmVnZXhTdHIoc3RyLCBpbm5lclBvcywgSURFTlQpO1xyXG4gICAgICAgICAgc3dpdGNoIChpZGVudCkge1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5cIjoge1xyXG4gICAgICAgICAgICAgIGlmIChsZXZlbCA+IFBSRUNfQ09NUCB8fCBsaHNMZXZlbCA8PSBQUkVDX0NPTVApXHJcbiAgICAgICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIGlubmVyUG9zICsgMik7XHJcbiAgICAgICAgICAgICAgbGV0IGlzR3JvdXAgPSBmYWxzZTtcclxuICAgICAgICAgICAgICBpZiAoc3RyW3Bvc10gPT09IFwiKFwiKSB7XHJcbiAgICAgICAgICAgICAgICBpc0dyb3VwID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBsZXQgcmFuZ2VQb3MgPSBwb3M7XHJcbiAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlRXhwcihzdHIsIHBvcywgUFJFQ19DT01QICsgMSk7XHJcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHJlc3VsdC5wb3NpdGlvbik7XHJcbiAgICAgICAgICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XHJcbiAgICAgICAgICAgICAgICBsZXQgdHlwZSA9IFwiaW5jX3JhbmdlXCI7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3RyW3BvcyArIDJdID09PSBcIi5cIikge1xyXG4gICAgICAgICAgICAgICAgICB0eXBlID0gXCJleGNfcmFuZ2VcIjtcclxuICAgICAgICAgICAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMyk7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxldCByaHMgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIFBSRUNfQ09NUCArIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgICAgICAgICBtYXJrcy51bnNoaWZ0KHsgbmFtZTogXCJpbl9yYW5nZVwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdCh7IG5hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvcyB9LCByZXN1bHQubWFya3MsIHJocy5tYXJrcyk7XHJcbiAgICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwib3BcIiwgcG9zaXRpb246IGlubmVyUG9zIH0sIHsgbmFtZTogXCJvcF9lbmRcIiwgcG9zaXRpb246IGlubmVyUG9zICsgMiB9KTtcclxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHJlc3VsdC5tYXJrcyk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGlmIChpc0dyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN0cltwb3NdICE9PSBcIilcIilcclxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgICAgICAgICAgICAgICBwb3MrKztcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSBQUkVDX0NPTVA7XHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcIm1hdGNoXCI6IHtcclxuICAgICAgICAgICAgICBpZiAobGV2ZWwgPiBQUkVDX0NPTVAgfHwgbGhzTGV2ZWwgPD0gUFJFQ19DT01QKVxyXG4gICAgICAgICAgICAgICAgYnJlYWsgbG9vcDtcclxuICAgICAgICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgc2tpcFdTKHN0ciwgaW5uZXJQb3MgKyA1KSwgUFJFQ19DT01QICsgMSk7XHJcbiAgICAgICAgICAgICAgaWYgKHJocy50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgICAgICAgICAgIG1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcImNvbXBcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcIm9wXCIsIHBvc2l0aW9uOiBpbm5lclBvcyB9LCB7IG5hbWU6IFwib3BfZW5kXCIsIHBvc2l0aW9uOiBpbm5lclBvcyArIDUgfSk7XHJcbiAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQocmhzLm1hcmtzKTtcclxuICAgICAgICAgICAgICBwb3MgPSByaHMucG9zaXRpb247XHJcbiAgICAgICAgICAgICAgbGhzTGV2ZWwgPSA0O1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICBicmVhayBsb29wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgbGV0IGZhaWxQb3NpdGlvbiA9ICh0cmF2ID09IG51bGwgPyB2b2lkIDAgOiB0cmF2LnR5cGUpID09PSBcImVycm9yXCIgJiYgdHJhdi5wb3NpdGlvbjtcclxuICByZXR1cm4geyB0eXBlOiBcInN1Y2Nlc3NcIiwgbWFya3MsIHBvc2l0aW9uOiBwb3MsIGZhaWxQb3NpdGlvbiB9O1xyXG59XHJcbmZ1bmN0aW9uIHBhcnNlVHJhdmVyc2FsKHN0ciwgcG9zKSB7XHJcbiAgbGV0IHN0YXJ0UG9zID0gcG9zO1xyXG4gIHN3aXRjaCAoc3RyW3Bvc10pIHtcclxuICAgIGNhc2UgXCIuXCI6IHtcclxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XHJcbiAgICAgIGxldCBpZGVudFN0YXJ0ID0gcG9zO1xyXG4gICAgICBsZXQgaWRlbnRMZW4yID0gcGFyc2VSZWdleChzdHIsIHBvcywgSURFTlQpO1xyXG4gICAgICBpZiAoIWlkZW50TGVuMilcclxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgcG9zICs9IGlkZW50TGVuMjtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcclxuICAgICAgICBtYXJrczogW1xyXG4gICAgICAgICAgeyBuYW1lOiBcImF0dHJfYWNjZXNzXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxyXG4gICAgICAgICAgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFN0YXJ0IH0sXHJcbiAgICAgICAgICB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcG9zaXRpb246IHBvc1xyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgY2FzZSBcIi1cIjpcclxuICAgICAgaWYgKHN0cltwb3MgKyAxXSAhPT0gXCI+XCIpXHJcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgICAgIGxldCBtYXJrcyA9IFt7IG5hbWU6IFwiZGVyZWZcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH1dO1xyXG4gICAgICBwb3MgKz0gMjtcclxuICAgICAgbGV0IGlkZW50UG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcclxuICAgICAgbGV0IGlkZW50TGVuID0gcGFyc2VSZWdleChzdHIsIGlkZW50UG9zLCBJREVOVCk7XHJcbiAgICAgIGlmIChpZGVudExlbikge1xyXG4gICAgICAgIHBvcyA9IGlkZW50UG9zICsgaWRlbnRMZW47XHJcbiAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwiZGVyZWZfYXR0clwiLCBwb3NpdGlvbjogaWRlbnRQb3MgfSwgeyBuYW1lOiBcImlkZW50XCIsIHBvc2l0aW9uOiBpZGVudFBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcclxuICAgICAgICBtYXJrcyxcclxuICAgICAgICBwb3NpdGlvbjogcG9zXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiW1wiOiB7XHJcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xyXG4gICAgICBpZiAoc3RyW3Bvc10gPT09IFwiXVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxyXG4gICAgICAgICAgbWFya3M6IFt7IG5hbWU6IFwiYXJyYXlfcG9zdGZpeFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0sXHJcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHJhbmdlUG9zID0gcG9zO1xyXG4gICAgICBsZXQgcmVzdWx0ID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcclxuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmVzdWx0LnBvc2l0aW9uKTtcclxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIi5cIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiLlwiKSB7XHJcbiAgICAgICAgbGV0IHR5cGUgPSBcImluY19yYW5nZVwiO1xyXG4gICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwiLlwiKSB7XHJcbiAgICAgICAgICB0eXBlID0gXCJleGNfcmFuZ2VcIjtcclxuICAgICAgICAgIHBvcyArPSAzO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwb3MgKz0gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcclxuICAgICAgICBsZXQgcmhzID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcclxuICAgICAgICBpZiAocmhzLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgIHJldHVybiByaHM7XHJcbiAgICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcmhzLnBvc2l0aW9uKTtcclxuICAgICAgICBpZiAoc3RyW3Bvc10gIT09IFwiXVwiKVxyXG4gICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxyXG4gICAgICAgICAgbWFya3M6IFtcclxuICAgICAgICAgICAgeyBuYW1lOiBcInNsaWNlXCIsIHBvc2l0aW9uOiBzdGFydFBvcyB9LFxyXG4gICAgICAgICAgICB7IG5hbWU6IHR5cGUsIHBvc2l0aW9uOiByYW5nZVBvcyB9XHJcbiAgICAgICAgICBdLmNvbmNhdChyZXN1bHQubWFya3MsIHJocy5tYXJrcyksXHJcbiAgICAgICAgICBwb3NpdGlvbjogcG9zICsgMVxyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHN0cltwb3NdICE9PSBcIl1cIilcclxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcclxuICAgICAgICBtYXJrczogW3sgbmFtZTogXCJzcXVhcmVfYnJhY2tldFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfV0uY29uY2F0KHJlc3VsdC5tYXJrcyksXHJcbiAgICAgICAgcG9zaXRpb246IHBvcyArIDFcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNhc2UgXCJ8XCI6IHtcclxuICAgICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XHJcbiAgICAgIGlmIChzdHJbcG9zXSA9PT0gXCJ7XCIpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VPYmplY3Qoc3RyLCBwb3MpO1xyXG4gICAgICAgIGlmIChyZXN1bHQudHlwZSA9PT0gXCJlcnJvclwiKVxyXG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgICByZXN1bHQubWFya3MudW5zaGlmdCh7IG5hbWU6IFwicHJvamVjdGlvblwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuICAgIGNhc2UgXCJ7XCI6IHtcclxuICAgICAgbGV0IHJlc3VsdCA9IHBhcnNlT2JqZWN0KHN0ciwgcG9zKTtcclxuICAgICAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgICAgcmVzdWx0Lm1hcmtzLnVuc2hpZnQoeyBuYW1lOiBcInByb2plY3Rpb25cIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZUZ1bmNDYWxsKHN0ciwgc3RhcnRQb3MsIHBvcykge1xyXG4gIGxldCBtYXJrcyA9IFtdO1xyXG4gIG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfY2FsbFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSk7XHJcbiAgaWYgKHN0cltwb3NdID09PSBcIjpcIiAmJiBzdHJbcG9zICsgMV0gPT09IFwiOlwiKSB7XHJcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJuYW1lc3BhY2VcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0pO1xyXG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHN0YXJ0UG9zIH0sIHsgbmFtZTogXCJpZGVudF9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcclxuICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDIpO1xyXG4gICAgbGV0IG5hbWVMZW4gPSBwYXJzZVJlZ2V4KHN0ciwgcG9zLCBJREVOVCk7XHJcbiAgICBpZiAoIW5hbWVMZW4pXHJcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xyXG4gICAgbWFya3MucHVzaCh7IG5hbWU6IFwiaWRlbnRcIiwgcG9zaXRpb246IHBvcyB9LCB7IG5hbWU6IFwiaWRlbnRfZW5kXCIsIHBvc2l0aW9uOiBwb3MgKyBuYW1lTGVuIH0pO1xyXG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgbmFtZUxlbik7XHJcbiAgICBpZiAoc3RyW3Bvc10gIT09IFwiKFwiKVxyXG4gICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgIHBvcysrO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJpZGVudFwiLCBwb3NpdGlvbjogc3RhcnRQb3MgfSwgeyBuYW1lOiBcImlkZW50X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xyXG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XHJcbiAgfVxyXG4gIGxldCBsYXN0UG9zID0gcG9zO1xyXG4gIGlmIChzdHJbcG9zXSAhPT0gXCIpXCIpIHtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgIGxldCByZXN1bHQgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xyXG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChyZXN1bHQubWFya3MpO1xyXG4gICAgICBsYXN0UG9zID0gcmVzdWx0LnBvc2l0aW9uO1xyXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCByZXN1bHQucG9zaXRpb24pO1xyXG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwiLFwiKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICBwb3MgPSBza2lwV1Moc3RyLCBwb3MgKyAxKTtcclxuICAgICAgaWYgKHN0cltwb3NdID09PSBcIilcIilcclxuICAgICAgICBicmVhaztcclxuICAgIH1cclxuICB9XHJcbiAgaWYgKHN0cltwb3NdICE9PSBcIilcIikge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJlcnJvclwiLCBwb3NpdGlvbjogcG9zIH07XHJcbiAgfVxyXG4gIG1hcmtzLnB1c2goeyBuYW1lOiBcImZ1bmNfYXJnc19lbmRcIiwgcG9zaXRpb246IGxhc3RQb3MgfSk7XHJcbiAgcmV0dXJuIHtcclxuICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxyXG4gICAgbWFya3MsXHJcbiAgICBwb3NpdGlvbjogcG9zICsgMVxyXG4gIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VPYmplY3Qoc3RyLCBwb3MpIHtcclxuICBsZXQgbWFya3MgPSBbeyBuYW1lOiBcIm9iamVjdFwiLCBwb3NpdGlvbjogcG9zIH1dO1xyXG4gIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDEpO1xyXG4gIHdoaWxlIChzdHJbcG9zXSAhPT0gXCJ9XCIpIHtcclxuICAgIGxldCBwYWlyUG9zID0gcG9zO1xyXG4gICAgaWYgKHN0ci5zbGljZShwb3MsIHBvcyArIDMpID09PSBcIi4uLlwiKSB7XHJcbiAgICAgIHBvcyA9IHNraXBXUyhzdHIsIHBvcyArIDMpO1xyXG4gICAgICBpZiAoc3RyW3Bvc10gIT09IFwifVwiICYmIHN0cltwb3NdICE9PSBcIixcIikge1xyXG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0ciwgcG9zLCAwKTtcclxuICAgICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgICByZXR1cm4gZXhwcjtcclxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3Rfc3BsYXRcIiwgcG9zaXRpb246IHBhaXJQb3MgfSk7XHJcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoZXhwci5tYXJrcyk7XHJcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3Rfc3BsYXRfdGhpc1wiLCBwb3NpdGlvbjogcGFpclBvcyB9KTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyLCBwb3MsIDApO1xyXG4gICAgICBpZiAoZXhwci50eXBlID09PSBcImVycm9yXCIpXHJcbiAgICAgICAgcmV0dXJuIGV4cHI7XHJcbiAgICAgIGxldCBuZXh0UG9zID0gc2tpcFdTKHN0ciwgZXhwci5wb3NpdGlvbik7XHJcbiAgICAgIGlmIChleHByLm1hcmtzWzBdLm5hbWUgPT09IFwic3RyXCIgJiYgc3RyW25leHRQb3NdID09PSBcIjpcIikge1xyXG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcnNlRXhwcihzdHIsIHNraXBXUyhzdHIsIG5leHRQb3MgKyAxKSwgMCk7XHJcbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgPT09IFwiZXJyb3JcIilcclxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfcGFpclwiLCBwb3NpdGlvbjogcGFpclBvcyB9KTtcclxuICAgICAgICBtYXJrcyA9IG1hcmtzLmNvbmNhdChleHByLm1hcmtzLCB2YWx1ZS5tYXJrcyk7XHJcbiAgICAgICAgcG9zID0gdmFsdWUucG9zaXRpb247XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQoeyBuYW1lOiBcIm9iamVjdF9leHByXCIsIHBvc2l0aW9uOiBwb3MgfSwgZXhwci5tYXJrcyk7XHJcbiAgICAgICAgcG9zID0gZXhwci5wb3NpdGlvbjtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zKTtcclxuICAgIGlmIChzdHJbcG9zXSAhPT0gXCIsXCIpXHJcbiAgICAgIGJyZWFrO1xyXG4gICAgcG9zID0gc2tpcFdTKHN0ciwgcG9zICsgMSk7XHJcbiAgfVxyXG4gIGlmIChzdHJbcG9zXSAhPT0gXCJ9XCIpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgcG9zaXRpb246IHBvcyB9O1xyXG4gIH1cclxuICBwb3MrKztcclxuICBtYXJrcy5wdXNoKHsgbmFtZTogXCJvYmplY3RfZW5kXCIsIHBvc2l0aW9uOiBwb3MgfSk7XHJcbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH07XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VTdHJpbmcoc3RyLCBwb3MpIHtcclxuICBsZXQgdG9rZW4gPSBzdHJbcG9zXTtcclxuICBwb3MgPSBwb3MgKyAxO1xyXG4gIGNvbnN0IG1hcmtzID0gW3sgbmFtZTogXCJzdHJcIiwgcG9zaXRpb246IHBvcyB9XTtcclxuICBzdHI6XHJcbiAgICBmb3IgKDsgOyBwb3MrKykge1xyXG4gICAgICBpZiAocG9zID4gc3RyLmxlbmd0aClcclxuICAgICAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHBvc2l0aW9uOiBwb3MgfTtcclxuICAgICAgc3dpdGNoIChzdHJbcG9zXSkge1xyXG4gICAgICAgIGNhc2UgdG9rZW46IHtcclxuICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInN0cl9lbmRcIiwgcG9zaXRpb246IHBvcyB9KTtcclxuICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgYnJlYWsgc3RyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XHJcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfcGF1c2VcIiwgcG9zaXRpb246IHBvcyB9KTtcclxuICAgICAgICAgIGlmIChzdHJbcG9zICsgMV0gPT09IFwidVwiKSB7XHJcbiAgICAgICAgICAgIGlmIChzdHJbcG9zICsgMl0gPT09IFwie1wiKSB7XHJcbiAgICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwidW5pY29kZV9oZXhcIiwgcG9zaXRpb246IHBvcyArIDMgfSk7XHJcbiAgICAgICAgICAgICAgcG9zID0gc3RyLmluZGV4T2YoXCJ9XCIsIHBvcyArIDMpO1xyXG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zIH0pO1xyXG4gICAgICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4XCIsIHBvc2l0aW9uOiBwb3MgKyAyIH0pO1xyXG4gICAgICAgICAgICAgIG1hcmtzLnB1c2goeyBuYW1lOiBcInVuaWNvZGVfaGV4X2VuZFwiLCBwb3NpdGlvbjogcG9zICsgNiB9KTtcclxuICAgICAgICAgICAgICBwb3MgKz0gNTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbWFya3MucHVzaCh7IG5hbWU6IFwic2luZ2xlX2VzY2FwZVwiLCBwb3NpdGlvbjogcG9zICsgMSB9KTtcclxuICAgICAgICAgICAgcG9zICs9IDE7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBtYXJrcy5wdXNoKHsgbmFtZTogXCJzdHJfc3RhcnRcIiwgcG9zaXRpb246IHBvcyArIDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgcmV0dXJuIHsgdHlwZTogXCJzdWNjZXNzXCIsIG1hcmtzLCBwb3NpdGlvbjogcG9zIH07XHJcbn1cclxuZnVuY3Rpb24gc2tpcFdTKHN0ciwgcG9zKSB7XHJcbiAgcmV0dXJuIHBvcyArIHBhcnNlUmVnZXgoc3RyLCBwb3MsIFdTKTtcclxufVxyXG5mdW5jdGlvbiBwYXJzZVJlZ2V4KHN0ciwgcG9zLCByZSkge1xyXG4gIGxldCBtID0gcmUuZXhlYyhzdHIuc2xpY2UocG9zKSk7XHJcbiAgcmV0dXJuIG0gPyBtWzBdLmxlbmd0aCA6IDA7XHJcbn1cclxuZnVuY3Rpb24gcGFyc2VSZWdleFN0cihzdHIsIHBvcywgcmUpIHtcclxuICBsZXQgbSA9IHJlLmV4ZWMoc3RyLnNsaWNlKHBvcykpO1xyXG4gIHJldHVybiBtID8gbVswXSA6IG51bGw7XHJcbn1cclxuZnVuY3Rpb24gam9pbihhLCBiKSB7XHJcbiAgcmV0dXJuIChiYXNlKSA9PiBiKGEoYmFzZSkpO1xyXG59XHJcbmZ1bmN0aW9uIG1hcChpbm5lcikge1xyXG4gIHJldHVybiAoYmFzZSkgPT4gKHsgdHlwZTogXCJNYXBcIiwgYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiBcIlRoaXNcIiB9KSB9KTtcclxufVxyXG5mdW5jdGlvbiBmbGF0TWFwKGlubmVyKSB7XHJcbiAgcmV0dXJuIChiYXNlKSA9PiAoeyB0eXBlOiBcIkZsYXRNYXBcIiwgYmFzZSwgZXhwcjogaW5uZXIoeyB0eXBlOiBcIlRoaXNcIiB9KSB9KTtcclxufVxyXG5mdW5jdGlvbiB0cmF2ZXJzZUFycmF5KGJ1aWxkLCByaWdodCkge1xyXG4gIGlmICghcmlnaHQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiYS1hXCIsXHJcbiAgICAgIGJ1aWxkXHJcbiAgICB9O1xyXG4gIH1cclxuICBzd2l0Y2ggKHJpZ2h0LnR5cGUpIHtcclxuICAgIGNhc2UgXCJhLWFcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImEtYVwiLFxyXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcclxuICAgICAgfTtcclxuICAgIGNhc2UgXCJhLWJcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImEtYlwiLFxyXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCByaWdodC5idWlsZClcclxuICAgICAgfTtcclxuICAgIGNhc2UgXCJiLWJcIjpcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICB0eXBlOiBcImEtYVwiLFxyXG4gICAgICAgIGJ1aWxkOiBqb2luKGJ1aWxkLCBtYXAocmlnaHQuYnVpbGQpKVxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBcImItYVwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYS1hXCIsXHJcbiAgICAgICAgYnVpbGQ6IGpvaW4oYnVpbGQsIGZsYXRNYXAocmlnaHQuYnVpbGQpKVxyXG4gICAgICB9O1xyXG4gICAgZGVmYXVsdDpcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHR5cGU6ICR7cmlnaHQudHlwZX1gKTtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gdHJhdmVyc2VQbGFpbihtYXBwZXIsIHJpZ2h0KSB7XHJcbiAgaWYgKCFyaWdodCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJiLWJcIixcclxuICAgICAgYnVpbGQ6IG1hcHBlclxyXG4gICAgfTtcclxuICB9XHJcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XHJcbiAgICBjYXNlIFwiYS1hXCI6XHJcbiAgICBjYXNlIFwiYi1hXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJiLWFcIixcclxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBcImEtYlwiOlxyXG4gICAgY2FzZSBcImItYlwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXHJcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcclxuICAgICAgfTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlRWxlbWVudChtYXBwZXIsIHJpZ2h0KSB7XHJcbiAgaWYgKCFyaWdodCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJhLWJcIixcclxuICAgICAgYnVpbGQ6IG1hcHBlclxyXG4gICAgfTtcclxuICB9XHJcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XHJcbiAgICBjYXNlIFwiYS1hXCI6XHJcbiAgICBjYXNlIFwiYi1hXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJhLWFcIixcclxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBcImEtYlwiOlxyXG4gICAgY2FzZSBcImItYlwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYS1iXCIsXHJcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcclxuICAgICAgfTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIHRyYXZlcnNlUHJvamVjdGlvbihtYXBwZXIsIHJpZ2h0KSB7XHJcbiAgaWYgKCFyaWdodCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJiLWJcIixcclxuICAgICAgYnVpbGQ6IG1hcHBlclxyXG4gICAgfTtcclxuICB9XHJcbiAgc3dpdGNoIChyaWdodC50eXBlKSB7XHJcbiAgICBjYXNlIFwiYS1hXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJhLWFcIixcclxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiYS1iXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJhLWJcIixcclxuICAgICAgICBidWlsZDogam9pbihtYXAobWFwcGVyKSwgcmlnaHQuYnVpbGQpXHJcbiAgICAgIH07XHJcbiAgICBjYXNlIFwiYi1hXCI6XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJiLWFcIixcclxuICAgICAgICBidWlsZDogam9pbihtYXBwZXIsIHJpZ2h0LmJ1aWxkKVxyXG4gICAgICB9O1xyXG4gICAgY2FzZSBcImItYlwiOlxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIHR5cGU6IFwiYi1iXCIsXHJcbiAgICAgICAgYnVpbGQ6IGpvaW4obWFwcGVyLCByaWdodC5idWlsZClcclxuICAgICAgfTtcclxuICAgIGRlZmF1bHQ6XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biB0eXBlOiAke3JpZ2h0LnR5cGV9YCk7XHJcbiAgfVxyXG59XHJcbmNvbnN0IGlzRXF1YWwgPSBlcXVhbGl0eTtcclxuZnVuY3Rpb24gZXF1YWxpdHkoYSwgYikge1xyXG4gIGlmIChhLnR5cGUgPT09IFwic3RyaW5nXCIgJiYgYi50eXBlID09PSBcInN0cmluZ1wiIHx8IGEudHlwZSA9PT0gXCJib29sZWFuXCIgJiYgYi50eXBlID09PSBcImJvb2xlYW5cIiB8fCBhLnR5cGUgPT09IFwibnVsbFwiICYmIGIudHlwZSA9PT0gXCJudWxsXCIgfHwgYS50eXBlID09PSBcIm51bWJlclwiICYmIGIudHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgcmV0dXJuIGEuZGF0YSA9PT0gYi5kYXRhO1xyXG4gIH1cclxuICBpZiAoYS50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgYi50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcclxuICAgIHJldHVybiBhLmRhdGEuZXF1YWxzKGIuZGF0YSk7XHJcbiAgfVxyXG4gIHJldHVybiBmYWxzZTtcclxufVxyXG5jb25zdCBvcGVyYXRvcnMgPSB7XHJcbiAgXCI9PVwiOiBmdW5jdGlvbiBlcShsZWZ0LCByaWdodCkge1xyXG4gICAgcmV0dXJuIGlzRXF1YWwobGVmdCwgcmlnaHQpID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xyXG4gIH0sXHJcbiAgXCIhPVwiOiBmdW5jdGlvbiBuZXEobGVmdCwgcmlnaHQpIHtcclxuICAgIHJldHVybiBpc0VxdWFsKGxlZnQsIHJpZ2h0KSA/IEZBTFNFX1ZBTFVFIDogVFJVRV9WQUxVRTtcclxuICB9LFxyXG4gIFwiPlwiOiBmdW5jdGlvbiBndChsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XHJcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdCA+IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XHJcbiAgfSxcclxuICBcIj49XCI6IGZ1bmN0aW9uIGd0ZShsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJzdHJlYW1cIiB8fCByaWdodC50eXBlID09PSBcInN0cmVhbVwiKVxyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHBhcnRpYWxDb21wYXJlKGxlZnQuZGF0YSwgcmlnaHQuZGF0YSk7XHJcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdCA+PSAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xyXG4gIH0sXHJcbiAgXCI8XCI6IGZ1bmN0aW9uIGx0KGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcclxuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0IDwgMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcclxuICB9LFxyXG4gIFwiPD1cIjogZnVuY3Rpb24gbHRlKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC50eXBlID09PSBcInN0cmVhbVwiIHx8IHJpZ2h0LnR5cGUgPT09IFwic3RyZWFtXCIpXHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgY29uc3QgcmVzdWx0ID0gcGFydGlhbENvbXBhcmUobGVmdC5kYXRhLCByaWdodC5kYXRhKTtcclxuICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0IDw9IDAgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XHJcbiAgfSxcclxuICBpbjogYXN5bmMgZnVuY3Rpb24gaW5vcChsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKHJpZ2h0LnR5cGUgPT09IFwicGF0aFwiKSB7XHJcbiAgICAgIGlmIChsZWZ0LnR5cGUgIT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gcmlnaHQuZGF0YS5tYXRjaGVzKGxlZnQuZGF0YSkgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBpZiAocmlnaHQuaXNBcnJheSgpKSB7XHJcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgYiBvZiByaWdodCkge1xyXG4gICAgICAgIGlmIChpc0VxdWFsKGxlZnQsIGIpKSB7XHJcbiAgICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfSxcclxuICBtYXRjaDogYXN5bmMgZnVuY3Rpb24gbWF0Y2gobGVmdCwgcmlnaHQpIHtcclxuICAgIGxldCB0b2tlbnMgPSBbXTtcclxuICAgIGxldCBwYXR0ZXJucyA9IFtdO1xyXG4gICAgYXdhaXQgZ2F0aGVyVGV4dChsZWZ0LCAocGFydCkgPT4ge1xyXG4gICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KG1hdGNoVG9rZW5pemUocGFydCkpO1xyXG4gICAgfSk7XHJcbiAgICBjb25zdCBkaWRTdWNjZWVkID0gYXdhaXQgZ2F0aGVyVGV4dChyaWdodCwgKHBhcnQpID0+IHtcclxuICAgICAgcGF0dGVybnMgPSBwYXR0ZXJucy5jb25jYXQobWF0Y2hBbmFseXplUGF0dGVybihwYXJ0KSk7XHJcbiAgICB9KTtcclxuICAgIGlmICghZGlkU3VjY2VlZCkge1xyXG4gICAgICByZXR1cm4gRkFMU0VfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBtYXRjaGVkID0gbWF0Y2hUZXh0KHRva2VucywgcGF0dGVybnMpO1xyXG4gICAgcmV0dXJuIG1hdGNoZWQgPyBUUlVFX1ZBTFVFIDogRkFMU0VfVkFMVUU7XHJcbiAgfSxcclxuICBcIitcIjogZnVuY3Rpb24gcGx1cyhsZWZ0LCByaWdodCkge1xyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJkYXRldGltZVwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgcmV0dXJuIGZyb21EYXRlVGltZShsZWZ0LmRhdGEuYWRkKHJpZ2h0LmRhdGEpKTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwibnVtYmVyXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICByZXR1cm4gZnJvbU51bWJlcihsZWZ0LmRhdGEgKyByaWdodC5kYXRhKTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwic3RyaW5nXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICByZXR1cm4gZnJvbVN0cmluZyhsZWZ0LmRhdGEgKyByaWdodC5kYXRhKTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwib2JqZWN0XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICByZXR1cm4gZnJvbUpTKF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBsZWZ0LmRhdGEpLCByaWdodC5kYXRhKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC50eXBlID09PSBcImFycmF5XCIgJiYgcmlnaHQudHlwZSA9PT0gXCJhcnJheVwiKSB7XHJcbiAgICAgIHJldHVybiBmcm9tSlMobGVmdC5kYXRhLmNvbmNhdChyaWdodC5kYXRhKSk7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdC5pc0FycmF5KCkgJiYgcmlnaHQuaXNBcnJheSgpKSB7XHJcbiAgICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbCBvZiBsZWZ0KSB7XHJcbiAgICAgICAgICB5aWVsZCB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsIG9mIHJpZ2h0KSB7XHJcbiAgICAgICAgICB5aWVsZCB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH0sXHJcbiAgXCItXCI6IGZ1bmN0aW9uIG1pbnVzKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC50eXBlID09PSBcImRhdGV0aW1lXCIgJiYgcmlnaHQudHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG4gICAgICByZXR1cm4gZnJvbURhdGVUaW1lKGxlZnQuZGF0YS5hZGQoLXJpZ2h0LmRhdGEpKTtcclxuICAgIH1cclxuICAgIGlmIChsZWZ0LnR5cGUgPT09IFwiZGF0ZXRpbWVcIiAmJiByaWdodC50eXBlID09PSBcImRhdGV0aW1lXCIpIHtcclxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIobGVmdC5kYXRhLmRpZmZlcmVuY2UocmlnaHQuZGF0YSkpO1xyXG4gICAgfVxyXG4gICAgaWYgKGxlZnQudHlwZSA9PT0gXCJudW1iZXJcIiAmJiByaWdodC50eXBlID09PSBcIm51bWJlclwiKSB7XHJcbiAgICAgIHJldHVybiBmcm9tTnVtYmVyKGxlZnQuZGF0YSAtIHJpZ2h0LmRhdGEpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfSxcclxuICBcIipcIjogbnVtZXJpY09wZXJhdG9yKChhLCBiKSA9PiBhICogYiksXHJcbiAgXCIvXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gYSAvIGIpLFxyXG4gIFwiJVwiOiBudW1lcmljT3BlcmF0b3IoKGEsIGIpID0+IGEgJSBiKSxcclxuICBcIioqXCI6IG51bWVyaWNPcGVyYXRvcigoYSwgYikgPT4gTWF0aC5wb3coYSwgYikpXHJcbn07XHJcbmZ1bmN0aW9uIG51bWVyaWNPcGVyYXRvcihpbXBsKSB7XHJcbiAgcmV0dXJuIGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICBpZiAobGVmdC50eXBlID09PSBcIm51bWJlclwiICYmIHJpZ2h0LnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgY29uc3QgcmVzdWx0ID0gaW1wbChsZWZ0LmRhdGEsIHJpZ2h0LmRhdGEpO1xyXG4gICAgICByZXR1cm4gZnJvbU51bWJlcihyZXN1bHQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfTtcclxufVxyXG5jbGFzcyBTY29wZSB7XHJcbiAgY29uc3RydWN0b3IocGFyYW1zLCBzb3VyY2UsIHZhbHVlLCBjb250ZXh0LCBwYXJlbnQpIHtcclxuICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcclxuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xyXG4gICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XHJcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgfVxyXG4gIGNyZWF0ZU5lc3RlZCh2YWx1ZSkge1xyXG4gICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgcmV0dXJuIG5ldyBTY29wZSh0aGlzLnBhcmFtcywgdGhpcy5zb3VyY2UsIHZhbHVlLCB0aGlzLmNvbnRleHQsIHRoaXMucGFyZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5wYXJhbXMsIHRoaXMuc291cmNlLCB2YWx1ZSwgdGhpcy5jb250ZXh0LCB0aGlzKTtcclxuICB9XHJcbiAgY3JlYXRlSGlkZGVuKHZhbHVlKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmNyZWF0ZU5lc3RlZCh2YWx1ZSk7XHJcbiAgICByZXN1bHQuaXNIaWRkZW4gPSB0cnVlO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxuICB9XHJcbn1cclxuZnVuY3Rpb24gZXZhbHVhdGUobm9kZSwgc2NvcGUsIGV4ZWN1dGUgPSBldmFsdWF0ZSkge1xyXG4gIGNvbnN0IGZ1bmMgPSBFWEVDVVRPUlNbbm9kZS50eXBlXTtcclxuICByZXR1cm4gZnVuYyhub2RlLCBzY29wZSwgZXhlY3V0ZSk7XHJcbn1cclxuZnVuY3Rpb24gcHJvbWlzZWxlc3NBcHBseSh2YWx1ZSwgY2IpIHtcclxuICBpZiAoXCJ0aGVuXCIgaW4gdmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZS50aGVuKGNiKTtcclxuICB9XHJcbiAgcmV0dXJuIGNiKHZhbHVlKTtcclxufVxyXG5jb25zdCBFWEVDVVRPUlMgPSB7XHJcbiAgVGhpcyhfLCBzY29wZSkge1xyXG4gICAgcmV0dXJuIHNjb3BlLnZhbHVlO1xyXG4gIH0sXHJcbiAgRXZlcnl0aGluZyhfLCBzY29wZSkge1xyXG4gICAgcmV0dXJuIHNjb3BlLnNvdXJjZTtcclxuICB9LFxyXG4gIFBhcmFtZXRlcih7IG5hbWUgfSwgc2NvcGUpIHtcclxuICAgIHJldHVybiBmcm9tSlMoc2NvcGUucGFyYW1zW25hbWVdKTtcclxuICB9LFxyXG4gIENvbnRleHQoeyBrZXkgfSwgc2NvcGUpIHtcclxuICAgIGlmIChrZXkgPT09IFwiYmVmb3JlXCIgfHwga2V5ID09PSBcImFmdGVyXCIpIHtcclxuICAgICAgY29uc3QgdmFsdWUgPSBzY29wZS5jb250ZXh0W2tleV07XHJcbiAgICAgIHJldHVybiB2YWx1ZSB8fCBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGNvbnRleHQga2V5OiAke2tleX1gKTtcclxuICB9LFxyXG4gIFBhcmVudCh7IG4gfSwgc2NvcGUpIHtcclxuICAgIGxldCBjdXJyZW50ID0gc2NvcGU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICBpZiAoIWN1cnJlbnQucGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICAgIH1cclxuICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGN1cnJlbnQudmFsdWU7XHJcbiAgfSxcclxuICBPcENhbGwoeyBvcCwgbGVmdCwgcmlnaHQgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIGNvbnN0IGZ1bmMgPSBvcGVyYXRvcnNbb3BdO1xyXG4gICAgaWYgKCFmdW5jKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBvcGVyYXRvcjogJHtvcH1gKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IGV4ZWN1dGUobGVmdCwgc2NvcGUpO1xyXG4gICAgY29uc3QgcmlnaHRWYWx1ZSA9IGV4ZWN1dGUocmlnaHQsIHNjb3BlKTtcclxuICAgIGlmIChcInRoZW5cIiBpbiBsZWZ0VmFsdWUgfHwgXCJ0aGVuXCIgaW4gcmlnaHRWYWx1ZSkge1xyXG4gICAgICByZXR1cm4gKGFzeW5jICgpID0+IGZ1bmMoYXdhaXQgbGVmdFZhbHVlLCBhd2FpdCByaWdodFZhbHVlKSkoKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jKGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XHJcbiAgfSxcclxuICBhc3luYyBTZWxlY3QoeyBhbHRlcm5hdGl2ZXMsIGZhbGxiYWNrIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBmb3IgKGNvbnN0IGFsdCBvZiBhbHRlcm5hdGl2ZXMpIHtcclxuICAgICAgY29uc3QgYWx0Q29uZCA9IGF3YWl0IGV4ZWN1dGUoYWx0LmNvbmRpdGlvbiwgc2NvcGUpO1xyXG4gICAgICBpZiAoYWx0Q29uZC50eXBlID09PSBcImJvb2xlYW5cIiAmJiBhbHRDb25kLmRhdGEgPT09IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gZXhlY3V0ZShhbHQudmFsdWUsIHNjb3BlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGZhbGxiYWNrKSB7XHJcbiAgICAgIHJldHVybiBleGVjdXRlKGZhbGxiYWNrLCBzY29wZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9LFxyXG4gIGFzeW5jIEluUmFuZ2UoeyBiYXNlLCBsZWZ0LCByaWdodCwgaXNJbmNsdXNpdmUgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBhd2FpdCBleGVjdXRlKGxlZnQsIHNjb3BlKTtcclxuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSBhd2FpdCBleGVjdXRlKHJpZ2h0LCBzY29wZSk7XHJcbiAgICBjb25zdCBsZWZ0Q21wID0gcGFydGlhbENvbXBhcmUoYXdhaXQgdmFsdWUuZ2V0KCksIGF3YWl0IGxlZnRWYWx1ZS5nZXQoKSk7XHJcbiAgICBpZiAobGVmdENtcCA9PT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIGNvbnN0IHJpZ2h0Q21wID0gcGFydGlhbENvbXBhcmUoYXdhaXQgdmFsdWUuZ2V0KCksIGF3YWl0IHJpZ2h0VmFsdWUuZ2V0KCkpO1xyXG4gICAgaWYgKHJpZ2h0Q21wID09PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XHJcbiAgICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPD0gMCA/IFRSVUVfVkFMVUUgOiBGQUxTRV9WQUxVRTtcclxuICAgIH1cclxuICAgIHJldHVybiBsZWZ0Q21wID49IDAgJiYgcmlnaHRDbXAgPCAwID8gVFJVRV9WQUxVRSA6IEZBTFNFX1ZBTFVFO1xyXG4gIH0sXHJcbiAgYXN5bmMgRmlsdGVyKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbmV3IFN0cmVhbVZhbHVlKGFzeW5jIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgZWxlbSBvZiBiYXNlVmFsdWUpIHtcclxuICAgICAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChlbGVtKTtcclxuICAgICAgICBjb25zdCBleHByVmFsdWUgPSBhd2FpdCBleGVjdXRlKGV4cHIsIG5ld1Njb3BlKTtcclxuICAgICAgICBpZiAoZXhwclZhbHVlLnR5cGUgPT09IFwiYm9vbGVhblwiICYmIGV4cHJWYWx1ZS5kYXRhID09PSB0cnVlKSB7XHJcbiAgICAgICAgICB5aWVsZCBlbGVtO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfSxcclxuICBhc3luYyBQcm9qZWN0aW9uKHsgYmFzZSwgZXhwciB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICBpZiAoYmFzZVZhbHVlLnR5cGUgIT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBuZXdTY29wZSA9IHNjb3BlLmNyZWF0ZU5lc3RlZChiYXNlVmFsdWUpO1xyXG4gICAgcmV0dXJuIGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xyXG4gIH0sXHJcbiAgRnVuY0NhbGwoeyBmdW5jLCBhcmdzIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICByZXR1cm4gZnVuYyhhcmdzLCBzY29wZSwgZXhlY3V0ZSk7XHJcbiAgfSxcclxuICBhc3luYyBQaXBlRnVuY0NhbGwoeyBmdW5jLCBiYXNlLCBhcmdzIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCBiYXNlVmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICAgIHJldHVybiBmdW5jKGJhc2VWYWx1ZSwgYXJncywgc2NvcGUsIGV4ZWN1dGUpO1xyXG4gIH0sXHJcbiAgYXN5bmMgQWNjZXNzQXR0cmlidXRlKHsgYmFzZSwgbmFtZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgbGV0IHZhbHVlID0gc2NvcGUudmFsdWU7XHJcbiAgICBpZiAoYmFzZSkge1xyXG4gICAgICB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgaWYgKHZhbHVlLmRhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gZnJvbUpTKHZhbHVlLmRhdGFbbmFtZV0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICB9LFxyXG4gIGFzeW5jIEFjY2Vzc0VsZW1lbnQoeyBiYXNlLCBpbmRleCB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgYmFzZVZhbHVlLmdldCgpO1xyXG4gICAgY29uc3QgZmluYWxJbmRleCA9IGluZGV4IDwgMCA/IGluZGV4ICsgZGF0YS5sZW5ndGggOiBpbmRleDtcclxuICAgIHJldHVybiBmcm9tSlMoZGF0YVtmaW5hbEluZGV4XSk7XHJcbiAgfSxcclxuICBhc3luYyBTbGljZSh7IGJhc2UsIGxlZnQsIHJpZ2h0LCBpc0luY2x1c2l2ZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgYmFzZVZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICBpZiAoIWJhc2VWYWx1ZS5pc0FycmF5KCkpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhcnJheSA9IGF3YWl0IGJhc2VWYWx1ZS5nZXQoKTtcclxuICAgIGxldCBsZWZ0SWR4ID0gbGVmdDtcclxuICAgIGxldCByaWdodElkeCA9IHJpZ2h0O1xyXG4gICAgaWYgKGxlZnRJZHggPCAwKSB7XHJcbiAgICAgIGxlZnRJZHggPSBhcnJheS5sZW5ndGggKyBsZWZ0SWR4O1xyXG4gICAgfVxyXG4gICAgaWYgKHJpZ2h0SWR4IDwgMCkge1xyXG4gICAgICByaWdodElkeCA9IGFycmF5Lmxlbmd0aCArIHJpZ2h0SWR4O1xyXG4gICAgfVxyXG4gICAgaWYgKGlzSW5jbHVzaXZlKSB7XHJcbiAgICAgIHJpZ2h0SWR4Kys7XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdElkeCA8IDApIHtcclxuICAgICAgbGVmdElkeCA9IDA7XHJcbiAgICB9XHJcbiAgICBpZiAocmlnaHRJZHggPCAwKSB7XHJcbiAgICAgIHJpZ2h0SWR4ID0gMDtcclxuICAgIH1cclxuICAgIHJldHVybiBmcm9tSlMoYXJyYXkuc2xpY2UobGVmdElkeCwgcmlnaHRJZHgpKTtcclxuICB9LFxyXG4gIGFzeW5jIERlcmVmKHsgYmFzZSB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGJhc2UsIHNjb3BlKTtcclxuICAgIGlmICghc2NvcGUuc291cmNlLmlzQXJyYXkoKSkge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgY29uc3QgaWQgPSB2YWx1ZS5kYXRhLl9yZWY7XHJcbiAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgZm9yIGF3YWl0IChjb25zdCBkb2Mgb2Ygc2NvcGUuc291cmNlKSB7XHJcbiAgICAgIGlmIChkb2MudHlwZSA9PT0gXCJvYmplY3RcIiAmJiBpZCA9PT0gZG9jLmRhdGEuX2lkKSB7XHJcbiAgICAgICAgcmV0dXJuIGRvYztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgfSxcclxuICBWYWx1ZSh7IHZhbHVlIH0pIHtcclxuICAgIHJldHVybiBmcm9tSlModmFsdWUpO1xyXG4gIH0sXHJcbiAgR3JvdXAoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICByZXR1cm4gZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgfSxcclxuICBhc3luYyBPYmplY3QoeyBhdHRyaWJ1dGVzIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcclxuICAgIGZvciAoY29uc3QgYXR0ciBvZiBhdHRyaWJ1dGVzKSB7XHJcbiAgICAgIGNvbnN0IGF0dHJUeXBlID0gYXR0ci50eXBlO1xyXG4gICAgICBzd2l0Y2ggKGF0dHIudHlwZSkge1xyXG4gICAgICAgIGNhc2UgXCJPYmplY3RBdHRyaWJ1dGVWYWx1ZVwiOiB7XHJcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYXR0ci52YWx1ZSwgc2NvcGUpO1xyXG4gICAgICAgICAgcmVzdWx0W2F0dHIubmFtZV0gPSBhd2FpdCB2YWx1ZS5nZXQoKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlIFwiT2JqZWN0Q29uZGl0aW9uYWxTcGxhdFwiOiB7XHJcbiAgICAgICAgICBjb25zdCBjb25kID0gYXdhaXQgZXhlY3V0ZShhdHRyLmNvbmRpdGlvbiwgc2NvcGUpO1xyXG4gICAgICAgICAgaWYgKGNvbmQudHlwZSAhPT0gXCJib29sZWFuXCIgfHwgY29uZC5kYXRhID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XHJcbiAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSBcIk9iamVjdFNwbGF0XCI6IHtcclxuICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShhdHRyLnZhbHVlLCBzY29wZSk7XHJcbiAgICAgICAgICBpZiAodmFsdWUudHlwZSA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgdmFsdWUuZGF0YSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBub2RlIHR5cGU6ICR7YXR0clR5cGV9YCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmcm9tSlMocmVzdWx0KTtcclxuICB9LFxyXG4gIEFycmF5KHsgZWxlbWVudHMgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcclxuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBleGVjdXRlKGVsZW1lbnQudmFsdWUsIHNjb3BlKTtcclxuICAgICAgICBpZiAoZWxlbWVudC5pc1NwbGF0KSB7XHJcbiAgICAgICAgICBpZiAodmFsdWUuaXNBcnJheSgpKSB7XHJcbiAgICAgICAgICAgIGZvciBhd2FpdCAoY29uc3QgdiBvZiB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgIHlpZWxkIHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeWllbGQgdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIFR1cGxlKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidHVwbGVzIGNhbiBub3QgYmUgZXZhbHVhdGVkXCIpO1xyXG4gIH0sXHJcbiAgYXN5bmMgT3IoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XHJcbiAgICBjb25zdCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xyXG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IHRydWUpIHtcclxuICAgICAgICByZXR1cm4gVFJVRV9WQUxVRTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHJpZ2h0VmFsdWUudHlwZSA9PT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgaWYgKHJpZ2h0VmFsdWUuZGF0YSA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHJldHVybiBUUlVFX1ZBTFVFO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAobGVmdFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJib29sZWFuXCIpIHtcclxuICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gRkFMU0VfVkFMVUU7XHJcbiAgfSxcclxuICBhc3luYyBBbmQoeyBsZWZ0LCByaWdodCB9LCBzY29wZSwgZXhlY3V0ZSkge1xyXG4gICAgY29uc3QgbGVmdFZhbHVlID0gYXdhaXQgZXhlY3V0ZShsZWZ0LCBzY29wZSk7XHJcbiAgICBjb25zdCByaWdodFZhbHVlID0gYXdhaXQgZXhlY3V0ZShyaWdodCwgc2NvcGUpO1xyXG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICBpZiAobGVmdFZhbHVlLmRhdGEgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIEZBTFNFX1ZBTFVFO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAocmlnaHRWYWx1ZS50eXBlID09PSBcImJvb2xlYW5cIikge1xyXG4gICAgICBpZiAocmlnaHRWYWx1ZS5kYXRhID09PSBmYWxzZSkge1xyXG4gICAgICAgIHJldHVybiBGQUxTRV9WQUxVRTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGxlZnRWYWx1ZS50eXBlICE9PSBcImJvb2xlYW5cIiB8fCByaWdodFZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFRSVUVfVkFMVUU7XHJcbiAgfSxcclxuICBhc3luYyBOb3QoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xyXG4gICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiYm9vbGVhblwiKSB7XHJcbiAgICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlLmRhdGEgPyBGQUxTRV9WQUxVRSA6IFRSVUVfVkFMVUU7XHJcbiAgfSxcclxuICBOZWcoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgKHZhbHVlKSA9PiB7XHJcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIoLXZhbHVlLmRhdGEpO1xyXG4gICAgfSk7XHJcbiAgfSxcclxuICBQb3MoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICByZXR1cm4gcHJvbWlzZWxlc3NBcHBseShleGVjdXRlKGJhc2UsIHNjb3BlKSwgKHZhbHVlKSA9PiB7XHJcbiAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcIm51bWJlclwiKSB7XHJcbiAgICAgICAgcmV0dXJuIE5VTExfVkFMVUU7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZyb21OdW1iZXIodmFsdWUuZGF0YSk7XHJcbiAgICB9KTtcclxuICB9LFxyXG4gIEFzYygpIHtcclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH0sXHJcbiAgRGVzYygpIHtcclxuICAgIHJldHVybiBOVUxMX1ZBTFVFO1xyXG4gIH0sXHJcbiAgYXN5bmMgQXJyYXlDb2VyY2UoeyBiYXNlIH0sIHNjb3BlLCBleGVjdXRlKSB7XHJcbiAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IGV4ZWN1dGUoYmFzZSwgc2NvcGUpO1xyXG4gICAgcmV0dXJuIHZhbHVlLmlzQXJyYXkoKSA/IHZhbHVlIDogTlVMTF9WQUxVRTtcclxuICB9LFxyXG4gIGFzeW5jIE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XHJcbiAgICAgICAgeWllbGQgYXdhaXQgZXhlY3V0ZShleHByLCBuZXdTY29wZSk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH0sXHJcbiAgYXN5bmMgRmxhdE1hcCh7IGJhc2UsIGV4cHIgfSwgc2NvcGUsIGV4ZWN1dGUpIHtcclxuICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgZXhlY3V0ZShiYXNlLCBzY29wZSk7XHJcbiAgICBpZiAoIXZhbHVlLmlzQXJyYXkoKSkge1xyXG4gICAgICByZXR1cm4gTlVMTF9WQUxVRTtcclxuICAgIH1cclxuICAgIHJldHVybiBuZXcgU3RyZWFtVmFsdWUoYXN5bmMgZnVuY3Rpb24qICgpIHtcclxuICAgICAgZm9yIGF3YWl0IChjb25zdCBlbGVtIG9mIHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U2NvcGUgPSBzY29wZS5jcmVhdGVIaWRkZW4oZWxlbSk7XHJcbiAgICAgICAgY29uc3QgaW5uZXJWYWx1ZSA9IGF3YWl0IGV4ZWN1dGUoZXhwciwgbmV3U2NvcGUpO1xyXG4gICAgICAgIGlmIChpbm5lclZhbHVlLmlzQXJyYXkoKSkge1xyXG4gICAgICAgICAgZm9yIGF3YWl0IChjb25zdCBpbm5lciBvZiBpbm5lclZhbHVlKSB7XHJcbiAgICAgICAgICAgIHlpZWxkIGlubmVyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5aWVsZCBpbm5lclZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBldmFsdWF0ZVF1ZXJ5KHRyZWUsIG9wdGlvbnMgPSB7fSkge1xyXG4gIGNvbnN0IHJvb3QgPSBmcm9tSlMob3B0aW9ucy5yb290KTtcclxuICBjb25zdCBkYXRhc2V0ID0gZnJvbUpTKG9wdGlvbnMuZGF0YXNldCk7XHJcbiAgY29uc3QgcGFyYW1zID0gX19zcHJlYWRWYWx1ZXMoe30sIG9wdGlvbnMucGFyYW1zKTtcclxuICBjb25zdCBzY29wZSA9IG5ldyBTY29wZShwYXJhbXMsIGRhdGFzZXQsIHJvb3QsIHtcclxuICAgIHRpbWVzdGFtcDogb3B0aW9ucy50aW1lc3RhbXAgfHwgbmV3IERhdGUoKSxcclxuICAgIGlkZW50aXR5OiBvcHRpb25zLmlkZW50aXR5ID09PSB2b2lkIDAgPyBcIm1lXCIgOiBvcHRpb25zLmlkZW50aXR5LFxyXG4gICAgc2FuaXR5OiBvcHRpb25zLnNhbml0eSxcclxuICAgIGFmdGVyOiBvcHRpb25zLmFmdGVyID8gZnJvbUpTKG9wdGlvbnMuYWZ0ZXIpIDogbnVsbCxcclxuICAgIGJlZm9yZTogb3B0aW9ucy5iZWZvcmUgPyBmcm9tSlMob3B0aW9ucy5iZWZvcmUpIDogbnVsbFxyXG4gIH0sIG51bGwpO1xyXG4gIHJldHVybiBldmFsdWF0ZSh0cmVlLCBzY29wZSk7XHJcbn1cclxuZnVuY3Rpb24gY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSB7XHJcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcclxuICAgIGNhc2UgXCJHcm91cFwiOlxyXG4gICAgY2FzZSBcIlZhbHVlXCI6XHJcbiAgICBjYXNlIFwiUGFyYW1ldGVyXCI6XHJcbiAgICBjYXNlIFwiUG9zXCI6XHJcbiAgICBjYXNlIFwiTmVnXCI6XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgY2FzZSBcIk9wQ2FsbFwiOlxyXG4gICAgICBzd2l0Y2ggKG5vZGUub3ApIHtcclxuICAgICAgICBjYXNlIFwiK1wiOlxyXG4gICAgICAgIGNhc2UgXCItXCI6XHJcbiAgICAgICAgY2FzZSBcIipcIjpcclxuICAgICAgICBjYXNlIFwiL1wiOlxyXG4gICAgICAgIGNhc2UgXCIlXCI6XHJcbiAgICAgICAgY2FzZSBcIioqXCI6XHJcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgfVxyXG59XHJcbmNvbnN0IERVTU1ZX1NDT1BFID0gbmV3IFNjb3BlKHt9LCBOVUxMX1ZBTFVFLCBOVUxMX1ZBTFVFLCB7IHRpbWVzdGFtcDogbmV3IERhdGUoMCksIGlkZW50aXR5OiBcIm1lXCIsIGJlZm9yZTogbnVsbCwgYWZ0ZXI6IG51bGwgfSwgbnVsbCk7XHJcbmNsYXNzIENvbnN0YW50RXZhbHVhdGVFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIkNvbnN0YW50RXZhbHVhdGVFcnJvclwiO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiB0cnlDb25zdGFudEV2YWx1YXRlKG5vZGUpIHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGNvbnN0YW50RXZhbHVhdGUobm9kZSk7XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBpZiAoZXJyLm5hbWUgPT09IFwiQ29uc3RhbnRFdmFsdWF0ZUVycm9yXCIpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBlcnI7XHJcbiAgfVxyXG59XHJcbmZ1bmN0aW9uIGNvbnN0YW50RXZhbHVhdGUobm9kZSkge1xyXG4gIGlmICghY2FuQ29uc3RhbnRFdmFsdWF0ZShub2RlKSkge1xyXG4gICAgdGhyb3cgbmV3IENvbnN0YW50RXZhbHVhdGVFcnJvcihcImNhbm5vdCBjb25zdGFudCBldmFsdWF0ZVwiKTtcclxuICB9XHJcbiAgY29uc3QgdmFsdWUgPSBldmFsdWF0ZShub2RlLCBEVU1NWV9TQ09QRSwgY29uc3RhbnRFdmFsdWF0ZSk7XHJcbiAgaWYgKFwidGhlblwiIGluIHZhbHVlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJCVUc6IGNvbnN0YW50IGV2YWx1YXRlIHNob3VsZCBuZXZlciByZXR1cm4gYSBwcm9taXNlXCIpO1xyXG4gIH1cclxuICByZXR1cm4gdmFsdWU7XHJcbn1cclxuY29uc3QgRVNDQVBFX1NFUVVFTkNFID0ge1xyXG4gIFwiJ1wiOiBcIidcIixcclxuICAnXCInOiAnXCInLFxyXG4gIFwiXFxcXFwiOiBcIlxcXFxcIixcclxuICBcIi9cIjogXCIvXCIsXHJcbiAgYjogXCJcXGJcIixcclxuICBmOiBcIlxcZlwiLFxyXG4gIG46IFwiXFxuXCIsXHJcbiAgcjogXCJcXHJcIixcclxuICB0OiBcIlx0XCJcclxufTtcclxuZnVuY3Rpb24gZXhwYW5kSGV4KHN0cikge1xyXG4gIGNvbnN0IGNoYXJDb2RlID0gcGFyc2VJbnQoc3RyLCAxNik7XHJcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xyXG59XHJcbmNsYXNzIEdyb3FRdWVyeUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgIHRoaXMubmFtZSA9IFwiR3JvcVF1ZXJ5RXJyb3JcIjtcclxuICB9XHJcbn1cclxuY29uc3QgRVhQUl9CVUlMREVSID0ge1xyXG4gIGdyb3VwKHApIHtcclxuICAgIGNvbnN0IGlubmVyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIkdyb3VwXCIsXHJcbiAgICAgIGJhc2U6IGlubmVyXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgZXZlcnl0aGluZygpIHtcclxuICAgIHJldHVybiB7IHR5cGU6IFwiRXZlcnl0aGluZ1wiIH07XHJcbiAgfSxcclxuICB0aGlzKCkge1xyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJUaGlzXCIgfTtcclxuICB9LFxyXG4gIHBhcmVudCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiUGFyZW50XCIsXHJcbiAgICAgIG46IDFcclxuICAgIH07XHJcbiAgfSxcclxuICBkYmxwYXJlbnQocCkge1xyXG4gICAgY29uc3QgbmV4dCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJQYXJlbnRcIixcclxuICAgICAgbjogbmV4dC5uICsgMVxyXG4gICAgfTtcclxuICB9LFxyXG4gIHRyYXZlcnNlKHApIHtcclxuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHRyYXZlcnNhbExpc3QgPSBbXTtcclxuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInRyYXZlcnNhbF9lbmRcIikge1xyXG4gICAgICB0cmF2ZXJzYWxMaXN0LnB1c2gocC5wcm9jZXNzKFRSQVZFUlNFX0JVSUxERVIpKTtcclxuICAgIH1cclxuICAgIHAuc2hpZnQoKTtcclxuICAgIGxldCB0cmF2ZXJzYWwgPSBudWxsO1xyXG4gICAgZm9yIChsZXQgaSA9IHRyYXZlcnNhbExpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgdHJhdmVyc2FsID0gdHJhdmVyc2FsTGlzdFtpXSh0cmF2ZXJzYWwpO1xyXG4gICAgfVxyXG4gICAgaWYgKGJhc2UudHlwZSA9PT0gXCJFdmVyeXRoaW5nXCIgfHwgYmFzZS50eXBlID09PSBcIkFycmF5XCIgfHwgYmFzZS50eXBlID09PSBcIlBpcGVGdW5jQ2FsbFwiKSB7XHJcbiAgICAgIHRyYXZlcnNhbCA9IHRyYXZlcnNlQXJyYXkoKHZhbCkgPT4gdmFsLCB0cmF2ZXJzYWwpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRyYXZlcnNhbCA9PT0gbnVsbClcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQlVHOiB1bmV4cGVjdGVkIGVtcHR5IHRyYXZlcnNhbFwiKTtcclxuICAgIHJldHVybiB0cmF2ZXJzYWwuYnVpbGQoYmFzZSk7XHJcbiAgfSxcclxuICB0aGlzX2F0dHIocCkge1xyXG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xyXG4gICAgaWYgKG5hbWUgPT09IFwibnVsbFwiKSB7XHJcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IG51bGwgfTtcclxuICAgIH1cclxuICAgIGlmIChuYW1lID09PSBcInRydWVcIikge1xyXG4gICAgICByZXR1cm4geyB0eXBlOiBcIlZhbHVlXCIsIHZhbHVlOiB0cnVlIH07XHJcbiAgICB9XHJcbiAgICBpZiAobmFtZSA9PT0gXCJmYWxzZVwiKSB7XHJcbiAgICAgIHJldHVybiB7IHR5cGU6IFwiVmFsdWVcIiwgdmFsdWU6IGZhbHNlIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLFxyXG4gICAgICBuYW1lXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgbmVnKHApIHtcclxuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiTmVnXCIsXHJcbiAgICAgIGJhc2VcclxuICAgIH07XHJcbiAgfSxcclxuICBwb3MocCkge1xyXG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJQb3NcIixcclxuICAgICAgYmFzZVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGFkZChwKSB7XHJcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPcENhbGxcIixcclxuICAgICAgb3A6IFwiK1wiLFxyXG4gICAgICBsZWZ0LFxyXG4gICAgICByaWdodFxyXG4gICAgfTtcclxuICB9LFxyXG4gIHN1YihwKSB7XHJcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPcENhbGxcIixcclxuICAgICAgb3A6IFwiLVwiLFxyXG4gICAgICBsZWZ0LFxyXG4gICAgICByaWdodFxyXG4gICAgfTtcclxuICB9LFxyXG4gIG11bChwKSB7XHJcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPcENhbGxcIixcclxuICAgICAgb3A6IFwiKlwiLFxyXG4gICAgICBsZWZ0LFxyXG4gICAgICByaWdodFxyXG4gICAgfTtcclxuICB9LFxyXG4gIGRpdihwKSB7XHJcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPcENhbGxcIixcclxuICAgICAgb3A6IFwiL1wiLFxyXG4gICAgICBsZWZ0LFxyXG4gICAgICByaWdodFxyXG4gICAgfTtcclxuICB9LFxyXG4gIG1vZChwKSB7XHJcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPcENhbGxcIixcclxuICAgICAgb3A6IFwiJVwiLFxyXG4gICAgICBsZWZ0LFxyXG4gICAgICByaWdodFxyXG4gICAgfTtcclxuICB9LFxyXG4gIHBvdyhwKSB7XHJcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPcENhbGxcIixcclxuICAgICAgb3A6IFwiKipcIixcclxuICAgICAgbGVmdCxcclxuICAgICAgcmlnaHRcclxuICAgIH07XHJcbiAgfSxcclxuICBjb21wKHApIHtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IG9wID0gcC5wcm9jZXNzU3RyaW5nKCk7XHJcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJPcENhbGxcIixcclxuICAgICAgb3AsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHJpZ2h0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgaW5fcmFuZ2UocCkge1xyXG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgY29uc3QgaXNJbmNsdXNpdmUgPSBwLmdldE1hcmsoKS5uYW1lID09PSBcImluY19yYW5nZVwiO1xyXG4gICAgcC5zaGlmdCgpO1xyXG4gICAgY29uc3QgbGVmdCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgY29uc3QgcmlnaHQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiSW5SYW5nZVwiLFxyXG4gICAgICBiYXNlLFxyXG4gICAgICBsZWZ0LFxyXG4gICAgICByaWdodCxcclxuICAgICAgaXNJbmNsdXNpdmVcclxuICAgIH07XHJcbiAgfSxcclxuICBzdHIocCkge1xyXG4gICAgbGV0IHZhbHVlID0gXCJcIjtcclxuICAgIGxvb3A6XHJcbiAgICAgIHdoaWxlIChwLmhhc01hcmsoKSkge1xyXG4gICAgICAgIGNvbnN0IG1hcmsgPSBwLmdldE1hcmsoKTtcclxuICAgICAgICBzd2l0Y2ggKG1hcmsubmFtZSkge1xyXG4gICAgICAgICAgY2FzZSBcInN0cl9lbmRcIjpcclxuICAgICAgICAgICAgdmFsdWUgKz0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XHJcbiAgICAgICAgICAgIGJyZWFrIGxvb3A7XHJcbiAgICAgICAgICBjYXNlIFwic3RyX3BhdXNlXCI6XHJcbiAgICAgICAgICAgIHZhbHVlICs9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJzdHJfc3RhcnRcIjpcclxuICAgICAgICAgICAgcC5zaGlmdCgpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJzaW5nbGVfZXNjYXBlXCI6IHtcclxuICAgICAgICAgICAgY29uc3QgY2hhciA9IHAuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgICAgICAgdmFsdWUgKz0gRVNDQVBFX1NFUVVFTkNFW2NoYXJdO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNhc2UgXCJ1bmljb2RlX2hleFwiOlxyXG4gICAgICAgICAgICBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIHZhbHVlICs9IGV4cGFuZEhleChwLnByb2Nlc3NTdHJpbmdFbmQoKSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmV4cGVjdGVkIG1hcms6ICR7bWFyay5uYW1lfWApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgcmV0dXJuIHsgdHlwZTogXCJWYWx1ZVwiLCB2YWx1ZSB9O1xyXG4gIH0sXHJcbiAgaW50ZWdlcihwKSB7XHJcbiAgICBjb25zdCBzdHJWYWx1ZSA9IHAucHJvY2Vzc1N0cmluZ0VuZCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJWYWx1ZVwiLFxyXG4gICAgICB2YWx1ZTogTnVtYmVyKHN0clZhbHVlKVxyXG4gICAgfTtcclxuICB9LFxyXG4gIGZsb2F0KHApIHtcclxuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXHJcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgc2NpKHApIHtcclxuICAgIGNvbnN0IHN0clZhbHVlID0gcC5wcm9jZXNzU3RyaW5nRW5kKCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIlZhbHVlXCIsXHJcbiAgICAgIHZhbHVlOiBOdW1iZXIoc3RyVmFsdWUpXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgb2JqZWN0KHApIHtcclxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXTtcclxuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcIm9iamVjdF9lbmRcIikge1xyXG4gICAgICBhdHRyaWJ1dGVzLnB1c2gocC5wcm9jZXNzKE9CSkVDVF9CVUlMREVSKSk7XHJcbiAgICB9XHJcbiAgICBwLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9iamVjdFwiLFxyXG4gICAgICBhdHRyaWJ1dGVzXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgYXJyYXkocCkge1xyXG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcclxuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcImFycmF5X2VuZFwiKSB7XHJcbiAgICAgIGxldCBpc1NwbGF0ID0gZmFsc2U7XHJcbiAgICAgIGlmIChwLmdldE1hcmsoKS5uYW1lID09PSBcImFycmF5X3NwbGF0XCIpIHtcclxuICAgICAgICBpc1NwbGF0ID0gdHJ1ZTtcclxuICAgICAgICBwLnNoaWZ0KCk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgICAgZWxlbWVudHMucHVzaCh7XHJcbiAgICAgICAgdHlwZTogXCJBcnJheUVsZW1lbnRcIixcclxuICAgICAgICB2YWx1ZSxcclxuICAgICAgICBpc1NwbGF0XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcC5zaGlmdCgpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJBcnJheVwiLFxyXG4gICAgICBlbGVtZW50c1xyXG4gICAgfTtcclxuICB9LFxyXG4gIHR1cGxlKHApIHtcclxuICAgIGNvbnN0IG1lbWJlcnMgPSBbXTtcclxuICAgIHdoaWxlIChwLmdldE1hcmsoKS5uYW1lICE9PSBcInR1cGxlX2VuZFwiKSB7XHJcbiAgICAgIG1lbWJlcnMucHVzaChwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSk7XHJcbiAgICB9XHJcbiAgICBwLnNoaWZ0KCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIlR1cGxlXCIsXHJcbiAgICAgIG1lbWJlcnNcclxuICAgIH07XHJcbiAgfSxcclxuICBmdW5jX2NhbGwocCkge1xyXG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XHJcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIikge1xyXG4gICAgICBwLnNoaWZ0KCk7XHJcbiAgICAgIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xyXG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcInNlbGVjdFwiKSB7XHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcclxuICAgICAgICB0eXBlOiBcIlNlbGVjdFwiLFxyXG4gICAgICAgIGFsdGVybmF0aXZlczogW11cclxuICAgICAgfTtcclxuICAgICAgd2hpbGUgKHAuZ2V0TWFyaygpLm5hbWUgIT09IFwiZnVuY19hcmdzX2VuZFwiKSB7XHJcbiAgICAgICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwicGFpclwiKSB7XHJcbiAgICAgICAgICBpZiAocmVzdWx0LmZhbGxiYWNrKVxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYHVuZXhwZWN0ZWQgYXJndW1lbnQgdG8gc2VsZWN0KClgKTtcclxuICAgICAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgICAgICAgIHJlc3VsdC5hbHRlcm5hdGl2ZXMucHVzaCh7XHJcbiAgICAgICAgICAgIHR5cGU6IFwiU2VsZWN0QWx0ZXJuYXRpdmVcIixcclxuICAgICAgICAgICAgY29uZGl0aW9uLFxyXG4gICAgICAgICAgICB2YWx1ZVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmIChyZXN1bHQuZmFsbGJhY2spXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgdW5leHBlY3RlZCBhcmd1bWVudCB0byBzZWxlY3QoKWApO1xyXG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgICAgICAgIHJlc3VsdC5mYWxsYmFjayA9IHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBwLnNoaWZ0KCk7XHJcbiAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBjb25zdCBhcmdzID0gW107XHJcbiAgICB3aGlsZSAocC5nZXRNYXJrKCkubmFtZSAhPT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcclxuICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcclxuICAgIH1cclxuICAgIHAuc2hpZnQoKTtcclxuICAgIGlmIChuYW1lc3BhY2UgPT09IFwiZ2xvYmFsXCIgJiYgKG5hbWUgPT09IFwiYmVmb3JlXCIgfHwgbmFtZSA9PT0gXCJhZnRlclwiKSkge1xyXG4gICAgICBpZiAocC5wYXJzZU9wdGlvbnMubW9kZSA9PT0gXCJkZWx0YVwiKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIHR5cGU6IFwiQ29udGV4dFwiLFxyXG4gICAgICAgICAga2V5OiBuYW1lXHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKG5hbWVzcGFjZSA9PT0gXCJnbG9iYWxcIiAmJiBuYW1lID09PSBcImJvb3N0XCIgJiYgIXAuYWxsb3dCb29zdClcclxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBib29zdFwiKTtcclxuICAgIGNvbnN0IGZ1bmNzID0gbmFtZXNwYWNlc1tuYW1lc3BhY2VdO1xyXG4gICAgaWYgKCFmdW5jcykge1xyXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBuYW1lc3BhY2U6ICR7bmFtZXNwYWNlfWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZnVuYyA9IGZ1bmNzW25hbWVdO1xyXG4gICAgaWYgKCFmdW5jKSB7XHJcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgVW5kZWZpbmVkIGZ1bmN0aW9uOiAke25hbWV9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZnVuYy5hcml0eSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIHZhbGlkYXRlQXJpdHkobmFtZSwgZnVuYy5hcml0eSwgYXJncy5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgaWYgKGZ1bmMubW9kZSAhPT0gdm9pZCAwICYmIGZ1bmMubW9kZSAhPT0gcC5wYXJzZU9wdGlvbnMubW9kZSkge1xyXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBmdW5jdGlvbjogJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdHlwZTogXCJGdW5jQ2FsbFwiLFxyXG4gICAgICBmdW5jLFxyXG4gICAgICBuYW1lLFxyXG4gICAgICBhcmdzXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgcGlwZWNhbGwocCkge1xyXG4gICAgY29uc3QgYmFzZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgcC5zaGlmdCgpO1xyXG4gICAgbGV0IG5hbWVzcGFjZSA9IFwiZ2xvYmFsXCI7XHJcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJuYW1lc3BhY2VcIikge1xyXG4gICAgICBwLnNoaWZ0KCk7XHJcbiAgICAgIG5hbWVzcGFjZSA9IHAucHJvY2Vzc1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgaWYgKG5hbWVzcGFjZSAhPT0gXCJnbG9iYWxcIikge1xyXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBuYW1lc3BhY2U6ICR7bmFtZXNwYWNlfWApO1xyXG4gICAgfVxyXG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xyXG4gICAgY29uc3QgYXJncyA9IFtdO1xyXG4gICAgY29uc3Qgb2xkQWxsb3dCb29zdCA9IHAuYWxsb3dCb29zdDtcclxuICAgIGlmIChuYW1lID09PSBcInNjb3JlXCIpIHtcclxuICAgICAgcC5hbGxvd0Jvb3N0ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGZvciAoOyA7ICkge1xyXG4gICAgICBjb25zdCBtYXJrTmFtZSA9IHAuZ2V0TWFyaygpLm5hbWU7XHJcbiAgICAgIGlmIChtYXJrTmFtZSA9PT0gXCJmdW5jX2FyZ3NfZW5kXCIpIHtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgICBpZiAobmFtZSA9PT0gXCJvcmRlclwiKSB7XHJcbiAgICAgICAgaWYgKG1hcmtOYW1lID09PSBcImFzY1wiKSB7XHJcbiAgICAgICAgICBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiBcIkFzY1wiLCBiYXNlOiBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKSB9KTtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAobWFya05hbWUgPT09IFwiZGVzY1wiKSB7XHJcbiAgICAgICAgICBwLnNoaWZ0KCk7XHJcbiAgICAgICAgICBhcmdzLnB1c2goeyB0eXBlOiBcIkRlc2NcIiwgYmFzZTogcC5wcm9jZXNzKEVYUFJfQlVJTERFUikgfSk7XHJcbiAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgYXJncy5wdXNoKHAucHJvY2VzcyhFWFBSX0JVSUxERVIpKTtcclxuICAgIH1cclxuICAgIHAuc2hpZnQoKTtcclxuICAgIHAuYWxsb3dCb29zdCA9IG9sZEFsbG93Qm9vc3Q7XHJcbiAgICBjb25zdCBmdW5jID0gcGlwZUZ1bmN0aW9uc1tuYW1lXTtcclxuICAgIGlmICghZnVuYykge1xyXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoYFVuZGVmaW5lZCBwaXBlIGZ1bmN0aW9uOiAke25hbWV9YCk7XHJcbiAgICB9XHJcbiAgICBpZiAoZnVuYy5hcml0eSkge1xyXG4gICAgICB2YWxpZGF0ZUFyaXR5KG5hbWUsIGZ1bmMuYXJpdHksIGFyZ3MubGVuZ3RoKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiUGlwZUZ1bmNDYWxsXCIsXHJcbiAgICAgIGZ1bmMsXHJcbiAgICAgIGJhc2UsXHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIGFyZ3NcclxuICAgIH07XHJcbiAgfSxcclxuICBwYWlyKHApIHtcclxuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgdW5leHBlY3RlZCA9PmApO1xyXG4gIH0sXHJcbiAgYW5kKHApIHtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIkFuZFwiLFxyXG4gICAgICBsZWZ0LFxyXG4gICAgICByaWdodFxyXG4gICAgfTtcclxuICB9LFxyXG4gIG9yKHApIHtcclxuICAgIGNvbnN0IGxlZnQgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIGNvbnN0IHJpZ2h0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9yXCIsXHJcbiAgICAgIGxlZnQsXHJcbiAgICAgIHJpZ2h0XHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgbm90KHApIHtcclxuICAgIGNvbnN0IGJhc2UgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiTm90XCIsXHJcbiAgICAgIGJhc2VcclxuICAgIH07XHJcbiAgfSxcclxuICBhc2MocCkge1xyXG4gICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKFwidW5leHBlY3RlZCBhc2NcIik7XHJcbiAgfSxcclxuICBkZXNjKHApIHtcclxuICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihcInVuZXhwZWN0ZWQgZGVzY1wiKTtcclxuICB9LFxyXG4gIHBhcmFtKHApIHtcclxuICAgIGNvbnN0IG5hbWUgPSBwLnByb2Nlc3NTdHJpbmcoKTtcclxuICAgIGlmIChwLnBhcnNlT3B0aW9ucy5wYXJhbXMgJiYgcC5wYXJzZU9wdGlvbnMucGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJWYWx1ZVwiLFxyXG4gICAgICAgIHZhbHVlOiBwLnBhcnNlT3B0aW9ucy5wYXJhbXNbbmFtZV1cclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiUGFyYW1ldGVyXCIsXHJcbiAgICAgIG5hbWVcclxuICAgIH07XHJcbiAgfVxyXG59O1xyXG5jb25zdCBPQkpFQ1RfQlVJTERFUiA9IHtcclxuICBvYmplY3RfZXhwcihwKSB7XHJcbiAgICBpZiAocC5nZXRNYXJrKCkubmFtZSA9PT0gXCJwYWlyXCIpIHtcclxuICAgICAgcC5zaGlmdCgpO1xyXG4gICAgICBjb25zdCBjb25kaXRpb24gPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgICAgY29uc3QgdmFsdWUyID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdHlwZTogXCJPYmplY3RDb25kaXRpb25hbFNwbGF0XCIsXHJcbiAgICAgICAgY29uZGl0aW9uLFxyXG4gICAgICAgIHZhbHVlOiB2YWx1ZTJcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIGNvbnN0IHZhbHVlID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB0eXBlOiBcIk9iamVjdEF0dHJpYnV0ZVZhbHVlXCIsXHJcbiAgICAgIG5hbWU6IGV4dHJhY3RQcm9wZXJ0eUtleSh2YWx1ZSksXHJcbiAgICAgIHZhbHVlXHJcbiAgICB9O1xyXG4gIH0sXHJcbiAgb2JqZWN0X3BhaXIocCkge1xyXG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgaWYgKG5hbWUudHlwZSAhPT0gXCJWYWx1ZVwiKVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgc3RyaW5nXCIpO1xyXG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiT2JqZWN0QXR0cmlidXRlVmFsdWVcIixcclxuICAgICAgbmFtZTogbmFtZS52YWx1ZSxcclxuICAgICAgdmFsdWVcclxuICAgIH07XHJcbiAgfSxcclxuICBvYmplY3Rfc3BsYXQocCkge1xyXG4gICAgY29uc3QgdmFsdWUgPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcclxuICAgICAgdmFsdWVcclxuICAgIH07XHJcbiAgfSxcclxuICBvYmplY3Rfc3BsYXRfdGhpcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHR5cGU6IFwiT2JqZWN0U3BsYXRcIixcclxuICAgICAgdmFsdWU6IHsgdHlwZTogXCJUaGlzXCIgfVxyXG4gICAgfTtcclxuICB9XHJcbn07XHJcbmNvbnN0IFRSQVZFUlNFX0JVSUxERVIgPSB7XHJcbiAgc3F1YXJlX2JyYWNrZXQocCkge1xyXG4gICAgY29uc3QgZXhwciA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgY29uc3QgdmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKGV4cHIpO1xyXG4gICAgaWYgKHZhbHVlICYmIHZhbHVlLnR5cGUgPT09IFwibnVtYmVyXCIpIHtcclxuICAgICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VFbGVtZW50KChiYXNlKSA9PiAoeyB0eXBlOiBcIkFjY2Vzc0VsZW1lbnRcIiwgYmFzZSwgaW5kZXg6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KTtcclxuICAgIH1cclxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUGxhaW4oKGJhc2UpID0+ICh7IHR5cGU6IFwiQWNjZXNzQXR0cmlidXRlXCIsIGJhc2UsIG5hbWU6IHZhbHVlLmRhdGEgfSksIHJpZ2h0KTtcclxuICAgIH1cclxuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlQXJyYXkoKGJhc2UpID0+ICh7XHJcbiAgICAgIHR5cGU6IFwiRmlsdGVyXCIsXHJcbiAgICAgIGJhc2UsXHJcbiAgICAgIGV4cHJcclxuICAgIH0pLCByaWdodCk7XHJcbiAgfSxcclxuICBzbGljZShwKSB7XHJcbiAgICBjb25zdCBpc0luY2x1c2l2ZSA9IHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiaW5jX3JhbmdlXCI7XHJcbiAgICBwLnNoaWZ0KCk7XHJcbiAgICBjb25zdCBsZWZ0ID0gcC5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbiAgICBjb25zdCByaWdodCA9IHAucHJvY2VzcyhFWFBSX0JVSUxERVIpO1xyXG4gICAgY29uc3QgbGVmdFZhbHVlID0gdHJ5Q29uc3RhbnRFdmFsdWF0ZShsZWZ0KTtcclxuICAgIGNvbnN0IHJpZ2h0VmFsdWUgPSB0cnlDb25zdGFudEV2YWx1YXRlKHJpZ2h0KTtcclxuICAgIGlmICghbGVmdFZhbHVlIHx8ICFyaWdodFZhbHVlIHx8IGxlZnRWYWx1ZS50eXBlICE9PSBcIm51bWJlclwiIHx8IHJpZ2h0VmFsdWUudHlwZSAhPT0gXCJudW1iZXJcIikge1xyXG4gICAgICB0aHJvdyBuZXcgR3JvcVF1ZXJ5RXJyb3IoXCJzbGljaW5nIG11c3QgdXNlIGNvbnN0YW50IG51bWJlcnNcIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKHJocykgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHtcclxuICAgICAgdHlwZTogXCJTbGljZVwiLFxyXG4gICAgICBiYXNlLFxyXG4gICAgICBsZWZ0OiBsZWZ0VmFsdWUuZGF0YSxcclxuICAgICAgcmlnaHQ6IHJpZ2h0VmFsdWUuZGF0YSxcclxuICAgICAgaXNJbmNsdXNpdmVcclxuICAgIH0pLCByaHMpO1xyXG4gIH0sXHJcbiAgcHJvamVjdGlvbihwKSB7XHJcbiAgICBjb25zdCBvYmogPSBwLnByb2Nlc3MoRVhQUl9CVUlMREVSKTtcclxuICAgIHJldHVybiAocmlnaHQpID0+IHRyYXZlcnNlUHJvamVjdGlvbigoYmFzZSkgPT4gKHsgdHlwZTogXCJQcm9qZWN0aW9uXCIsIGJhc2UsIGV4cHI6IG9iaiB9KSwgcmlnaHQpO1xyXG4gIH0sXHJcbiAgYXR0cl9hY2Nlc3MocCkge1xyXG4gICAgY29uc3QgbmFtZSA9IHAucHJvY2Vzc1N0cmluZygpO1xyXG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gKHsgdHlwZTogXCJBY2Nlc3NBdHRyaWJ1dGVcIiwgYmFzZSwgbmFtZSB9KSwgcmlnaHQpO1xyXG4gIH0sXHJcbiAgZGVyZWYocCkge1xyXG4gICAgbGV0IGF0dHIgPSBudWxsO1xyXG4gICAgaWYgKHAuZ2V0TWFyaygpLm5hbWUgPT09IFwiZGVyZWZfYXR0clwiKSB7XHJcbiAgICAgIHAuc2hpZnQoKTtcclxuICAgICAgYXR0ciA9IHAucHJvY2Vzc1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgd3JhcCA9IChiYXNlKSA9PiBhdHRyID8geyB0eXBlOiBcIkFjY2Vzc0F0dHJpYnV0ZVwiLCBiYXNlLCBuYW1lOiBhdHRyIH0gOiBiYXNlO1xyXG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VQbGFpbigoYmFzZSkgPT4gd3JhcCh7XHJcbiAgICAgIHR5cGU6IFwiRGVyZWZcIixcclxuICAgICAgYmFzZVxyXG4gICAgfSksIHJpZ2h0KTtcclxuICB9LFxyXG4gIGFycmF5X3Bvc3RmaXgocCkge1xyXG4gICAgcmV0dXJuIChyaWdodCkgPT4gdHJhdmVyc2VBcnJheSgoYmFzZSkgPT4gKHsgdHlwZTogXCJBcnJheUNvZXJjZVwiLCBiYXNlIH0pLCByaWdodCk7XHJcbiAgfVxyXG59O1xyXG5mdW5jdGlvbiBleHRyYWN0UHJvcGVydHlLZXkobm9kZSkge1xyXG4gIGlmIChub2RlLnR5cGUgPT09IFwiQWNjZXNzQXR0cmlidXRlXCIgJiYgIW5vZGUuYmFzZSkge1xyXG4gICAgcmV0dXJuIG5vZGUubmFtZTtcclxuICB9XHJcbiAgaWYgKG5vZGUudHlwZSA9PT0gXCJEZXJlZlwiIHx8IG5vZGUudHlwZSA9PT0gXCJNYXBcIiB8fCBub2RlLnR5cGUgPT09IFwiUHJvamVjdGlvblwiIHx8IG5vZGUudHlwZSA9PT0gXCJTbGljZVwiIHx8IG5vZGUudHlwZSA9PT0gXCJGaWx0ZXJcIiB8fCBub2RlLnR5cGUgPT09IFwiQWNjZXNzRWxlbWVudFwiIHx8IG5vZGUudHlwZSA9PT0gXCJBcnJheUNvZXJjZVwiKSB7XHJcbiAgICByZXR1cm4gZXh0cmFjdFByb3BlcnR5S2V5KG5vZGUuYmFzZSk7XHJcbiAgfVxyXG4gIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgQ2Fubm90IGRldGVybWluZSBwcm9wZXJ0eSBrZXkgZm9yIHR5cGU6ICR7bm9kZS50eXBlfWApO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlQXJpdHkobmFtZSwgYXJpdHksIGNvdW50Mikge1xyXG4gIGlmICh0eXBlb2YgYXJpdHkgPT09IFwibnVtYmVyXCIpIHtcclxuICAgIGlmIChjb3VudDIgIT09IGFyaXR5KSB7XHJcbiAgICAgIHRocm93IG5ldyBHcm9xUXVlcnlFcnJvcihgSW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJHtuYW1lfSgpLiBFeHBlY3RlZCAke2FyaXR5fSwgZ290ICR7Y291bnQyfS5gKTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGFyaXR5KSB7XHJcbiAgICBpZiAoIWFyaXR5KGNvdW50MikpIHtcclxuICAgICAgdGhyb3cgbmV3IEdyb3FRdWVyeUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIGFyZ3VtZW50cyB0byBmdW5jdGlvbiAke25hbWV9KCkuYCk7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbmNsYXNzIEdyb3FTeW50YXhFcnJvciBleHRlbmRzIEVycm9yIHtcclxuICBjb25zdHJ1Y3Rvcihwb3NpdGlvbikge1xyXG4gICAgc3VwZXIoYFN5bnRheCBlcnJvciBpbiBHUk9RIHF1ZXJ5IGF0IHBvc2l0aW9uICR7cG9zaXRpb259YCk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIkdyb3FTeW50YXhFcnJvclwiO1xyXG4gICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gIH1cclxufVxyXG5mdW5jdGlvbiBwYXJzZShpbnB1dCwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgY29uc3QgcmVzdWx0ID0gcGFyc2UkMShpbnB1dCk7XHJcbiAgaWYgKHJlc3VsdC50eXBlID09PSBcImVycm9yXCIpIHtcclxuICAgIHRocm93IG5ldyBHcm9xU3ludGF4RXJyb3IocmVzdWx0LnBvc2l0aW9uKTtcclxuICB9XHJcbiAgY29uc3QgcHJvY2Vzc29yID0gbmV3IE1hcmtQcm9jZXNzb3IoaW5wdXQsIHJlc3VsdC5tYXJrcywgb3B0aW9ucyk7XHJcbiAgcmV0dXJuIHByb2Nlc3Nvci5wcm9jZXNzKEVYUFJfQlVJTERFUik7XHJcbn1cclxuZXhwb3J0IHsgZXZhbHVhdGVRdWVyeSBhcyBldmFsdWF0ZSwgcGFyc2UgfTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JvcS1qcy5lc20uanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/groq-js/dist/groq-js.esm.js\n");

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/incremental-patcher.js":
/*!*************************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/incremental-patcher.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; },\n/* harmony export */   \"getType\": function() { return /* binding */ getType; },\n/* harmony export */   \"rebaseValue\": function() { return /* binding */ rebaseValue; },\n/* harmony export */   \"unwrap\": function() { return /* binding */ unwrap; },\n/* harmony export */   \"wrap\": function() { return /* binding */ wrap; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\r\n\r\nvar Model = /** @class */ (function () {\r\n    function Model(meta) {\r\n        this.meta = meta;\r\n    }\r\n    Model.prototype.wrap = function (data) {\r\n        return this.wrapWithMeta(data, this.meta, this.meta);\r\n    };\r\n    Model.prototype.wrapWithMeta = function (data, startMeta, endMeta) {\r\n        if (endMeta === void 0) { endMeta = this.meta; }\r\n        return { data: data, startMeta: startMeta, endMeta: endMeta };\r\n    };\r\n    Model.prototype.asObject = function (value) {\r\n        if (!value.content) {\r\n            var fields = {};\r\n            for (var _i = 0, _a = Object.entries(value.data); _i < _a.length; _i++) {\r\n                var _b = _a[_i], key = _b[0], val = _b[1];\r\n                fields[key] = this.wrapWithMeta(val, value.startMeta);\r\n            }\r\n            value.content = { type: 'object', fields: fields };\r\n        }\r\n        return value.content;\r\n    };\r\n    Model.prototype.asArray = function (value) {\r\n        var _this = this;\r\n        if (!value.content) {\r\n            var elements = value.data.map(function (item) { return _this.wrapWithMeta(item, value.startMeta); });\r\n            var metas = elements.map(function () { return _this.meta; });\r\n            value.content = { type: 'array', elements: elements, metas: metas };\r\n        }\r\n        return value.content;\r\n    };\r\n    Model.prototype.asString = function (value) {\r\n        if (!value.content) {\r\n            var str = value.data;\r\n            var part = {\r\n                value: str,\r\n                utf8size: (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(str),\r\n                uses: [],\r\n                startMeta: value.startMeta,\r\n                endMeta: value.endMeta\r\n            };\r\n            value.content = this.stringFromParts([part]);\r\n        }\r\n        return value.content;\r\n    };\r\n    Model.prototype.stringFromParts = function (parts) {\r\n        var str = {\r\n            type: 'string',\r\n            parts: parts\r\n        };\r\n        for (var _i = 0, parts_1 = parts; _i < parts_1.length; _i++) {\r\n            var part = parts_1[_i];\r\n            part.uses.push(str);\r\n        }\r\n        return str;\r\n    };\r\n    Model.prototype.objectGetKeys = function (value) {\r\n        if (value.content) {\r\n            return Object.keys(value.content.fields);\r\n        }\r\n        else {\r\n            return Object.keys(value.data);\r\n        }\r\n    };\r\n    Model.prototype.objectGetField = function (value, key) {\r\n        var obj = this.asObject(value);\r\n        return obj.fields[key];\r\n    };\r\n    Model.prototype.arrayGetElement = function (value, idx) {\r\n        var arr = this.asArray(value);\r\n        return arr.elements[idx];\r\n    };\r\n    Model.prototype.finalize = function (content) {\r\n        this.updateEndMeta(content);\r\n        return { content: content, startMeta: this.meta, endMeta: this.meta };\r\n    };\r\n    Model.prototype.markChanged = function (value) {\r\n        return this.wrap(unwrap(value));\r\n    };\r\n    Model.prototype.updateEndMeta = function (content) {\r\n        if (content.type == 'string') {\r\n            for (var _i = 0, _a = content.parts; _i < _a.length; _i++) {\r\n                var part = _a[_i];\r\n                part.endMeta = this.meta;\r\n            }\r\n        }\r\n        else {\r\n            if (content.type === 'array') {\r\n                for (var _b = 0, _c = content.elements; _b < _c.length; _b++) {\r\n                    var val = _c[_b];\r\n                    if (val.content && val.endMeta !== this.meta) {\r\n                        this.updateEndMeta(val.content);\r\n                    }\r\n                    val.endMeta = this.meta;\r\n                }\r\n            }\r\n            else {\r\n                for (var _d = 0, _e = Object.values(content.fields); _d < _e.length; _d++) {\r\n                    var val = _e[_d];\r\n                    if (val.content && val.endMeta !== this.meta) {\r\n                        this.updateEndMeta(val.content);\r\n                    }\r\n                    val.endMeta = this.meta;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Model.prototype.copyString = function (value) {\r\n        if (value) {\r\n            var other = this.asString(value);\r\n            return this.stringFromParts(other.parts.slice());\r\n        }\r\n        else {\r\n            return {\r\n                type: 'string',\r\n                parts: []\r\n            };\r\n        }\r\n    };\r\n    Model.prototype.copyObject = function (value) {\r\n        var obj = {\r\n            type: 'object',\r\n            fields: {}\r\n        };\r\n        if (value) {\r\n            var other = this.asObject(value);\r\n            Object.assign(obj.fields, other.fields);\r\n        }\r\n        return obj;\r\n    };\r\n    Model.prototype.copyArray = function (value) {\r\n        var arr = value ? this.asArray(value) : null;\r\n        var elements = arr ? arr.elements : [];\r\n        var metas = arr ? arr.metas : [];\r\n        return {\r\n            type: 'array',\r\n            elements: elements,\r\n            metas: metas\r\n        };\r\n    };\r\n    Model.prototype.objectSetField = function (target, key, value) {\r\n        target.fields[key] = value;\r\n    };\r\n    Model.prototype.objectDeleteField = function (target, key) {\r\n        delete target.fields[key];\r\n    };\r\n    Model.prototype.arrayAppendValue = function (target, value) {\r\n        target.elements.push(value);\r\n        target.metas.push(this.meta);\r\n    };\r\n    Model.prototype.arrayAppendSlice = function (target, source, left, right) {\r\n        var _a, _b;\r\n        var arr = this.asArray(source);\r\n        var samePosition = arr.elements.length === left;\r\n        (_a = target.elements).push.apply(_a, arr.elements.slice(left, right));\r\n        if (samePosition) {\r\n            (_b = target.metas).push.apply(_b, arr.metas.slice(left, right));\r\n        }\r\n        else {\r\n            for (var i = left; i < right; i++) {\r\n                target.metas.push(this.meta);\r\n            }\r\n        }\r\n    };\r\n    Model.prototype.stringAppendValue = function (target, value) {\r\n        var str = this.asString(value);\r\n        for (var _i = 0, _a = str.parts; _i < _a.length; _i++) {\r\n            var part = _a[_i];\r\n            this.stringAppendPart(target, part);\r\n        }\r\n    };\r\n    Model.prototype.stringAppendPart = function (target, part) {\r\n        target.parts.push(part);\r\n        part.uses.push(target);\r\n    };\r\n    Model.prototype.resolveStringPart = function (str, from, len) {\r\n        if (len === 0)\r\n            return from;\r\n        for (var i = from; i < str.parts.length; i++) {\r\n            var part = str.parts[i];\r\n            if (len === part.utf8size) {\r\n                // Matches perfect!\r\n                return i + 1;\r\n            }\r\n            if (len < part.utf8size) {\r\n                // It's a part of this chunk. We now need to split it up.\r\n                this.splitString(part, len);\r\n                return i + 1;\r\n            }\r\n            len -= part.utf8size;\r\n        }\r\n        throw new Error('splitting string out of bounds');\r\n    };\r\n    Model.prototype.splitString = function (part, idx) {\r\n        var leftValue;\r\n        var rightValue;\r\n        var leftSize = idx;\r\n        var rightSize = part.utf8size - leftSize;\r\n        // idx is here in UTF-8 index, not codepoint index.\r\n        // This means we might to adjust for multi-byte characters.\r\n        if (part.utf8size !== part.value.length) {\r\n            var byteCount = 0;\r\n            for (idx = 0; byteCount < leftSize; idx++) {\r\n                var code = part.value.codePointAt(idx);\r\n                var size = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8charSize)(code);\r\n                if (size === 4)\r\n                    idx++; // Surrogate pair.\r\n                byteCount += size;\r\n            }\r\n        }\r\n        leftValue = part.value.slice(0, idx);\r\n        rightValue = part.value.slice(idx);\r\n        var newPart = {\r\n            value: rightValue,\r\n            utf8size: rightSize,\r\n            uses: part.uses.slice(),\r\n            startMeta: part.startMeta,\r\n            endMeta: part.endMeta\r\n        };\r\n        part.value = leftValue;\r\n        part.utf8size = leftSize;\r\n        for (var _i = 0, _a = part.uses; _i < _a.length; _i++) {\r\n            var use = _a[_i];\r\n            // Insert the new part.\r\n            var idx_1 = use.parts.indexOf(part);\r\n            if (idx_1 === -1)\r\n                throw new Error('bug: mismatch between string parts and use.');\r\n            use.parts.splice(idx_1 + 1, 0, newPart);\r\n        }\r\n    };\r\n    Model.prototype.stringAppendSlice = function (target, source, left, right) {\r\n        var str = this.asString(source);\r\n        var firstPart = this.resolveStringPart(str, 0, left);\r\n        var lastPart = this.resolveStringPart(str, firstPart, right - left);\r\n        for (var i = firstPart; i < lastPart; i++) {\r\n            var part = str.parts[i];\r\n            this.stringAppendPart(target, part);\r\n        }\r\n    };\r\n    return Model;\r\n}());\r\n// Turns a native JavaScript object into a Value with a given origin.\r\nfunction wrap(data, meta) {\r\n    return { data: data, startMeta: meta, endMeta: meta };\r\n}\r\n// Converts a Value into a native JavaScript type.\r\nfunction unwrap(value) {\r\n    if (typeof value.data !== 'undefined')\r\n        return value.data;\r\n    var result;\r\n    var content = value.content;\r\n    switch (content.type) {\r\n        case 'string':\r\n            result = content.parts.map(function (part) { return part.value; }).join('');\r\n            break;\r\n        case 'array':\r\n            result = content.elements.map(function (val) { return unwrap(val); });\r\n            break;\r\n        case 'object': {\r\n            result = {};\r\n            for (var _i = 0, _a = Object.entries(content.fields); _i < _a.length; _i++) {\r\n                var _b = _a[_i], key = _b[0], val = _b[1];\r\n                result[key] = unwrap(val);\r\n            }\r\n        }\r\n    }\r\n    value.data = result;\r\n    return result;\r\n}\r\n// Returns the type of a Value.\r\nfunction getType(value) {\r\n    if (value.content)\r\n        return value.content.type;\r\n    if (Array.isArray(value.data))\r\n        return 'array';\r\n    if (value.data === null)\r\n        return 'null';\r\n    return typeof value.data;\r\n}\r\n// Updates the `right` value such that it reuses as much as possible from the `left` value.\r\nfunction rebaseValue(left, right) {\r\n    var leftType = getType(left);\r\n    var rightType = getType(right);\r\n    if (leftType !== rightType)\r\n        return right;\r\n    var leftModel = new Model(left.endMeta);\r\n    var rightModel = new Model(right.endMeta);\r\n    switch (leftType) {\r\n        case 'object': {\r\n            var leftObj = leftModel.asObject(left);\r\n            var rightObj = rightModel.asObject(right);\r\n            // Number of fields which are identical in left and right.\r\n            var identicalFieldCount = 0;\r\n            var leftFieldCount = Object.keys(leftObj.fields).length;\r\n            var rightFieldCount = Object.keys(rightObj.fields).length;\r\n            for (var _i = 0, _a = Object.entries(rightObj.fields); _i < _a.length; _i++) {\r\n                var _b = _a[_i], key = _b[0], rightVal = _b[1];\r\n                var leftVal = leftObj.fields[key];\r\n                if (leftVal) {\r\n                    rightObj.fields[key] = rebaseValue(leftVal, rightVal);\r\n                    if (rightObj.fields[key] === leftVal) {\r\n                        identicalFieldCount++;\r\n                    }\r\n                }\r\n            }\r\n            var isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount;\r\n            return isIdentical ? left : right;\r\n        }\r\n        case 'array': {\r\n            var leftArr = leftModel.asArray(left);\r\n            var rightArr = rightModel.asArray(right);\r\n            if (leftArr.elements.length !== rightArr.elements.length) {\r\n                break;\r\n            }\r\n            var numRebased = 0;\r\n            for (var i = 0; i < rightArr.elements.length; i++) {\r\n                rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i]);\r\n                if (rightArr.elements[i] !== leftArr.elements[i]) {\r\n                    numRebased++;\r\n                }\r\n            }\r\n            return numRebased === 0 ? left : right;\r\n        }\r\n        case 'null':\r\n        case 'boolean':\r\n        case 'number': {\r\n            if (unwrap(left) === unwrap(right))\r\n                return left;\r\n            break;\r\n        }\r\n        case 'string': {\r\n            var leftRaw = unwrap(left);\r\n            var rightRaw = unwrap(right);\r\n            if (leftRaw === rightRaw)\r\n                return left;\r\n            var result = rightModel.copyString(null);\r\n            var prefix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonPrefix)(leftRaw, rightRaw);\r\n            var suffix = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.commonSuffix)(leftRaw, rightRaw, prefix);\r\n            var rightLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(rightRaw);\r\n            var leftLen = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8stringSize)(leftRaw);\r\n            if (0 < prefix) {\r\n                rightModel.stringAppendSlice(result, left, 0, prefix);\r\n            }\r\n            if (prefix < rightLen - suffix) {\r\n                rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix);\r\n            }\r\n            if (leftLen - suffix < leftLen) {\r\n                rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen);\r\n            }\r\n            var value = rightModel.finalize(result);\r\n            if (unwrap(value) !== rightRaw)\r\n                throw new Error('incorrect string rebase');\r\n            return value;\r\n        }\r\n    }\r\n    return right;\r\n}\r\nfunction applyPatch(left, patch, startMeta) {\r\n    var model = new Model(startMeta);\r\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(model, left, patch);\r\n    return patcher.process();\r\n}\r\n//# sourceMappingURL=incremental-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2QztBQUNxQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxnQkFBZ0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxtREFBbUQ7QUFDL0csbURBQW1ELG9CQUFvQjtBQUN2RSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxREFBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxxQkFBcUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsZ0JBQWdCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxnQkFBZ0I7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsc0JBQXNCO0FBQ2hEO0FBQ0EsMkJBQTJCLG1EQUFZO0FBQ3ZDO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsb0JBQW9CO0FBQzdFO0FBQ0E7QUFDQSwyREFBMkQscUJBQXFCO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxnQkFBZ0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsZ0JBQWdCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDhCQUE4QjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLG1EQUFZO0FBQ3JDLHlCQUF5QixtREFBWTtBQUNyQywyQkFBMkIscURBQWM7QUFDekMsMEJBQTBCLHFEQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luY3JlbWVudGFsLXBhdGNoZXIuanM/ZTZmYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYXRjaGVyIH0gZnJvbSAnLi9pbnRlcm5hbC1wYXRjaGVyJztcclxuaW1wb3J0IHsgdXRmOGNoYXJTaXplLCB1dGY4c3RyaW5nU2l6ZSwgY29tbW9uUHJlZml4LCBjb21tb25TdWZmaXggfSBmcm9tICcuL3V0ZjgnO1xyXG52YXIgTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBNb2RlbChtZXRhKSB7XHJcbiAgICAgICAgdGhpcy5tZXRhID0gbWV0YTtcclxuICAgIH1cclxuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53cmFwV2l0aE1ldGEoZGF0YSwgdGhpcy5tZXRhLCB0aGlzLm1ldGEpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS53cmFwV2l0aE1ldGEgPSBmdW5jdGlvbiAoZGF0YSwgc3RhcnRNZXRhLCBlbmRNZXRhKSB7XHJcbiAgICAgICAgaWYgKGVuZE1ldGEgPT09IHZvaWQgMCkgeyBlbmRNZXRhID0gdGhpcy5tZXRhOyB9XHJcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogZGF0YSwgc3RhcnRNZXRhOiBzdGFydE1ldGEsIGVuZE1ldGE6IGVuZE1ldGEgfTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoIXZhbHVlLmNvbnRlbnQpIHtcclxuICAgICAgICAgICAgdmFyIGZpZWxkcyA9IHt9O1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModmFsdWUuZGF0YSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGtleSA9IF9iWzBdLCB2YWwgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgIGZpZWxkc1trZXldID0gdGhpcy53cmFwV2l0aE1ldGEodmFsLCB2YWx1ZS5zdGFydE1ldGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB7IHR5cGU6ICdvYmplY3QnLCBmaWVsZHM6IGZpZWxkcyB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuYXNBcnJheSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IHZhbHVlLmRhdGEubWFwKGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBfdGhpcy53cmFwV2l0aE1ldGEoaXRlbSwgdmFsdWUuc3RhcnRNZXRhKTsgfSk7XHJcbiAgICAgICAgICAgIHZhciBtZXRhcyA9IGVsZW1lbnRzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5tZXRhOyB9KTtcclxuICAgICAgICAgICAgdmFsdWUuY29udGVudCA9IHsgdHlwZTogJ2FycmF5JywgZWxlbWVudHM6IGVsZW1lbnRzLCBtZXRhczogbWV0YXMgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmNvbnRlbnQ7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFzU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF2YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBzdHIgPSB2YWx1ZS5kYXRhO1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IHtcclxuICAgICAgICAgICAgICAgIHZhbHVlOiBzdHIsXHJcbiAgICAgICAgICAgICAgICB1dGY4c2l6ZTogdXRmOHN0cmluZ1NpemUoc3RyKSxcclxuICAgICAgICAgICAgICAgIHVzZXM6IFtdLFxyXG4gICAgICAgICAgICAgICAgc3RhcnRNZXRhOiB2YWx1ZS5zdGFydE1ldGEsXHJcbiAgICAgICAgICAgICAgICBlbmRNZXRhOiB2YWx1ZS5lbmRNZXRhXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHZhbHVlLmNvbnRlbnQgPSB0aGlzLnN0cmluZ0Zyb21QYXJ0cyhbcGFydF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudDtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuc3RyaW5nRnJvbVBhcnRzID0gZnVuY3Rpb24gKHBhcnRzKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXHJcbiAgICAgICAgICAgIHBhcnRzOiBwYXJ0c1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBwYXJ0c18xID0gcGFydHM7IF9pIDwgcGFydHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHBhcnQgPSBwYXJ0c18xW19pXTtcclxuICAgICAgICAgICAgcGFydC51c2VzLnB1c2goc3RyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUub2JqZWN0R2V0S2V5cyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZS5jb250ZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZS5jb250ZW50LmZpZWxkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUuZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3RHZXRGaWVsZCA9IGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuYXNPYmplY3QodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBvYmouZmllbGRzW2tleV07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5R2V0RWxlbWVudCA9IGZ1bmN0aW9uICh2YWx1ZSwgaWR4KSB7XHJcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuYXNBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIGFyci5lbGVtZW50c1tpZHhdO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKGNvbnRlbnQpO1xyXG4gICAgICAgIHJldHVybiB7IGNvbnRlbnQ6IGNvbnRlbnQsIHN0YXJ0TWV0YTogdGhpcy5tZXRhLCBlbmRNZXRhOiB0aGlzLm1ldGEgfTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUubWFya0NoYW5nZWQgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53cmFwKHVud3JhcCh2YWx1ZSkpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS51cGRhdGVFbmRNZXRhID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcclxuICAgICAgICBpZiAoY29udGVudC50eXBlID09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZW50LnBhcnRzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnQgPSBfYVtfaV07XHJcbiAgICAgICAgICAgICAgICBwYXJ0LmVuZE1ldGEgPSB0aGlzLm1ldGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjb250ZW50LnR5cGUgPT09ICdhcnJheScpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gMCwgX2MgPSBjb250ZW50LmVsZW1lbnRzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBfY1tfYl07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbC5jb250ZW50ICYmIHZhbC5lbmRNZXRhICE9PSB0aGlzLm1ldGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFbmRNZXRhKHZhbC5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmFsLmVuZE1ldGEgPSB0aGlzLm1ldGE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZCA9IDAsIF9lID0gT2JqZWN0LnZhbHVlcyhjb250ZW50LmZpZWxkcyk7IF9kIDwgX2UubGVuZ3RoOyBfZCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IF9lW19kXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsLmNvbnRlbnQgJiYgdmFsLmVuZE1ldGEgIT09IHRoaXMubWV0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUVuZE1ldGEodmFsLmNvbnRlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YWwuZW5kTWV0YSA9IHRoaXMubWV0YTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuY29weVN0cmluZyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzU3RyaW5nKHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nRnJvbVBhcnRzKG90aGVyLnBhcnRzLnNsaWNlKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxyXG4gICAgICAgICAgICAgICAgcGFydHM6IFtdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5T2JqZWN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9IHtcclxuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXHJcbiAgICAgICAgICAgIGZpZWxkczoge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2YWx1ZSkge1xyXG4gICAgICAgICAgICB2YXIgb3RoZXIgPSB0aGlzLmFzT2JqZWN0KHZhbHVlKTtcclxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvYmouZmllbGRzLCBvdGhlci5maWVsZHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5jb3B5QXJyYXkgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgYXJyID0gdmFsdWUgPyB0aGlzLmFzQXJyYXkodmFsdWUpIDogbnVsbDtcclxuICAgICAgICB2YXIgZWxlbWVudHMgPSBhcnIgPyBhcnIuZWxlbWVudHMgOiBbXTtcclxuICAgICAgICB2YXIgbWV0YXMgPSBhcnIgPyBhcnIubWV0YXMgOiBbXTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnYXJyYXknLFxyXG4gICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHMsXHJcbiAgICAgICAgICAgIG1ldGFzOiBtZXRhc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLm9iamVjdFNldEZpZWxkID0gZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRhcmdldC5maWVsZHNba2V5XSA9IHZhbHVlO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5vYmplY3REZWxldGVGaWVsZCA9IGZ1bmN0aW9uICh0YXJnZXQsIGtleSkge1xyXG4gICAgICAgIGRlbGV0ZSB0YXJnZXQuZmllbGRzW2tleV07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLmFycmF5QXBwZW5kVmFsdWUgPSBmdW5jdGlvbiAodGFyZ2V0LCB2YWx1ZSkge1xyXG4gICAgICAgIHRhcmdldC5lbGVtZW50cy5wdXNoKHZhbHVlKTtcclxuICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5hcnJheUFwcGVuZFNsaWNlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgdmFyIGFyciA9IHRoaXMuYXNBcnJheShzb3VyY2UpO1xyXG4gICAgICAgIHZhciBzYW1lUG9zaXRpb24gPSBhcnIuZWxlbWVudHMubGVuZ3RoID09PSBsZWZ0O1xyXG4gICAgICAgIChfYSA9IHRhcmdldC5lbGVtZW50cykucHVzaC5hcHBseShfYSwgYXJyLmVsZW1lbnRzLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XHJcbiAgICAgICAgaWYgKHNhbWVQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAoX2IgPSB0YXJnZXQubWV0YXMpLnB1c2guYXBwbHkoX2IsIGFyci5tZXRhcy5zbGljZShsZWZ0LCByaWdodCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IGxlZnQ7IGkgPCByaWdodDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQubWV0YXMucHVzaCh0aGlzLm1ldGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5zdHJpbmdBcHBlbmRWYWx1ZSA9IGZ1bmN0aW9uICh0YXJnZXQsIHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMuYXNTdHJpbmcodmFsdWUpO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzdHIucGFydHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gX2FbX2ldO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0FwcGVuZFBhcnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBwYXJ0KSB7XHJcbiAgICAgICAgdGFyZ2V0LnBhcnRzLnB1c2gocGFydCk7XHJcbiAgICAgICAgcGFydC51c2VzLnB1c2godGFyZ2V0KTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUucmVzb2x2ZVN0cmluZ1BhcnQgPSBmdW5jdGlvbiAoc3RyLCBmcm9tLCBsZW4pIHtcclxuICAgICAgICBpZiAobGVuID09PSAwKVxyXG4gICAgICAgICAgICByZXR1cm4gZnJvbTtcclxuICAgICAgICBmb3IgKHZhciBpID0gZnJvbTsgaSA8IHN0ci5wYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgcGFydCA9IHN0ci5wYXJ0c1tpXTtcclxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gcGFydC51dGY4c2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gTWF0Y2hlcyBwZXJmZWN0IVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgKyAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChsZW4gPCBwYXJ0LnV0ZjhzaXplKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJdCdzIGEgcGFydCBvZiB0aGlzIGNodW5rLiBXZSBub3cgbmVlZCB0byBzcGxpdCBpdCB1cC5cclxuICAgICAgICAgICAgICAgIHRoaXMuc3BsaXRTdHJpbmcocGFydCwgbGVuKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZW4gLT0gcGFydC51dGY4c2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdHRpbmcgc3RyaW5nIG91dCBvZiBib3VuZHMnKTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuc3BsaXRTdHJpbmcgPSBmdW5jdGlvbiAocGFydCwgaWR4KSB7XHJcbiAgICAgICAgdmFyIGxlZnRWYWx1ZTtcclxuICAgICAgICB2YXIgcmlnaHRWYWx1ZTtcclxuICAgICAgICB2YXIgbGVmdFNpemUgPSBpZHg7XHJcbiAgICAgICAgdmFyIHJpZ2h0U2l6ZSA9IHBhcnQudXRmOHNpemUgLSBsZWZ0U2l6ZTtcclxuICAgICAgICAvLyBpZHggaXMgaGVyZSBpbiBVVEYtOCBpbmRleCwgbm90IGNvZGVwb2ludCBpbmRleC5cclxuICAgICAgICAvLyBUaGlzIG1lYW5zIHdlIG1pZ2h0IHRvIGFkanVzdCBmb3IgbXVsdGktYnl0ZSBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGlmIChwYXJ0LnV0ZjhzaXplICE9PSBwYXJ0LnZhbHVlLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB2YXIgYnl0ZUNvdW50ID0gMDtcclxuICAgICAgICAgICAgZm9yIChpZHggPSAwOyBieXRlQ291bnQgPCBsZWZ0U2l6ZTsgaWR4KyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gcGFydC52YWx1ZS5jb2RlUG9pbnRBdChpZHgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZSA9PT0gNClcclxuICAgICAgICAgICAgICAgICAgICBpZHgrKzsgLy8gU3Vycm9nYXRlIHBhaXIuXHJcbiAgICAgICAgICAgICAgICBieXRlQ291bnQgKz0gc2l6ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBsZWZ0VmFsdWUgPSBwYXJ0LnZhbHVlLnNsaWNlKDAsIGlkeCk7XHJcbiAgICAgICAgcmlnaHRWYWx1ZSA9IHBhcnQudmFsdWUuc2xpY2UoaWR4KTtcclxuICAgICAgICB2YXIgbmV3UGFydCA9IHtcclxuICAgICAgICAgICAgdmFsdWU6IHJpZ2h0VmFsdWUsXHJcbiAgICAgICAgICAgIHV0ZjhzaXplOiByaWdodFNpemUsXHJcbiAgICAgICAgICAgIHVzZXM6IHBhcnQudXNlcy5zbGljZSgpLFxyXG4gICAgICAgICAgICBzdGFydE1ldGE6IHBhcnQuc3RhcnRNZXRhLFxyXG4gICAgICAgICAgICBlbmRNZXRhOiBwYXJ0LmVuZE1ldGFcclxuICAgICAgICB9O1xyXG4gICAgICAgIHBhcnQudmFsdWUgPSBsZWZ0VmFsdWU7XHJcbiAgICAgICAgcGFydC51dGY4c2l6ZSA9IGxlZnRTaXplO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBwYXJ0LnVzZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciB1c2UgPSBfYVtfaV07XHJcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGUgbmV3IHBhcnQuXHJcbiAgICAgICAgICAgIHZhciBpZHhfMSA9IHVzZS5wYXJ0cy5pbmRleE9mKHBhcnQpO1xyXG4gICAgICAgICAgICBpZiAoaWR4XzEgPT09IC0xKVxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdidWc6IG1pc21hdGNoIGJldHdlZW4gc3RyaW5nIHBhcnRzIGFuZCB1c2UuJyk7XHJcbiAgICAgICAgICAgIHVzZS5wYXJ0cy5zcGxpY2UoaWR4XzEgKyAxLCAwLCBuZXdQYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnN0cmluZ0FwcGVuZFNsaWNlID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHZhciBzdHIgPSB0aGlzLmFzU3RyaW5nKHNvdXJjZSk7XHJcbiAgICAgICAgdmFyIGZpcnN0UGFydCA9IHRoaXMucmVzb2x2ZVN0cmluZ1BhcnQoc3RyLCAwLCBsZWZ0KTtcclxuICAgICAgICB2YXIgbGFzdFBhcnQgPSB0aGlzLnJlc29sdmVTdHJpbmdQYXJ0KHN0ciwgZmlyc3RQYXJ0LCByaWdodCAtIGxlZnQpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSBmaXJzdFBhcnQ7IGkgPCBsYXN0UGFydDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJ0ID0gc3RyLnBhcnRzW2ldO1xyXG4gICAgICAgICAgICB0aGlzLnN0cmluZ0FwcGVuZFBhcnQodGFyZ2V0LCBwYXJ0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vZGVsO1xyXG59KCkpO1xyXG4vLyBUdXJucyBhIG5hdGl2ZSBKYXZhU2NyaXB0IG9iamVjdCBpbnRvIGEgVmFsdWUgd2l0aCBhIGdpdmVuIG9yaWdpbi5cclxuZXhwb3J0IGZ1bmN0aW9uIHdyYXAoZGF0YSwgbWV0YSkge1xyXG4gICAgcmV0dXJuIHsgZGF0YTogZGF0YSwgc3RhcnRNZXRhOiBtZXRhLCBlbmRNZXRhOiBtZXRhIH07XHJcbn1cclxuLy8gQ29udmVydHMgYSBWYWx1ZSBpbnRvIGEgbmF0aXZlIEphdmFTY3JpcHQgdHlwZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcCh2YWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5kYXRhICE9PSAndW5kZWZpbmVkJylcclxuICAgICAgICByZXR1cm4gdmFsdWUuZGF0YTtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICB2YXIgY29udGVudCA9IHZhbHVlLmNvbnRlbnQ7XHJcbiAgICBzd2l0Y2ggKGNvbnRlbnQudHlwZSkge1xyXG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGNvbnRlbnQucGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0KSB7IHJldHVybiBwYXJ0LnZhbHVlOyB9KS5qb2luKCcnKTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnYXJyYXknOlxyXG4gICAgICAgICAgICByZXN1bHQgPSBjb250ZW50LmVsZW1lbnRzLm1hcChmdW5jdGlvbiAodmFsKSB7IHJldHVybiB1bndyYXAodmFsKTsgfSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ29iamVjdCc6IHtcclxuICAgICAgICAgICAgcmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhjb250ZW50LmZpZWxkcyk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfYVtfaV0sIGtleSA9IF9iWzBdLCB2YWwgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdW53cmFwKHZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YWx1ZS5kYXRhID0gcmVzdWx0O1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG4vLyBSZXR1cm5zIHRoZSB0eXBlIG9mIGEgVmFsdWUuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XHJcbiAgICBpZiAodmFsdWUuY29udGVudClcclxuICAgICAgICByZXR1cm4gdmFsdWUuY29udGVudC50eXBlO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUuZGF0YSkpXHJcbiAgICAgICAgcmV0dXJuICdhcnJheSc7XHJcbiAgICBpZiAodmFsdWUuZGF0YSA9PT0gbnVsbClcclxuICAgICAgICByZXR1cm4gJ251bGwnO1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZS5kYXRhO1xyXG59XHJcbi8vIFVwZGF0ZXMgdGhlIGByaWdodGAgdmFsdWUgc3VjaCB0aGF0IGl0IHJldXNlcyBhcyBtdWNoIGFzIHBvc3NpYmxlIGZyb20gdGhlIGBsZWZ0YCB2YWx1ZS5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlYmFzZVZhbHVlKGxlZnQsIHJpZ2h0KSB7XHJcbiAgICB2YXIgbGVmdFR5cGUgPSBnZXRUeXBlKGxlZnQpO1xyXG4gICAgdmFyIHJpZ2h0VHlwZSA9IGdldFR5cGUocmlnaHQpO1xyXG4gICAgaWYgKGxlZnRUeXBlICE9PSByaWdodFR5cGUpXHJcbiAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgdmFyIGxlZnRNb2RlbCA9IG5ldyBNb2RlbChsZWZ0LmVuZE1ldGEpO1xyXG4gICAgdmFyIHJpZ2h0TW9kZWwgPSBuZXcgTW9kZWwocmlnaHQuZW5kTWV0YSk7XHJcbiAgICBzd2l0Y2ggKGxlZnRUeXBlKSB7XHJcbiAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xyXG4gICAgICAgICAgICB2YXIgbGVmdE9iaiA9IGxlZnRNb2RlbC5hc09iamVjdChsZWZ0KTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0T2JqID0gcmlnaHRNb2RlbC5hc09iamVjdChyaWdodCk7XHJcbiAgICAgICAgICAgIC8vIE51bWJlciBvZiBmaWVsZHMgd2hpY2ggYXJlIGlkZW50aWNhbCBpbiBsZWZ0IGFuZCByaWdodC5cclxuICAgICAgICAgICAgdmFyIGlkZW50aWNhbEZpZWxkQ291bnQgPSAwO1xyXG4gICAgICAgICAgICB2YXIgbGVmdEZpZWxkQ291bnQgPSBPYmplY3Qua2V5cyhsZWZ0T2JqLmZpZWxkcykubGVuZ3RoO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRGaWVsZENvdW50ID0gT2JqZWN0LmtleXMocmlnaHRPYmouZmllbGRzKS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBPYmplY3QuZW50cmllcyhyaWdodE9iai5maWVsZHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgcmlnaHRWYWwgPSBfYlsxXTtcclxuICAgICAgICAgICAgICAgIHZhciBsZWZ0VmFsID0gbGVmdE9iai5maWVsZHNba2V5XTtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRPYmouZmllbGRzW2tleV0gPSByZWJhc2VWYWx1ZShsZWZ0VmFsLCByaWdodFZhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpZ2h0T2JqLmZpZWxkc1trZXldID09PSBsZWZ0VmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWNhbEZpZWxkQ291bnQrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGlzSWRlbnRpY2FsID0gbGVmdEZpZWxkQ291bnQgPT09IHJpZ2h0RmllbGRDb3VudCAmJiBsZWZ0RmllbGRDb3VudCA9PT0gaWRlbnRpY2FsRmllbGRDb3VudDtcclxuICAgICAgICAgICAgcmV0dXJuIGlzSWRlbnRpY2FsID8gbGVmdCA6IHJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXNlICdhcnJheSc6IHtcclxuICAgICAgICAgICAgdmFyIGxlZnRBcnIgPSBsZWZ0TW9kZWwuYXNBcnJheShsZWZ0KTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0QXJyID0gcmlnaHRNb2RlbC5hc0FycmF5KHJpZ2h0KTtcclxuICAgICAgICAgICAgaWYgKGxlZnRBcnIuZWxlbWVudHMubGVuZ3RoICE9PSByaWdodEFyci5lbGVtZW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBudW1SZWJhc2VkID0gMDtcclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaWdodEFyci5lbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRBcnIuZWxlbWVudHNbaV0gPSByZWJhc2VWYWx1ZShsZWZ0QXJyLmVsZW1lbnRzW2ldLCByaWdodEFyci5lbGVtZW50c1tpXSk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRBcnIuZWxlbWVudHNbaV0gIT09IGxlZnRBcnIuZWxlbWVudHNbaV0pIHtcclxuICAgICAgICAgICAgICAgICAgICBudW1SZWJhc2VkKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bVJlYmFzZWQgPT09IDAgPyBsZWZ0IDogcmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ251bGwnOlxyXG4gICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxyXG4gICAgICAgIGNhc2UgJ251bWJlcic6IHtcclxuICAgICAgICAgICAgaWYgKHVud3JhcChsZWZ0KSA9PT0gdW53cmFwKHJpZ2h0KSlcclxuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xyXG4gICAgICAgICAgICB2YXIgbGVmdFJhdyA9IHVud3JhcChsZWZ0KTtcclxuICAgICAgICAgICAgdmFyIHJpZ2h0UmF3ID0gdW53cmFwKHJpZ2h0KTtcclxuICAgICAgICAgICAgaWYgKGxlZnRSYXcgPT09IHJpZ2h0UmF3KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQ7XHJcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSByaWdodE1vZGVsLmNvcHlTdHJpbmcobnVsbCk7XHJcbiAgICAgICAgICAgIHZhciBwcmVmaXggPSBjb21tb25QcmVmaXgobGVmdFJhdywgcmlnaHRSYXcpO1xyXG4gICAgICAgICAgICB2YXIgc3VmZml4ID0gY29tbW9uU3VmZml4KGxlZnRSYXcsIHJpZ2h0UmF3LCBwcmVmaXgpO1xyXG4gICAgICAgICAgICB2YXIgcmlnaHRMZW4gPSB1dGY4c3RyaW5nU2l6ZShyaWdodFJhdyk7XHJcbiAgICAgICAgICAgIHZhciBsZWZ0TGVuID0gdXRmOHN0cmluZ1NpemUobGVmdFJhdyk7XHJcbiAgICAgICAgICAgIGlmICgwIDwgcHJlZml4KSB7XHJcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgMCwgcHJlZml4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocHJlZml4IDwgcmlnaHRMZW4gLSBzdWZmaXgpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0TW9kZWwuc3RyaW5nQXBwZW5kU2xpY2UocmVzdWx0LCByaWdodCwgcHJlZml4LCByaWdodExlbiAtIHN1ZmZpeCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxlZnRMZW4gLSBzdWZmaXggPCBsZWZ0TGVuKSB7XHJcbiAgICAgICAgICAgICAgICByaWdodE1vZGVsLnN0cmluZ0FwcGVuZFNsaWNlKHJlc3VsdCwgbGVmdCwgbGVmdExlbiAtIHN1ZmZpeCwgbGVmdExlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmlnaHRNb2RlbC5maW5hbGl6ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICBpZiAodW53cmFwKHZhbHVlKSAhPT0gcmlnaHRSYXcpXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luY29ycmVjdCBzdHJpbmcgcmViYXNlJyk7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmlnaHQ7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGF0Y2gobGVmdCwgcGF0Y2gsIHN0YXJ0TWV0YSkge1xyXG4gICAgdmFyIG1vZGVsID0gbmV3IE1vZGVsKHN0YXJ0TWV0YSk7XHJcbiAgICB2YXIgcGF0Y2hlciA9IG5ldyBQYXRjaGVyKG1vZGVsLCBsZWZ0LCBwYXRjaCk7XHJcbiAgICByZXR1cm4gcGF0Y2hlci5wcm9jZXNzKCk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5jcmVtZW50YWwtcGF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/incremental-patcher.js\n");

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/index.js":
/*!***********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* reexport safe */ _simple_patcher__WEBPACK_IMPORTED_MODULE_1__.applyPatch; },\n/* harmony export */   \"incremental\": function() { return /* reexport module object */ _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__; }\n/* harmony export */ });\n/* harmony import */ var _incremental_patcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./incremental-patcher */ \"./node_modules/mendoza/lib/esm/incremental-patcher.js\");\n/* harmony import */ var _simple_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./simple-patcher */ \"./node_modules/mendoza/lib/esm/simple-patcher.js\");\n\r\n\r\n\r\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBdUQ7QUFDZjtBQUNNO0FBQzlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9tZW5kb3phL2xpYi9lc20vaW5kZXguanM/NGE1NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBpbmNyZW1lbnRhbF8xIGZyb20gJy4vaW5jcmVtZW50YWwtcGF0Y2hlcic7XHJcbmV4cG9ydCB7IGluY3JlbWVudGFsXzEgYXMgaW5jcmVtZW50YWwgfTtcclxuZXhwb3J0IHsgYXBwbHlQYXRjaCB9IGZyb20gJy4vc2ltcGxlLXBhdGNoZXInO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/index.js\n");

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/internal-patcher.js":
/*!**********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/internal-patcher.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Patcher\": function() { return /* binding */ Patcher; }\n/* harmony export */ });\nvar OPS = [\r\n    'Value',\r\n    'Copy',\r\n    'Blank',\r\n    'ReturnIntoArray',\r\n    'ReturnIntoObject',\r\n    'ReturnIntoObjectSameKey',\r\n    'PushField',\r\n    'PushElement',\r\n    'PushParent',\r\n    'Pop',\r\n    'PushFieldCopy',\r\n    'PushFieldBlank',\r\n    'PushElementCopy',\r\n    'PushElementBlank',\r\n    'ReturnIntoObjectPop',\r\n    'ReturnIntoObjectSameKeyPop',\r\n    'ReturnIntoArrayPop',\r\n    'ObjectSetFieldValue',\r\n    'ObjectCopyField',\r\n    'ObjectDeleteField',\r\n    'ArrayAppendValue',\r\n    'ArrayAppendSlice',\r\n    'StringAppendString',\r\n    'StringAppendSlice'\r\n];\r\nvar Patcher = /** @class */ (function () {\r\n    function Patcher(model, root, patch) {\r\n        this.i = 0;\r\n        this.inputStack = [];\r\n        this.outputStack = [];\r\n        this.model = model;\r\n        this.root = root;\r\n        this.patch = patch;\r\n    }\r\n    Patcher.prototype.read = function () {\r\n        return this.patch[this.i++];\r\n    };\r\n    Patcher.prototype.process = function () {\r\n        this.inputStack.push({ value: this.root });\r\n        this.outputStack.push({ value: this.root });\r\n        for (; this.i < this.patch.length;) {\r\n            var opcode = this.read();\r\n            var op = OPS[opcode];\r\n            if (!op)\r\n                throw new Error(\"Unknown opcode: \" + opcode);\r\n            var processor = \"process\" + op;\r\n            this[processor].apply(this);\r\n        }\r\n        var entry = this.outputStack.pop();\r\n        return this.finalizeOutput(entry);\r\n    };\r\n    Patcher.prototype.inputEntry = function () {\r\n        return this.inputStack[this.inputStack.length - 1];\r\n    };\r\n    Patcher.prototype.inputKey = function (entry, idx) {\r\n        if (!entry.keys) {\r\n            entry.keys = this.model.objectGetKeys(entry.value).sort();\r\n        }\r\n        return entry.keys[idx];\r\n    };\r\n    Patcher.prototype.outputEntry = function () {\r\n        return this.outputStack[this.outputStack.length - 1];\r\n    };\r\n    Patcher.prototype.outputArray = function () {\r\n        var entry = this.outputEntry();\r\n        if (!entry.writeValue) {\r\n            entry.writeValue = this.model.copyArray(entry.value);\r\n        }\r\n        return entry.writeValue;\r\n    };\r\n    Patcher.prototype.outputObject = function () {\r\n        var entry = this.outputEntry();\r\n        if (!entry.writeValue) {\r\n            entry.writeValue = this.model.copyObject(entry.value);\r\n        }\r\n        return entry.writeValue;\r\n    };\r\n    Patcher.prototype.outputString = function () {\r\n        var entry = this.outputEntry();\r\n        if (!entry.writeValue) {\r\n            entry.writeValue = this.model.copyString(entry.value);\r\n        }\r\n        return entry.writeValue;\r\n    };\r\n    Patcher.prototype.finalizeOutput = function (entry) {\r\n        if (entry.writeValue) {\r\n            return this.model.finalize(entry.writeValue);\r\n        }\r\n        else {\r\n            return entry.value;\r\n        }\r\n    };\r\n    // Processors:\r\n    Patcher.prototype.processValue = function () {\r\n        var value = this.model.wrap(this.read());\r\n        this.outputStack.push({ value: value });\r\n    };\r\n    Patcher.prototype.processCopy = function () {\r\n        var input = this.inputEntry();\r\n        this.outputStack.push({ value: input.value });\r\n    };\r\n    Patcher.prototype.processBlank = function () {\r\n        this.outputStack.push({ value: null });\r\n    };\r\n    Patcher.prototype.processReturnIntoArray = function () {\r\n        var entry = this.outputStack.pop();\r\n        var result = this.finalizeOutput(entry);\r\n        var arr = this.outputArray();\r\n        this.model.arrayAppendValue(arr, result);\r\n    };\r\n    Patcher.prototype.processReturnIntoObject = function () {\r\n        var key = this.read();\r\n        var entry = this.outputStack.pop();\r\n        var result = this.finalizeOutput(entry);\r\n        result = this.model.markChanged(result);\r\n        var obj = this.outputObject();\r\n        this.model.objectSetField(obj, key, result);\r\n    };\r\n    Patcher.prototype.processReturnIntoObjectSameKey = function () {\r\n        var input = this.inputEntry();\r\n        var entry = this.outputStack.pop();\r\n        var result = this.finalizeOutput(entry);\r\n        var obj = this.outputObject();\r\n        this.model.objectSetField(obj, input.key, result);\r\n    };\r\n    Patcher.prototype.processPushField = function () {\r\n        var idx = this.read();\r\n        var entry = this.inputEntry();\r\n        var key = this.inputKey(entry, idx);\r\n        var value = this.model.objectGetField(entry.value, key);\r\n        this.inputStack.push({ value: value, key: key });\r\n    };\r\n    Patcher.prototype.processPushElement = function () {\r\n        var idx = this.read();\r\n        var entry = this.inputEntry();\r\n        var value = this.model.arrayGetElement(entry.value, idx);\r\n        this.inputStack.push({ value: value });\r\n    };\r\n    Patcher.prototype.processPop = function () {\r\n        this.inputStack.pop();\r\n    };\r\n    Patcher.prototype.processPushFieldCopy = function () {\r\n        this.processPushField();\r\n        this.processCopy();\r\n    };\r\n    Patcher.prototype.processPushFieldBlank = function () {\r\n        this.processPushField();\r\n        this.processBlank();\r\n    };\r\n    Patcher.prototype.processPushElementCopy = function () {\r\n        this.processPushElement();\r\n        this.processCopy();\r\n    };\r\n    Patcher.prototype.processPushElementBlank = function () {\r\n        this.processPushElement();\r\n        this.processBlank();\r\n    };\r\n    Patcher.prototype.processReturnIntoObjectPop = function () {\r\n        this.processReturnIntoObject();\r\n        this.processPop();\r\n    };\r\n    Patcher.prototype.processReturnIntoObjectSameKeyPop = function () {\r\n        this.processReturnIntoObjectSameKey();\r\n        this.processPop();\r\n    };\r\n    Patcher.prototype.processReturnIntoArrayPop = function () {\r\n        this.processReturnIntoArray();\r\n        this.processPop();\r\n    };\r\n    Patcher.prototype.processObjectSetFieldValue = function () {\r\n        this.processValue();\r\n        this.processReturnIntoObject();\r\n    };\r\n    Patcher.prototype.processObjectCopyField = function () {\r\n        this.processPushField();\r\n        this.processCopy();\r\n        this.processReturnIntoObjectSameKey();\r\n        this.processPop();\r\n    };\r\n    Patcher.prototype.processObjectDeleteField = function () {\r\n        var idx = this.read();\r\n        var entry = this.inputEntry();\r\n        var key = this.inputKey(entry, idx);\r\n        var obj = this.outputObject();\r\n        this.model.objectDeleteField(obj, key);\r\n    };\r\n    Patcher.prototype.processArrayAppendValue = function () {\r\n        var value = this.model.wrap(this.read());\r\n        var arr = this.outputArray();\r\n        this.model.arrayAppendValue(arr, value);\r\n    };\r\n    Patcher.prototype.processArrayAppendSlice = function () {\r\n        var left = this.read();\r\n        var right = this.read();\r\n        var str = this.outputArray();\r\n        var val = this.inputEntry().value;\r\n        this.model.arrayAppendSlice(str, val, left, right);\r\n    };\r\n    Patcher.prototype.processStringAppendString = function () {\r\n        var value = this.model.wrap(this.read());\r\n        var str = this.outputString();\r\n        this.model.stringAppendValue(str, value);\r\n    };\r\n    Patcher.prototype.processStringAppendSlice = function () {\r\n        var left = this.read();\r\n        var right = this.read();\r\n        var str = this.outputString();\r\n        var val = this.inputEntry().value;\r\n        this.model.stringAppendSlice(str, val, left, right);\r\n    };\r\n    return Patcher;\r\n}());\r\n\r\n//# sourceMappingURL=internal-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQsZ0NBQWdDLGtCQUFrQjtBQUNsRCxlQUFlLDJCQUEyQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0JBQXdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNrQjtBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL2ludGVybmFsLXBhdGNoZXIuanM/YjYyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgT1BTID0gW1xyXG4gICAgJ1ZhbHVlJyxcclxuICAgICdDb3B5JyxcclxuICAgICdCbGFuaycsXHJcbiAgICAnUmV0dXJuSW50b0FycmF5JyxcclxuICAgICdSZXR1cm5JbnRvT2JqZWN0JyxcclxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleScsXHJcbiAgICAnUHVzaEZpZWxkJyxcclxuICAgICdQdXNoRWxlbWVudCcsXHJcbiAgICAnUHVzaFBhcmVudCcsXHJcbiAgICAnUG9wJyxcclxuICAgICdQdXNoRmllbGRDb3B5JyxcclxuICAgICdQdXNoRmllbGRCbGFuaycsXHJcbiAgICAnUHVzaEVsZW1lbnRDb3B5JyxcclxuICAgICdQdXNoRWxlbWVudEJsYW5rJyxcclxuICAgICdSZXR1cm5JbnRvT2JqZWN0UG9wJyxcclxuICAgICdSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCcsXHJcbiAgICAnUmV0dXJuSW50b0FycmF5UG9wJyxcclxuICAgICdPYmplY3RTZXRGaWVsZFZhbHVlJyxcclxuICAgICdPYmplY3RDb3B5RmllbGQnLFxyXG4gICAgJ09iamVjdERlbGV0ZUZpZWxkJyxcclxuICAgICdBcnJheUFwcGVuZFZhbHVlJyxcclxuICAgICdBcnJheUFwcGVuZFNsaWNlJyxcclxuICAgICdTdHJpbmdBcHBlbmRTdHJpbmcnLFxyXG4gICAgJ1N0cmluZ0FwcGVuZFNsaWNlJ1xyXG5dO1xyXG52YXIgUGF0Y2hlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFBhdGNoZXIobW9kZWwsIHJvb3QsIHBhdGNoKSB7XHJcbiAgICAgICAgdGhpcy5pID0gMDtcclxuICAgICAgICB0aGlzLmlucHV0U3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLm91dHB1dFN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5tb2RlbCA9IG1vZGVsO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IHJvb3Q7XHJcbiAgICAgICAgdGhpcy5wYXRjaCA9IHBhdGNoO1xyXG4gICAgfVxyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wYXRjaFt0aGlzLmkrK107XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2VzcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB0aGlzLnJvb3QgfSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IHRoaXMucm9vdCB9KTtcclxuICAgICAgICBmb3IgKDsgdGhpcy5pIDwgdGhpcy5wYXRjaC5sZW5ndGg7KSB7XHJcbiAgICAgICAgICAgIHZhciBvcGNvZGUgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICAgICAgdmFyIG9wID0gT1BTW29wY29kZV07XHJcbiAgICAgICAgICAgIGlmICghb3ApXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIG9wY29kZTogXCIgKyBvcGNvZGUpO1xyXG4gICAgICAgICAgICB2YXIgcHJvY2Vzc29yID0gXCJwcm9jZXNzXCIgKyBvcDtcclxuICAgICAgICAgICAgdGhpc1twcm9jZXNzb3JdLmFwcGx5KHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLm91dHB1dFN0YWNrLnBvcCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZpbmFsaXplT3V0cHV0KGVudHJ5KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5pbnB1dEVudHJ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0U3RhY2tbdGhpcy5pbnB1dFN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLmlucHV0S2V5ID0gZnVuY3Rpb24gKGVudHJ5LCBpZHgpIHtcclxuICAgICAgICBpZiAoIWVudHJ5LmtleXMpIHtcclxuICAgICAgICAgICAgZW50cnkua2V5cyA9IHRoaXMubW9kZWwub2JqZWN0R2V0S2V5cyhlbnRyeS52YWx1ZSkuc29ydCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW50cnkua2V5c1tpZHhdO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLm91dHB1dEVudHJ5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dFN0YWNrW3RoaXMub3V0cHV0U3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0QXJyYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xyXG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5QXJyYXkoZW50cnkudmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW50cnkud3JpdGVWYWx1ZTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5vdXRwdXRPYmplY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRFbnRyeSgpO1xyXG4gICAgICAgIGlmICghZW50cnkud3JpdGVWYWx1ZSkge1xyXG4gICAgICAgICAgICBlbnRyeS53cml0ZVZhbHVlID0gdGhpcy5tb2RlbC5jb3B5T2JqZWN0KGVudHJ5LnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGVudHJ5LndyaXRlVmFsdWU7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUub3V0cHV0U3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0RW50cnkoKTtcclxuICAgICAgICBpZiAoIWVudHJ5LndyaXRlVmFsdWUpIHtcclxuICAgICAgICAgICAgZW50cnkud3JpdGVWYWx1ZSA9IHRoaXMubW9kZWwuY29weVN0cmluZyhlbnRyeS52YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbnRyeS53cml0ZVZhbHVlO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLmZpbmFsaXplT3V0cHV0ID0gZnVuY3Rpb24gKGVudHJ5KSB7XHJcbiAgICAgICAgaWYgKGVudHJ5LndyaXRlVmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kZWwuZmluYWxpemUoZW50cnkud3JpdGVWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50cnkudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFByb2Nlc3NvcnM6XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC53cmFwKHRoaXMucmVhZCgpKTtcclxuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUgfSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0NvcHkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5pbnB1dEVudHJ5KCk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXRTdGFjay5wdXNoKHsgdmFsdWU6IGlucHV0LnZhbHVlIH0pO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NCbGFuayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLm91dHB1dFN0YWNrLnB1c2goeyB2YWx1ZTogbnVsbCB9KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xyXG4gICAgICAgIHZhciBhcnIgPSB0aGlzLm91dHB1dEFycmF5KCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5hcnJheUFwcGVuZFZhbHVlKGFyciwgcmVzdWx0KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUmV0dXJuSW50b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIga2V5ID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5vdXRwdXRTdGFjay5wb3AoKTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5maW5hbGl6ZU91dHB1dChlbnRyeSk7XHJcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5tb2RlbC5tYXJrQ2hhbmdlZChyZXN1bHQpO1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBrZXksIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1JldHVybkludG9PYmplY3RTYW1lS2V5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbnB1dCA9IHRoaXMuaW5wdXRFbnRyeSgpO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMub3V0cHV0U3RhY2sucG9wKCk7XHJcbiAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuZmluYWxpemVPdXRwdXQoZW50cnkpO1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0U2V0RmllbGQob2JqLCBpbnB1dC5rZXksIHJlc3VsdCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5yZWFkKCk7XHJcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5pbnB1dEVudHJ5KCk7XHJcbiAgICAgICAgdmFyIGtleSA9IHRoaXMuaW5wdXRLZXkoZW50cnksIGlkeCk7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gdGhpcy5tb2RlbC5vYmplY3RHZXRGaWVsZChlbnRyeS52YWx1ZSwga2V5KTtcclxuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSwga2V5OiBrZXkgfSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpZHggPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLmlucHV0RW50cnkoKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm1vZGVsLmFycmF5R2V0RWxlbWVudChlbnRyeS52YWx1ZSwgaWR4KTtcclxuICAgICAgICB0aGlzLmlucHV0U3RhY2sucHVzaCh7IHZhbHVlOiB2YWx1ZSB9KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaW5wdXRTdGFjay5wb3AoKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEZpZWxkQ29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hGaWVsZEJsYW5rID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1B1c2hGaWVsZCgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1B1c2hFbGVtZW50Q29weSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0NvcHkoKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzUHVzaEVsZW1lbnRCbGFuayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc0JsYW5rKCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc1JldHVybkludG9PYmplY3RQb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdCgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleVBvcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0U2FtZUtleSgpO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1BvcCgpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NSZXR1cm5JbnRvQXJyYXlQb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b0FycmF5KCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUG9wKCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc09iamVjdFNldEZpZWxkVmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzVmFsdWUoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NSZXR1cm5JbnRvT2JqZWN0KCk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc09iamVjdENvcHlGaWVsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQdXNoRmllbGQoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NDb3B5KCk7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmV0dXJuSW50b09iamVjdFNhbWVLZXkoKTtcclxuICAgICAgICB0aGlzLnByb2Nlc3NQb3AoKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzT2JqZWN0RGVsZXRlRmllbGQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkeCA9IHRoaXMucmVhZCgpO1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuaW5wdXRFbnRyeSgpO1xyXG4gICAgICAgIHZhciBrZXkgPSB0aGlzLmlucHV0S2V5KGVudHJ5LCBpZHgpO1xyXG4gICAgICAgIHZhciBvYmogPSB0aGlzLm91dHB1dE9iamVjdCgpO1xyXG4gICAgICAgIHRoaXMubW9kZWwub2JqZWN0RGVsZXRlRmllbGQob2JqLCBrZXkpO1xyXG4gICAgfTtcclxuICAgIFBhdGNoZXIucHJvdG90eXBlLnByb2Nlc3NBcnJheUFwcGVuZFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XHJcbiAgICAgICAgdmFyIGFyciA9IHRoaXMub3V0cHV0QXJyYXkoKTtcclxuICAgICAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kVmFsdWUoYXJyLCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgUGF0Y2hlci5wcm90b3R5cGUucHJvY2Vzc0FycmF5QXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRBcnJheSgpO1xyXG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmlucHV0RW50cnkoKS52YWx1ZTtcclxuICAgICAgICB0aGlzLm1vZGVsLmFycmF5QXBwZW5kU2xpY2Uoc3RyLCB2YWwsIGxlZnQsIHJpZ2h0KTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU3RyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMubW9kZWwud3JhcCh0aGlzLnJlYWQoKSk7XHJcbiAgICAgICAgdmFyIHN0ciA9IHRoaXMub3V0cHV0U3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRWYWx1ZShzdHIsIHZhbHVlKTtcclxuICAgIH07XHJcbiAgICBQYXRjaGVyLnByb3RvdHlwZS5wcm9jZXNzU3RyaW5nQXBwZW5kU2xpY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgcmlnaHQgPSB0aGlzLnJlYWQoKTtcclxuICAgICAgICB2YXIgc3RyID0gdGhpcy5vdXRwdXRTdHJpbmcoKTtcclxuICAgICAgICB2YXIgdmFsID0gdGhpcy5pbnB1dEVudHJ5KCkudmFsdWU7XHJcbiAgICAgICAgdGhpcy5tb2RlbC5zdHJpbmdBcHBlbmRTbGljZShzdHIsIHZhbCwgbGVmdCwgcmlnaHQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBQYXRjaGVyO1xyXG59KCkpO1xyXG5leHBvcnQgeyBQYXRjaGVyIH07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVybmFsLXBhdGNoZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/internal-patcher.js\n");

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/simple-patcher.js":
/*!********************************************************!*\
  !*** ./node_modules/mendoza/lib/esm/simple-patcher.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"applyPatch\": function() { return /* binding */ applyPatch; }\n/* harmony export */ });\n/* harmony import */ var _internal_patcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal-patcher */ \"./node_modules/mendoza/lib/esm/internal-patcher.js\");\n/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ \"./node_modules/mendoza/lib/esm/utf8.js\");\n\r\n\r\nvar Model = {\r\n    wrap: function (data) {\r\n        return data;\r\n    },\r\n    finalize: function (b) {\r\n        if (Array.isArray(b)) {\r\n            return b;\r\n        }\r\n        else {\r\n            return b.data;\r\n        }\r\n    },\r\n    markChanged: function (value) {\r\n        return value;\r\n    },\r\n    objectGetKeys: function (value) {\r\n        return Object.keys(value);\r\n    },\r\n    objectGetField: function (value, key) {\r\n        return value[key];\r\n    },\r\n    arrayGetElement: function (value, idx) {\r\n        return value[idx];\r\n    },\r\n    copyObject: function (value) {\r\n        var res = {\r\n            type: 'object',\r\n            data: {}\r\n        };\r\n        if (value !== null) {\r\n            for (var _i = 0, _a = Object.entries(value); _i < _a.length; _i++) {\r\n                var _b = _a[_i], key = _b[0], val = _b[1];\r\n                res.data[key] = val;\r\n            }\r\n        }\r\n        return res;\r\n    },\r\n    copyArray: function (value) {\r\n        if (value === null)\r\n            return [];\r\n        return value.slice();\r\n    },\r\n    copyString: function (value) {\r\n        return {\r\n            type: 'string',\r\n            data: value === null ? '' : value\r\n        };\r\n    },\r\n    objectSetField: function (target, key, value) {\r\n        target.data[key] = value;\r\n    },\r\n    objectDeleteField: function (target, key) {\r\n        delete target.data[key];\r\n    },\r\n    arrayAppendValue: function (target, value) {\r\n        target.push(value);\r\n    },\r\n    arrayAppendSlice: function (target, source, left, right) {\r\n        target.push.apply(target, source.slice(left, right));\r\n    },\r\n    stringAppendSlice: function (target, source, left, right) {\r\n        var sourceString = source;\r\n        var leftPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, left);\r\n        var rightPos = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.utf8resolveIndex)(sourceString, right, leftPos);\r\n        target.data += sourceString.slice(leftPos, rightPos);\r\n    },\r\n    stringAppendValue: function (target, value) {\r\n        target.data += value;\r\n    }\r\n};\r\n// Applies a patch on a JavaScript object.\r\nfunction applyPatch(left, patch) {\r\n    var root = left; // No need to wrap because the representation is the same.\r\n    var patcher = new _internal_patcher__WEBPACK_IMPORTED_MODULE_1__.Patcher(Model, root, patch);\r\n    return patcher.process();\r\n}\r\n//# sourceMappingURL=simple-patcher.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QztBQUNIO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxnQkFBZ0I7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNCQUFzQix1REFBZ0I7QUFDdEMsdUJBQXVCLHVEQUFnQjtBQUN2QztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxxQkFBcUI7QUFDckIsc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3NpbXBsZS1wYXRjaGVyLmpzPzY5YjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGF0Y2hlciB9IGZyb20gJy4vaW50ZXJuYWwtcGF0Y2hlcic7XHJcbmltcG9ydCB7IHV0ZjhyZXNvbHZlSW5kZXggfSBmcm9tICcuL3V0ZjgnO1xyXG52YXIgTW9kZWwgPSB7XHJcbiAgICB3cmFwOiBmdW5jdGlvbiAoZGF0YSkge1xyXG4gICAgICAgIHJldHVybiBkYXRhO1xyXG4gICAgfSxcclxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoYikge1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGIuZGF0YTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbWFya0NoYW5nZWQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBvYmplY3RHZXRLZXlzOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpO1xyXG4gICAgfSxcclxuICAgIG9iamVjdEdldEZpZWxkOiBmdW5jdGlvbiAodmFsdWUsIGtleSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xyXG4gICAgfSxcclxuICAgIGFycmF5R2V0RWxlbWVudDogZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWVbaWR4XTtcclxuICAgIH0sXHJcbiAgICBjb3B5T2JqZWN0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICB2YXIgcmVzID0ge1xyXG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcclxuICAgICAgICAgICAgZGF0YToge31cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmVudHJpZXModmFsdWUpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX2FbX2ldLCBrZXkgPSBfYlswXSwgdmFsID0gX2JbMV07XHJcbiAgICAgICAgICAgICAgICByZXMuZGF0YVtrZXldID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9LFxyXG4gICAgY29weUFycmF5OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICByZXR1cm4gdmFsdWUuc2xpY2UoKTtcclxuICAgIH0sXHJcbiAgICBjb3B5U3RyaW5nOiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcclxuICAgICAgICAgICAgZGF0YTogdmFsdWUgPT09IG51bGwgPyAnJyA6IHZhbHVlXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBvYmplY3RTZXRGaWVsZDogZnVuY3Rpb24gKHRhcmdldCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHRhcmdldC5kYXRhW2tleV0gPSB2YWx1ZTtcclxuICAgIH0sXHJcbiAgICBvYmplY3REZWxldGVGaWVsZDogZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7XHJcbiAgICAgICAgZGVsZXRlIHRhcmdldC5kYXRhW2tleV07XHJcbiAgICB9LFxyXG4gICAgYXJyYXlBcHBlbmRWYWx1ZTogZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcclxuICAgICAgICB0YXJnZXQucHVzaCh2YWx1ZSk7XHJcbiAgICB9LFxyXG4gICAgYXJyYXlBcHBlbmRTbGljZTogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHRhcmdldC5wdXNoLmFwcGx5KHRhcmdldCwgc291cmNlLnNsaWNlKGxlZnQsIHJpZ2h0KSk7XHJcbiAgICB9LFxyXG4gICAgc3RyaW5nQXBwZW5kU2xpY2U6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB2YXIgc291cmNlU3RyaW5nID0gc291cmNlO1xyXG4gICAgICAgIHZhciBsZWZ0UG9zID0gdXRmOHJlc29sdmVJbmRleChzb3VyY2VTdHJpbmcsIGxlZnQpO1xyXG4gICAgICAgIHZhciByaWdodFBvcyA9IHV0ZjhyZXNvbHZlSW5kZXgoc291cmNlU3RyaW5nLCByaWdodCwgbGVmdFBvcyk7XHJcbiAgICAgICAgdGFyZ2V0LmRhdGEgKz0gc291cmNlU3RyaW5nLnNsaWNlKGxlZnRQb3MsIHJpZ2h0UG9zKTtcclxuICAgIH0sXHJcbiAgICBzdHJpbmdBcHBlbmRWYWx1ZTogZnVuY3Rpb24gKHRhcmdldCwgdmFsdWUpIHtcclxuICAgICAgICB0YXJnZXQuZGF0YSArPSB2YWx1ZTtcclxuICAgIH1cclxufTtcclxuLy8gQXBwbGllcyBhIHBhdGNoIG9uIGEgSmF2YVNjcmlwdCBvYmplY3QuXHJcbmV4cG9ydCBmdW5jdGlvbiBhcHBseVBhdGNoKGxlZnQsIHBhdGNoKSB7XHJcbiAgICB2YXIgcm9vdCA9IGxlZnQ7IC8vIE5vIG5lZWQgdG8gd3JhcCBiZWNhdXNlIHRoZSByZXByZXNlbnRhdGlvbiBpcyB0aGUgc2FtZS5cclxuICAgIHZhciBwYXRjaGVyID0gbmV3IFBhdGNoZXIoTW9kZWwsIHJvb3QsIHBhdGNoKTtcclxuICAgIHJldHVybiBwYXRjaGVyLnByb2Nlc3MoKTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaW1wbGUtcGF0Y2hlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/simple-patcher.js\n");

/***/ }),

/***/ "./node_modules/mendoza/lib/esm/utf8.js":
/*!**********************************************!*\
  !*** ./node_modules/mendoza/lib/esm/utf8.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"commonPrefix\": function() { return /* binding */ commonPrefix; },\n/* harmony export */   \"commonSuffix\": function() { return /* binding */ commonSuffix; },\n/* harmony export */   \"utf8charSize\": function() { return /* binding */ utf8charSize; },\n/* harmony export */   \"utf8resolveIndex\": function() { return /* binding */ utf8resolveIndex; },\n/* harmony export */   \"utf8stringSize\": function() { return /* binding */ utf8stringSize; }\n/* harmony export */ });\nfunction utf8charSize(code) {\r\n    if (code >> 16) {\r\n        return 4;\r\n    }\r\n    else if (code >> 11) {\r\n        return 3;\r\n    }\r\n    else if (code >> 7) {\r\n        return 2;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n}\r\nfunction utf8stringSize(str) {\r\n    var b = 0;\r\n    for (var i = 0; i < str.length; i++) {\r\n        var code = str.codePointAt(i);\r\n        var size = utf8charSize(code);\r\n        if (size == 4)\r\n            i++;\r\n        b += size;\r\n    }\r\n    return b;\r\n}\r\n/** Converts an UTF-8 byte index into a UCS-2 index. */\r\nfunction utf8resolveIndex(str, idx, start) {\r\n    if (start === void 0) { start = 0; }\r\n    var byteCount = start;\r\n    var ucsIdx = 0;\r\n    for (ucsIdx = start; byteCount < idx; ucsIdx++) {\r\n        var code = str.codePointAt(ucsIdx);\r\n        var size = utf8charSize(code);\r\n        if (size === 4)\r\n            ucsIdx++; // Surrogate pair.\r\n        byteCount += size;\r\n    }\r\n    return ucsIdx;\r\n}\r\nfunction commonPrefix(str, str2) {\r\n    var len = Math.min(str.length, str2.length);\r\n    var b = 0;\r\n    for (var i = 0; i < len;) {\r\n        var aPoint = str.codePointAt(i);\r\n        var bPoint = str2.codePointAt(i);\r\n        if (aPoint !== bPoint)\r\n            return b;\r\n        var size = utf8charSize(aPoint);\r\n        b += size;\r\n        i += size === 4 ? 2 : 1;\r\n    }\r\n    return b;\r\n}\r\nfunction commonSuffix(str, str2, prefix) {\r\n    if (prefix === void 0) { prefix = 0; }\r\n    var len = Math.min(str.length, str2.length) - prefix;\r\n    var b = 0;\r\n    for (var i = 0; i < len;) {\r\n        var aPoint = str.codePointAt(str.length - 1 - i);\r\n        var bPoint = str2.codePointAt(str2.length - 1 - i);\r\n        if (aPoint !== bPoint)\r\n            return b;\r\n        var size = utf8charSize(aPoint);\r\n        b += size;\r\n        i += size === 4 ? 2 : 1;\r\n    }\r\n    return b;\r\n}\r\n//# sourceMappingURL=utf8.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbWVuZG96YS9saWIvZXNtL3V0ZjguanM/ZWM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gdXRmOGNoYXJTaXplKGNvZGUpIHtcclxuICAgIGlmIChjb2RlID4+IDE2KSB7XHJcbiAgICAgICAgcmV0dXJuIDQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID4+IDExKSB7XHJcbiAgICAgICAgcmV0dXJuIDM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChjb2RlID4+IDcpIHtcclxuICAgICAgICByZXR1cm4gMjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiB1dGY4c3RyaW5nU2l6ZShzdHIpIHtcclxuICAgIHZhciBiID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY29kZVBvaW50QXQoaSk7XHJcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XHJcbiAgICAgICAgaWYgKHNpemUgPT0gNClcclxuICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgIGIgKz0gc2l6ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBiO1xyXG59XHJcbi8qKiBDb252ZXJ0cyBhbiBVVEYtOCBieXRlIGluZGV4IGludG8gYSBVQ1MtMiBpbmRleC4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhyZXNvbHZlSW5kZXgoc3RyLCBpZHgsIHN0YXJ0KSB7XHJcbiAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IDA7IH1cclxuICAgIHZhciBieXRlQ291bnQgPSBzdGFydDtcclxuICAgIHZhciB1Y3NJZHggPSAwO1xyXG4gICAgZm9yICh1Y3NJZHggPSBzdGFydDsgYnl0ZUNvdW50IDwgaWR4OyB1Y3NJZHgrKykge1xyXG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNvZGVQb2ludEF0KHVjc0lkeCk7XHJcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoY29kZSk7XHJcbiAgICAgICAgaWYgKHNpemUgPT09IDQpXHJcbiAgICAgICAgICAgIHVjc0lkeCsrOyAvLyBTdXJyb2dhdGUgcGFpci5cclxuICAgICAgICBieXRlQ291bnQgKz0gc2l6ZTtcclxuICAgIH1cclxuICAgIHJldHVybiB1Y3NJZHg7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbW1vblByZWZpeChzdHIsIHN0cjIpIHtcclxuICAgIHZhciBsZW4gPSBNYXRoLm1pbihzdHIubGVuZ3RoLCBzdHIyLmxlbmd0aCk7XHJcbiAgICB2YXIgYiA9IDA7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjspIHtcclxuICAgICAgICB2YXIgYVBvaW50ID0gc3RyLmNvZGVQb2ludEF0KGkpO1xyXG4gICAgICAgIHZhciBiUG9pbnQgPSBzdHIyLmNvZGVQb2ludEF0KGkpO1xyXG4gICAgICAgIGlmIChhUG9pbnQgIT09IGJQb2ludClcclxuICAgICAgICAgICAgcmV0dXJuIGI7XHJcbiAgICAgICAgdmFyIHNpemUgPSB1dGY4Y2hhclNpemUoYVBvaW50KTtcclxuICAgICAgICBiICs9IHNpemU7XHJcbiAgICAgICAgaSArPSBzaXplID09PSA0ID8gMiA6IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYjtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gY29tbW9uU3VmZml4KHN0ciwgc3RyMiwgcHJlZml4KSB7XHJcbiAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHsgcHJlZml4ID0gMDsgfVxyXG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIHN0cjIubGVuZ3RoKSAtIHByZWZpeDtcclxuICAgIHZhciBiID0gMDtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOykge1xyXG4gICAgICAgIHZhciBhUG9pbnQgPSBzdHIuY29kZVBvaW50QXQoc3RyLmxlbmd0aCAtIDEgLSBpKTtcclxuICAgICAgICB2YXIgYlBvaW50ID0gc3RyMi5jb2RlUG9pbnRBdChzdHIyLmxlbmd0aCAtIDEgLSBpKTtcclxuICAgICAgICBpZiAoYVBvaW50ICE9PSBiUG9pbnQpXHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIHZhciBzaXplID0gdXRmOGNoYXJTaXplKGFQb2ludCk7XHJcbiAgICAgICAgYiArPSBzaXplO1xyXG4gICAgICAgIGkgKz0gc2l6ZSA9PT0gNCA/IDIgOiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGI7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRmOC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mendoza/lib/esm/utf8.js\n");

/***/ }),

/***/ "./node_modules/throttle-debounce/cjs/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/throttle-debounce/cjs/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";
eval("\r\n\r\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\r\n\r\n/* eslint-disable no-undefined,no-param-reassign,no-shadow */\r\n\r\n/**\r\n * Throttle execution of a function. Especially useful for rate limiting\r\n * execution of handlers on events like resize and scroll.\r\n *\r\n * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\r\n * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the\r\n *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time\r\n *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,\r\n *                                    the internal counter is reset).\r\n * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\r\n *                                    to `callback` when the throttled-function is executed.\r\n * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),\r\n *                                    schedule `callback` to execute after `delay` ms.\r\n *\r\n * @returns {Function}  A new, throttled, function.\r\n */\r\nfunction throttle (delay, noTrailing, callback, debounceMode) {\r\n  /*\r\n   * After wrapper has stopped being called, this timeout ensures that\r\n   * `callback` is executed at the proper times in `throttle` and `end`\r\n   * debounce modes.\r\n   */\r\n  var timeoutID;\r\n  var cancelled = false; // Keep track of the last time `callback` was executed.\r\n\r\n  var lastExec = 0; // Function to clear existing timeout\r\n\r\n  function clearExistingTimeout() {\r\n    if (timeoutID) {\r\n      clearTimeout(timeoutID);\r\n    }\r\n  } // Function to cancel next exec\r\n\r\n\r\n  function cancel() {\r\n    clearExistingTimeout();\r\n    cancelled = true;\r\n  } // `noTrailing` defaults to falsy.\r\n\r\n\r\n  if (typeof noTrailing !== 'boolean') {\r\n    debounceMode = callback;\r\n    callback = noTrailing;\r\n    noTrailing = undefined;\r\n  }\r\n  /*\r\n   * The `wrapper` function encapsulates all of the throttling / debouncing\r\n   * functionality and when executed will limit the rate at which `callback`\r\n   * is executed.\r\n   */\r\n\r\n\r\n  function wrapper() {\r\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      arguments_[_key] = arguments[_key];\r\n    }\r\n\r\n    var self = this;\r\n    var elapsed = Date.now() - lastExec;\r\n\r\n    if (cancelled) {\r\n      return;\r\n    } // Execute `callback` and update the `lastExec` timestamp.\r\n\r\n\r\n    function exec() {\r\n      lastExec = Date.now();\r\n      callback.apply(self, arguments_);\r\n    }\r\n    /*\r\n     * If `debounceMode` is true (at begin) this is used to clear the flag\r\n     * to allow future `callback` executions.\r\n     */\r\n\r\n\r\n    function clear() {\r\n      timeoutID = undefined;\r\n    }\r\n\r\n    if (debounceMode && !timeoutID) {\r\n      /*\r\n       * Since `wrapper` is being called for the first time and\r\n       * `debounceMode` is true (at begin), execute `callback`.\r\n       */\r\n      exec();\r\n    }\r\n\r\n    clearExistingTimeout();\r\n\r\n    if (debounceMode === undefined && elapsed > delay) {\r\n      /*\r\n       * In throttle mode, if `delay` time has been exceeded, execute\r\n       * `callback`.\r\n       */\r\n      exec();\r\n    } else if (noTrailing !== true) {\r\n      /*\r\n       * In trailing throttle mode, since `delay` time has not been\r\n       * exceeded, schedule `callback` to execute `delay` ms after most\r\n       * recent execution.\r\n       *\r\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\r\n       * after `delay` ms.\r\n       *\r\n       * If `debounceMode` is false (at end), schedule `callback` to\r\n       * execute after `delay` ms.\r\n       */\r\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\r\n    }\r\n  }\r\n\r\n  wrapper.cancel = cancel; // Return the wrapper function.\r\n\r\n  return wrapper;\r\n}\r\n\r\n/* eslint-disable no-undefined */\r\n/**\r\n * Debounce execution of a function. Debouncing, unlike throttling,\r\n * guarantees that a function is only executed a single time, either at the\r\n * very beginning of a series of calls, or at the very end.\r\n *\r\n * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\r\n * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\r\n *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\r\n *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\r\n * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\r\n *                                  to `callback` when the debounced-function is executed.\r\n *\r\n * @returns {Function} A new, debounced function.\r\n */\r\n\r\nfunction debounce (delay, atBegin, callback) {\r\n  return callback === undefined ? throttle(delay, atBegin, false) : throttle(delay, callback, atBegin !== false);\r\n}\r\n\r\nexports.debounce = debounce;\r\nexports.throttle = throttle;\r\n//# sourceMappingURL=index.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGhyb3R0bGUtZGVib3VuY2UvY2pzL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBLFlBQVksV0FBVztBQUN2QjtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxhQUFhO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aHJvdHRsZS1kZWJvdW5jZS9janMvaW5kZXguanM/N2VkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWZpbmVkLG5vLXBhcmFtLXJlYXNzaWduLG5vLXNoYWRvdyAqL1xyXG5cclxuLyoqXHJcbiAqIFRocm90dGxlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBFc3BlY2lhbGx5IHVzZWZ1bCBmb3IgcmF0ZSBsaW1pdGluZ1xyXG4gKiBleGVjdXRpb24gb2YgaGFuZGxlcnMgb24gZXZlbnRzIGxpa2UgcmVzaXplIGFuZCBzY3JvbGwuXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gICAgZGVsYXkgLSAgICAgICAgICBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudCBjYWxsYmFja3MsIHZhbHVlcyBhcm91bmQgMTAwIG9yIDI1MCAob3IgZXZlbiBoaWdoZXIpIGFyZSBtb3N0IHVzZWZ1bC5cclxuICogQHBhcmFtICB7Ym9vbGVhbn0gICBbbm9UcmFpbGluZ10gLSAgIE9wdGlvbmFsLCBkZWZhdWx0cyB0byBmYWxzZS4gSWYgbm9UcmFpbGluZyBpcyB0cnVlLCBjYWxsYmFjayB3aWxsIG9ubHkgZXhlY3V0ZSBldmVyeSBgZGVsYXlgIG1pbGxpc2Vjb25kcyB3aGlsZSB0aGVcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub1RyYWlsaW5nIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIGJlIGV4ZWN1dGVkIG9uZSBmaW5hbCB0aW1lXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgdGhyb3R0bGVkLWZ1bmN0aW9uIGNhbGwuIChBZnRlciB0aGUgdGhyb3R0bGVkLWZ1bmN0aW9uIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIGBkZWxheWAgbWlsbGlzZWNvbmRzLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cclxuICogQHBhcmFtICB7RnVuY3Rpb259ICBjYWxsYmFjayAtICAgICAgIEEgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgZGVsYXkgbWlsbGlzZWNvbmRzLiBUaGUgYHRoaXNgIGNvbnRleHQgYW5kIGFsbCBhcmd1bWVudHMgYXJlIHBhc3NlZCB0aHJvdWdoLCBhcy1pcyxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byBgY2FsbGJhY2tgIHdoZW4gdGhlIHRocm90dGxlZC1mdW5jdGlvbiBpcyBleGVjdXRlZC5cclxuICogQHBhcmFtICB7Ym9vbGVhbn0gICBbZGVib3VuY2VNb2RlXSAtIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlIGFmdGVyIGBkZWxheWAgbXMuIElmIGBkZWJvdW5jZU1vZGVgIGlzIGZhbHNlIChhdCBlbmQpLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259ICBBIG5ldywgdGhyb3R0bGVkLCBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHRocm90dGxlIChkZWxheSwgbm9UcmFpbGluZywgY2FsbGJhY2ssIGRlYm91bmNlTW9kZSkge1xyXG4gIC8qXHJcbiAgICogQWZ0ZXIgd3JhcHBlciBoYXMgc3RvcHBlZCBiZWluZyBjYWxsZWQsIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXRcclxuICAgKiBgY2FsbGJhY2tgIGlzIGV4ZWN1dGVkIGF0IHRoZSBwcm9wZXIgdGltZXMgaW4gYHRocm90dGxlYCBhbmQgYGVuZGBcclxuICAgKiBkZWJvdW5jZSBtb2Rlcy5cclxuICAgKi9cclxuICB2YXIgdGltZW91dElEO1xyXG4gIHZhciBjYW5jZWxsZWQgPSBmYWxzZTsgLy8gS2VlcCB0cmFjayBvZiB0aGUgbGFzdCB0aW1lIGBjYWxsYmFja2Agd2FzIGV4ZWN1dGVkLlxyXG5cclxuICB2YXIgbGFzdEV4ZWMgPSAwOyAvLyBGdW5jdGlvbiB0byBjbGVhciBleGlzdGluZyB0aW1lb3V0XHJcblxyXG4gIGZ1bmN0aW9uIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCkge1xyXG4gICAgaWYgKHRpbWVvdXRJRCkge1xyXG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElEKTtcclxuICAgIH1cclxuICB9IC8vIEZ1bmN0aW9uIHRvIGNhbmNlbCBuZXh0IGV4ZWNcclxuXHJcblxyXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcclxuICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XHJcbiAgICBjYW5jZWxsZWQgPSB0cnVlO1xyXG4gIH0gLy8gYG5vVHJhaWxpbmdgIGRlZmF1bHRzIHRvIGZhbHN5LlxyXG5cclxuXHJcbiAgaWYgKHR5cGVvZiBub1RyYWlsaW5nICE9PSAnYm9vbGVhbicpIHtcclxuICAgIGRlYm91bmNlTW9kZSA9IGNhbGxiYWNrO1xyXG4gICAgY2FsbGJhY2sgPSBub1RyYWlsaW5nO1xyXG4gICAgbm9UcmFpbGluZyA9IHVuZGVmaW5lZDtcclxuICB9XHJcbiAgLypcclxuICAgKiBUaGUgYHdyYXBwZXJgIGZ1bmN0aW9uIGVuY2Fwc3VsYXRlcyBhbGwgb2YgdGhlIHRocm90dGxpbmcgLyBkZWJvdW5jaW5nXHJcbiAgICogZnVuY3Rpb25hbGl0eSBhbmQgd2hlbiBleGVjdXRlZCB3aWxsIGxpbWl0IHRoZSByYXRlIGF0IHdoaWNoIGBjYWxsYmFja2BcclxuICAgKiBpcyBleGVjdXRlZC5cclxuICAgKi9cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XHJcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzXyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgYXJndW1lbnRzX1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICB2YXIgZWxhcHNlZCA9IERhdGUubm93KCkgLSBsYXN0RXhlYztcclxuXHJcbiAgICBpZiAoY2FuY2VsbGVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH0gLy8gRXhlY3V0ZSBgY2FsbGJhY2tgIGFuZCB1cGRhdGUgdGhlIGBsYXN0RXhlY2AgdGltZXN0YW1wLlxyXG5cclxuXHJcbiAgICBmdW5jdGlvbiBleGVjKCkge1xyXG4gICAgICBsYXN0RXhlYyA9IERhdGUubm93KCk7XHJcbiAgICAgIGNhbGxiYWNrLmFwcGx5KHNlbGYsIGFyZ3VtZW50c18pO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSB0aGlzIGlzIHVzZWQgdG8gY2xlYXIgdGhlIGZsYWdcclxuICAgICAqIHRvIGFsbG93IGZ1dHVyZSBgY2FsbGJhY2tgIGV4ZWN1dGlvbnMuXHJcbiAgICAgKi9cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gY2xlYXIoKSB7XHJcbiAgICAgIHRpbWVvdXRJRCA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZGVib3VuY2VNb2RlICYmICF0aW1lb3V0SUQpIHtcclxuICAgICAgLypcclxuICAgICAgICogU2luY2UgYHdyYXBwZXJgIGlzIGJlaW5nIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXHJcbiAgICAgICAqIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgZXhlY3V0ZSBgY2FsbGJhY2tgLlxyXG4gICAgICAgKi9cclxuICAgICAgZXhlYygpO1xyXG4gICAgfVxyXG5cclxuICAgIGNsZWFyRXhpc3RpbmdUaW1lb3V0KCk7XHJcblxyXG4gICAgaWYgKGRlYm91bmNlTW9kZSA9PT0gdW5kZWZpbmVkICYmIGVsYXBzZWQgPiBkZWxheSkge1xyXG4gICAgICAvKlxyXG4gICAgICAgKiBJbiB0aHJvdHRsZSBtb2RlLCBpZiBgZGVsYXlgIHRpbWUgaGFzIGJlZW4gZXhjZWVkZWQsIGV4ZWN1dGVcclxuICAgICAgICogYGNhbGxiYWNrYC5cclxuICAgICAgICovXHJcbiAgICAgIGV4ZWMoKTtcclxuICAgIH0gZWxzZSBpZiAobm9UcmFpbGluZyAhPT0gdHJ1ZSkge1xyXG4gICAgICAvKlxyXG4gICAgICAgKiBJbiB0cmFpbGluZyB0aHJvdHRsZSBtb2RlLCBzaW5jZSBgZGVsYXlgIHRpbWUgaGFzIG5vdCBiZWVuXHJcbiAgICAgICAqIGV4Y2VlZGVkLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvIGV4ZWN1dGUgYGRlbGF5YCBtcyBhZnRlciBtb3N0XHJcbiAgICAgICAqIHJlY2VudCBleGVjdXRpb24uXHJcbiAgICAgICAqXHJcbiAgICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIHRydWUgKGF0IGJlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlXHJcbiAgICAgICAqIGFmdGVyIGBkZWxheWAgbXMuXHJcbiAgICAgICAqXHJcbiAgICAgICAqIElmIGBkZWJvdW5jZU1vZGVgIGlzIGZhbHNlIChhdCBlbmQpLCBzY2hlZHVsZSBgY2FsbGJhY2tgIHRvXHJcbiAgICAgICAqIGV4ZWN1dGUgYWZ0ZXIgYGRlbGF5YCBtcy5cclxuICAgICAgICovXHJcbiAgICAgIHRpbWVvdXRJRCA9IHNldFRpbWVvdXQoZGVib3VuY2VNb2RlID8gY2xlYXIgOiBleGVjLCBkZWJvdW5jZU1vZGUgPT09IHVuZGVmaW5lZCA/IGRlbGF5IC0gZWxhcHNlZCA6IGRlbGF5KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHdyYXBwZXIuY2FuY2VsID0gY2FuY2VsOyAvLyBSZXR1cm4gdGhlIHdyYXBwZXIgZnVuY3Rpb24uXHJcblxyXG4gIHJldHVybiB3cmFwcGVyO1xyXG59XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlZmluZWQgKi9cclxuLyoqXHJcbiAqIERlYm91bmNlIGV4ZWN1dGlvbiBvZiBhIGZ1bmN0aW9uLiBEZWJvdW5jaW5nLCB1bmxpa2UgdGhyb3R0bGluZyxcclxuICogZ3VhcmFudGVlcyB0aGF0IGEgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBhIHNpbmdsZSB0aW1lLCBlaXRoZXIgYXQgdGhlXHJcbiAqIHZlcnkgYmVnaW5uaW5nIG9mIGEgc2VyaWVzIG9mIGNhbGxzLCBvciBhdCB0aGUgdmVyeSBlbmQuXHJcbiAqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gICBkZWxheSAtICAgICAgICAgQSB6ZXJvLW9yLWdyZWF0ZXIgZGVsYXkgaW4gbWlsbGlzZWNvbmRzLiBGb3IgZXZlbnQgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXHJcbiAqIEBwYXJhbSAge2Jvb2xlYW59ICBbYXRCZWdpbl0gLSAgICAgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBhdEJlZ2luIGlzIGZhbHNlIG9yIHVuc3BlY2lmaWVkLCBjYWxsYmFjayB3aWxsIG9ubHkgYmUgZXhlY3V0ZWQgYGRlbGF5YCBtaWxsaXNlY29uZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWZ0ZXIgdGhlIGxhc3QgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwuIElmIGF0QmVnaW4gaXMgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBiZSBleGVjdXRlZCBvbmx5IGF0IHRoZSBmaXJzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC5cclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKEFmdGVyIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaGFzIG5vdCBiZWVuIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KS5cclxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrIC0gICAgICBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy4gVGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhbGwgYXJndW1lbnRzIGFyZSBwYXNzZWQgdGhyb3VnaCwgYXMtaXMsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGBjYWxsYmFja2Agd2hlbiB0aGUgZGVib3VuY2VkLWZ1bmN0aW9uIGlzIGV4ZWN1dGVkLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IEEgbmV3LCBkZWJvdW5jZWQgZnVuY3Rpb24uXHJcbiAqL1xyXG5cclxuZnVuY3Rpb24gZGVib3VuY2UgKGRlbGF5LCBhdEJlZ2luLCBjYWxsYmFjaykge1xyXG4gIHJldHVybiBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gdGhyb3R0bGUoZGVsYXksIGF0QmVnaW4sIGZhbHNlKSA6IHRocm90dGxlKGRlbGF5LCBjYWxsYmFjaywgYXRCZWdpbiAhPT0gZmFsc2UpO1xyXG59XHJcblxyXG5leHBvcnRzLmRlYm91bmNlID0gZGVib3VuY2U7XHJcbmV4cG9ydHMudGhyb3R0bGUgPSB0aHJvdHRsZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/throttle-debounce/cjs/index.js\n");

/***/ })

}]);